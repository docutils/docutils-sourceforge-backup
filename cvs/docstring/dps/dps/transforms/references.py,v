head	1.13;
access;
symbols;
locks; strict;
comment	@# @;


1.13
date	2002.04.13.17.06.18;	author goodger;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.16.05.59.38;	author goodger;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.13.02.47.35;	author goodger;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.11.03.40.58;	author goodger;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.08.04.31.44;	author goodger;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.07.04.01.40;	author goodger;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.22.02.11.24;	author goodger;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.20.04.14.15;	author goodger;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.06.02.50.31;	author goodger;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.30.04.52.17;	author goodger;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.29.02.17.32;	author goodger;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.28.02.19.47;	author goodger;	state Exp;
branches;
next	1.1;

1.1
date	2002.01.26.00.10.09;	author goodger;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Reworked reference resolution.
@
text
@#! /usr/bin/env python
"""
:Authors: David Goodger
:Contact: goodger@@users.sourceforge.net
:Revision: $Revision: 1.12 $
:Date: $Date: 2002/03/16 05:59:38 $
:Copyright: This module has been placed in the public domain.

Transforms for resolving references:

- `Hyperlinks`: Used to resolve hyperlink targets and references.
- `Footnotes`: Resolve footnote numbering and references.
- `Substitutions`: Resolve substitutions.
"""

__docformat__ = 'reStructuredText'

import re
from dps import nodes, utils
from dps.transforms import TransformError, Transform


class Hyperlinks(Transform):

    """Resolve the various types of hyperlink targets and references."""

    def transform(self):
        stages = []
        #stages.append('Beginning of references.Hyperlinks.transform()\n' + self.doctree.pformat())
        self.resolve_chained_targets()
        #stages.append('After references.Hyperlinks.resolve_chained_targets()\n' + self.doctree.pformat())
        self.resolve_anonymous()
        #stages.append('After references.Hyperlinks.resolve_anonymous()\n' + self.doctree.pformat())
        self.resolve_indirect()
        #stages.append('After references.Hyperlinks.resolve_indirect()\n' + self.doctree.pformat())
        self.resolve_external_targets()
        #stages.append('After references.Hyperlinks.resolve_external_references()\n' + self.doctree.pformat())
        self.resolve_internal_targets()
        #stages.append('After references.Hyperlinks.resolve_internal_references()\n' + self.doctree.pformat())
        #import difflib
        #compare = difflib.Differ().compare
        #for i in range(len(stages) - 1):
        #    print ''.join(compare(stages[i].splitlines(1), stages[i+1].splitlines(1)))

    def resolve_chained_targets(self):
        """
        Attributes "refuri" and "refname" are migrated from the final direct
        target up the chain of contiguous adjacent internal targets, using
        `ChainedTargetResolver`.
        """
        visitor = ChainedTargetResolver(self.doctree)
        self.doctree.walk(visitor)

    def resolve_anonymous(self):
        """
        Link anonymous references to targets.  Given::

            <paragraph>
                <reference anonymous="1">
                    internal
                <reference anonymous="1">
                    external
            <target anonymous="1" id="id1">
            <target anonymous="1" id="id2" refuri="http://external">

        Corresponding references are linked via "refid" or resolved via
        "refuri"::

            <paragraph>
                <reference anonymous="1" refid="id1">
                    text
                <reference anonymous="1" refuri="http://external">
                    external
            <target anonymous="1" id="id1">
            <target anonymous="1" id="id2" refuri="http://external">
        """
        if len(self.doctree.anonymous_refs) \
              != len(self.doctree.anonymous_targets):
            msg = self.doctree.reporter.error(
                  'Anonymous hyperlink mismatch: %s references but %s targets.'
                  % (len(self.doctree.anonymous_refs),
                     len(self.doctree.anonymous_targets)))
            self.doctree.messages += msg
            msgid = self.doctree.set_id(msg)
            for ref in self.doctree.anonymous_refs:
                prb = nodes.problematic(
                      ref.rawsource, ref.rawsource, refid=msgid)
                prbid = self.doctree.set_id(prb)
                msg.add_backref(prbid)
                ref.parent.replace(ref, prb)
            return
        for i in range(len(self.doctree.anonymous_refs)):
            ref = self.doctree.anonymous_refs[i]
            target = self.doctree.anonymous_targets[i]
            if target.hasattr('refuri'):
                ref['refuri'] = target['refuri']
                ref.resolved = 1
            else:
                ref['refid'] = target['id']
                self.doctree.note_refid(ref)
            target.referenced = 1

    def resolve_indirect(self):
        """
        a) Indirect external references::

               <paragraph>
                   <reference refname="indirect external">
                       indirect external
               <target id="id1" name="direct external"
                   refuri="http://indirect">
               <target id="id2" name="indirect external"
                   refname="direct external">

           The "refuri" attribute is migrated back to all indirect targets from
           the final direct target (i.e. a target not referring to another
           indirect target)::

               <paragraph>
                   <reference refname="indirect external">
                       indirect external
               <target id="id1" name="direct external"
                   refuri="http://indirect">
               <target id="id2" name="indirect external"
                   refuri="http://indirect">

           Once the attribute is migrated, the preexisting "refname" attribute
           is dropped.

        b) Indirect internal references::

               <target id="id1" name="final target">
               <paragraph>
                   <reference refname="indirect internal">
                       indirect internal
               <target id="id2" name="indirect internal 2"
                   refname="final target">
               <target id="id3" name="indirect internal"
                   refname="indirect internal 2">

           Targets which indirectly refer to an internal target become one-hop
           indirect (their "refid" attributes are directly set to the internal
           target's "id"). References which indirectly refer to an internal
           target become direct internal references::

               <target id="id1" name="final target">
               <paragraph>
                   <reference refid="id1">
                       indirect internal
               <target id="id2" name="indirect internal 2" refid="id1">
               <target id="id3" name="indirect internal" refid="id1">
        """
        #import mypdb as pdb
        #pdb.set_trace()
        for target in self.doctree.indirect_targets:
            if not target.resolved:
                self.resolve_indirect_target(target)
            self.resolve_indirect_references(target)

    def resolve_indirect_target(self, target):
        refname = target['refname']
        reftarget = None
        if self.doctree.explicit_targets.has_key(refname):
            reftarget = self.doctree.explicit_targets[refname]
        elif self.doctree.implicit_targets.has_key(refname):
            reftarget = self.doctree.implicit_targets[refname]
        if not reftarget:
            self.nonexistent_indirect_target(target)
            return
        if isinstance(reftarget, nodes.target) \
              and not reftarget.resolved and reftarget.hasattr('refname'):
            self.one_indirect_target(reftarget) # multiply indirect
        if reftarget.hasattr('refuri'):
            target['refuri'] = reftarget['refuri']
            if target.hasattr('name'):
                self.doctree.note_external_target(target)
        elif reftarget.hasattr('refid'):
            target['refid'] = reftarget['refid']
            self.doctree.note_refid(target)
        else:
            try:
                target['refid'] = reftarget['id']
                self.doctree.note_refid(target)
            except KeyError:
                self.nonexistent_indirect_target(target)
                return
        del target['refname']
        target.resolved = 1
        reftarget.referenced = 1

    def nonexistent_indirect_target(self, target):
        naming = ''
        if target.hasattr('name'):
            naming = '"%s" ' % target['name']
            reflist = self.doctree.refnames[target['name']]
        else:
            reflist = self.doctree.refnames[target['id']]
        naming += '(id="%s")' % target['id']
        msg = self.doctree.reporter.warning(
              'Indirect hyperlink target %s refers to target "%s", '
              'which does not exist.' % (naming, target['refname']))
        self.doctree.messages += msg
        msgid = self.doctree.set_id(msg)
        for ref in reflist:
            prb = nodes.problematic(
                  ref.rawsource, ref.rawsource, refid=msgid)
            prbid = self.doctree.set_id(prb)
            msg.add_backref(prbid)
            ref.parent.replace(ref, prb)
        target.resolved = 1

    def resolve_indirect_references(self, target):
        if target.hasattr('refid'):
            attname = 'refid'
            call_if_named = 0
            call_method = self.doctree.note_refid
        elif target.hasattr('refuri'):
            attname = 'refuri'
            call_if_named = 1
            call_method = self.doctree.note_external_target
        else:
            return
        attval = target[attname]
        if target.hasattr('name'):
            name = target['name']
            try:
                reflist = self.doctree.refnames[name]
            except KeyError, instance:
                if target.referenced:
                    return
                msg = self.doctree.reporter.info(
                      'Indirect hyperlink target "%s" is not referenced.'
                      % name)
                self.doctree.messages += msg
                target.referenced = 1
                return
            delatt = 'refname'
        else:
            id = target['id']
            try:
                reflist = self.doctree.refids[id]
            except KeyError, instance:
                if target.referenced:
                    return
                msg = self.doctree.reporter.info(
                      'Indirect hyperlink target id="%s" is not referenced.'
                      % id)
                self.doctree.messages += msg
                target.referenced = 1
                return
            delatt = 'refid'
        for ref in reflist:
            if ref.resolved:
                continue
            del ref[delatt]
            ref[attname] = attval
            if not call_if_named or ref.hasattr('name'):
                call_method(ref)
            ref.resolved = 1
            if isinstance(ref, nodes.target):
                self.resolve_indirect_references(ref)
        target.referenced = 1

    def resolve_external_targets(self):
        """
        Given::

            <paragraph>
                <reference refname="direct external">
                    direct external
            <target id="id1" name="direct external" refuri="http://direct">

        The "refname" attribute is replaced by the direct "refuri" attribute::

            <paragraph>
                <reference refuri="http://direct">
                    direct external
            <target id="id1" name="direct external" refuri="http://direct">
        """
        for target in self.doctree.external_targets:
            if target.hasattr('refuri') and target.hasattr('name'):
                name = target['name']
                refuri = target['refuri']
                try:
                    reflist = self.doctree.refnames[name]
                except KeyError, instance:
                    if target.referenced:
                        continue
                    msg = self.doctree.reporter.info(
                          'External hyperlink target "%s" is not referenced.'
                          % name)
                    self.doctree.messages += msg
                    target.referenced = 1
                    continue
                for ref in reflist:
                    if ref.resolved:
                        continue
                    del ref['refname']
                    ref['refuri'] = refuri
                    ref.resolved = 1
                target.referenced = 1

    def resolve_internal_targets(self):
        """
        Given::

            <paragraph>
                <reference refname="direct internal">
                    direct internal
            <target id="id1" name="direct internal">

        The "refname" attribute is replaced by "refid" linking to the target's
        "id"::

            <paragraph>
                <reference refid="id1">
                    direct internal
            <target id="id1" name="direct internal">
        """
        for target in self.doctree.internal_targets:
            if target.hasattr('refuri') or target.hasattr('refid') \
                  or not target.hasattr('name'):
                continue
            name = target['name']
            refid = target['id']
            try:
                reflist = self.doctree.refnames[name]
            except KeyError, instance:
                if target.referenced:
                    continue
                msg = self.doctree.reporter.info(
                      'Internal hyperlink target "%s" is not referenced.'
                      % name)
                self.doctree.messages += msg
                target.referenced = 1
                continue
            for ref in reflist:
                if ref.resolved:
                    continue
                del ref['refname']
                ref['refid'] = refid
                ref.resolved = 1
            target.referenced = 1


class ChainedTargetResolver(nodes.NodeVisitor):

    """
    Copy reference attributes up the length of a hyperlink target chain.

    "Chained targets" are multiple adjacent internal hyperlink targets which
    "point to" an external or indirect target.  After the transform, all
    chained targets will effectively point to the same place.

    Given the following ``doctree`` as input::

        <document>
            <target id="a" name="a">
            <target id="b" name="b">
            <target id="c" name="c" refuri="http://chained.external.targets">
            <target id="d" name="d">
            <paragraph>
                I'm known as "d".
            <target id="e" name="e">
            <target id="id1">
            <target id="f" name="f" refname="d">

    ``ChainedTargetResolver(doctree).walk()`` will transform the above into::

        <document>
            <target id="a" name="a" refuri="http://chained.external.targets">
            <target id="b" name="b" refuri="http://chained.external.targets">
            <target id="c" name="c" refuri="http://chained.external.targets">
            <target id="d" name="d">
            <paragraph>
                I'm known as "d".
            <target id="e" name="e" refname="d">
            <target id="id1" refname="d">
            <target id="f" name="f" refname="d">
    """

    def unknown_visit(self, node):
        pass

    def visit_target(self, node):
        if node.hasattr('refuri'):
            attname = 'refuri'
            call_if_named = self.doctree.note_external_target
        elif node.hasattr('refname'):
            attname = 'refname'
            call_if_named = self.doctree.note_indirect_target
        elif node.hasattr('refid'):
            attname = 'refid'
            call_if_named = None
        else:
            return
        attval = node[attname]
        index = node.parent.index(node)
        for i in range(index - 1, -1, -1):
            sibling = node.parent[i]
            if not isinstance(sibling, nodes.target) \
                  or sibling.hasattr('refuri') \
                  or sibling.hasattr('refname') \
                  or sibling.hasattr('refid'):
                break
            sibling[attname] = attval
            if sibling.hasattr('name') and call_if_named:
                call_if_named(sibling)


class Footnotes(Transform):

    """
    Assign numbers to autonumbered footnotes, and resolve links to footnotes,
    citations, and their references.

    Given the following ``doctree`` as input::

        <document>
            <paragraph>
                A labeled autonumbered footnote referece:
                <footnote_reference auto="1" id="id1" refname="footnote">
            <paragraph>
                An unlabeled autonumbered footnote referece:
                <footnote_reference auto="1" id="id2">
            <footnote auto="1" id="id3">
                <paragraph>
                    Unlabeled autonumbered footnote.
            <footnote auto="1" id="footnote" name="footnote">
                <paragraph>
                    Labeled autonumbered footnote.

    Auto-numbered footnotes have attribute ``auto="1"`` and no label.
    Auto-numbered footnote_references have no reference text (they're
    empty elements). When resolving the numbering, a ``label`` element
    is added to the beginning of the ``footnote``, and reference text
    to the ``footnote_reference``.

    The transformed result will be::

        <document>
            <paragraph>
                A labeled autonumbered footnote referece:
                <footnote_reference auto="1" id="id1" refid="footnote">
                    2
            <paragraph>
                An unlabeled autonumbered footnote referece:
                <footnote_reference auto="1" id="id2" refid="id3">
                    1
            <footnote auto="1" id="id3" backrefs="id2">
                <label>
                    1
                <paragraph>
                    Unlabeled autonumbered footnote.
            <footnote auto="1" id="footnote" name="footnote" backrefs="id1">
                <label>
                    2
                <paragraph>
                    Labeled autonumbered footnote.

    Note that the footnotes are not in the same order as the references.

    The labels and reference text are added to the auto-numbered ``footnote``
    and ``footnote_reference`` elements.  Footnote elements are backlinked to
    their references via "refids" attributes.  References are assigned "id"
    and "refid" attributes.

    After adding labels and reference text, the "auto" attributes can be
    ignored.
    """

    autofootnote_labels = None
    """Keep track of unlabeled autonumbered footnotes."""

    symbols = [
          # Entries 1-4 and 6 below are from section 12.51 of
          # The Chicago Manual of Style, 14th edition.
          '*',                          # asterisk/star
          u'\u2020',                    # dagger &dagger;
          u'\u2021',                    # double dagger &Dagger;
          u'\u00A7',                    # section mark &sect;
          u'\u00B6',                    # paragraph mark (pilcrow) &para;
                                        # (parallels ['||'] in CMoS)
          '#',                          # number sign
          # The entries below were chosen arbitrarily.
          u'\u2660',                    # spade suit &spades;
          u'\u2665',                    # heart suit &hearts;
          u'\u2666',                    # diamond suit &diams;
          u'\u2663',                    # club suit &clubs;
          ]

    def transform(self):
        self.autofootnote_labels = []
        startnum = self.doctree.autofootnote_start
        self.doctree.autofootnote_start = self.number_footnotes(startnum)
        self.number_footnote_references(startnum)
        self.symbolize_footnotes()
        self.resolve_footnotes_and_citations()

    def number_footnotes(self, startnum):
        """
        Assign numbers to autonumbered footnotes.

        For labeled autonumbered footnotes, copy the number over to
        corresponding footnote references.
        """
        for footnote in self.doctree.autofootnotes:
            while 1:
                label = str(startnum)
                startnum += 1
                if not self.doctree.explicit_targets.has_key(label):
                    break
            footnote.insert(0, nodes.label('', label))
            if footnote.hasattr('dupname'):
                continue
            if footnote.hasattr('name'):
                name = footnote['name']
                for ref in self.doctree.footnote_refs.get(name, []):
                    ref += nodes.Text(label)
                    ref.delattr('refname')
                    ref['refid'] = footnote['id']
                    footnote.add_backref(ref['id'])
                    self.doctree.note_refid(ref)
                    ref.resolved = 1
            else:
                footnote['name'] = label
                self.doctree.note_explicit_target(footnote, footnote)
                self.autofootnote_labels.append(label)
        return startnum

    def number_footnote_references(self, startnum):
        """Assign numbers to autonumbered footnote references."""
        i = 0
        for ref in self.doctree.autofootnote_refs:
            if ref.resolved or ref.hasattr('refid'):
                continue
            try:
                label = self.autofootnote_labels[i]
            except IndexError:
                msg = self.doctree.reporter.error(
                      'Too many autonumbered footnote references: only %s '
                      'corresponding footnotes available.'
                      % len(self.autofootnote_labels))
                msgid = self.doctree.set_id(msg)
                self.doctree.messages += msg
                for ref in self.doctree.autofootnote_refs[i:]:
                    if ref.resolved or ref.hasattr('refname'):
                        continue
                    prb = nodes.problematic(
                          ref.rawsource, ref.rawsource, refid=msgid)
                    prbid = self.doctree.set_id(prb)
                    msg.add_backref(prbid)
                    ref.parent.replace(ref, prb)
                break
            ref += nodes.Text(label)
            footnote = self.doctree.explicit_targets[label]
            ref['refid'] = footnote['id']
            self.doctree.note_refid(ref)
            footnote.add_backref(ref['id'])
            ref.resolved = 1
            i += 1

    def symbolize_footnotes(self):
        """Add symbols indexes to "[*]"-style footnotes and references."""
        labels = []
        for footnote in self.doctree.symbol_footnotes:
            reps, index = divmod(self.doctree.symbol_footnote_start,
                                 len(self.symbols))
            labeltext = self.symbols[index] * (reps + 1)
            labels.append(labeltext)
            footnote.insert(0, nodes.label('', labeltext))
            self.doctree.symbol_footnote_start += 1
            self.doctree.set_id(footnote)
        i = 0
        for ref in self.doctree.symbol_footnote_refs:
            try:
                ref += nodes.Text(labels[i])
            except IndexError:
                msg = self.doctree.reporter.error(
                      'Too many symbol footnote references: only %s '
                      'corresponding footnotes available.' % len(labels))
                msgid = self.set_id(msg)
                self.doctree.messages += msg
                for ref in self.doctree.symbol_footnote_refs[i:]:
                    if ref.resolved or ref.hasattr('refid'):
                        continue
                    prb = nodes.problematic(
                          ref.rawsource, ref.rawsource, refid=msgid)
                    prbid = self.doctree.set_id(prb)
                    msg.add_backref(prbid)
                    ref.parent.replace(ref, prb)
                break
            footnote = self.doctree.symbol_footnotes[i]
            ref['refid'] = footnote['id']
            self.doctree.note_refid(ref)
            footnote.add_backref(ref['id'])
            i += 1

    def resolve_footnotes_and_citations(self):
        """
        Link manually-labeled footnotes and citations to/from their references.
        """
        for footnote in self.doctree.footnotes:
            label = footnote['name']
            if self.doctree.footnote_refs.has_key(label):
                reflist = self.doctree.footnote_refs[label]
                self.resolve_references(footnote, reflist)
        for citation in self.doctree.citations:
            label = citation['name']
            if self.doctree.citation_refs.has_key(label):
                reflist = self.doctree.citation_refs[label]
                self.resolve_references(citation, reflist)

    def resolve_references(self, note, reflist):
        id = note['id']
        for ref in reflist:
            if ref.resolved:
                continue
            ref.delattr('refname')
            ref['refid'] = id
            note.add_backref(ref['id'])
            ref.resolved = 1
        note.resolved = 1


class Substitutions(Transform):

    """
    Given the following ``doctree`` as input::

        <document>
            <paragraph>
                The
                <substitution_reference refname="biohazard">
                    biohazard
                 symbol is deservedly scary-looking.
            <substitution_definition name="biohazard">
                <image alt="biohazard" uri="biohazard.png">

    The ``substitution_reference`` will simply be replaced by the
    contents of the corresponding ``substitution_definition``.

    The transformed result will be::

        <document>
            <paragraph>
                The
                <image alt="biohazard" uri="biohazard.png">
                 symbol is deservedly scary-looking.
            <substitution_definition name="biohazard">
                <image alt="biohazard" uri="biohazard.png">
    """

    def transform(self):
        defs = self.doctree.substitution_defs
        for refname, refs in self.doctree.substitution_refs.items():
            for ref in refs:
                if defs.has_key(refname):
                    ref.parent.replace(ref, defs[refname].getchildren())
                else:
                    msg = self.doctree.reporter.error(
                          'Undefined substitution referenced: "%s".' % refname)
                    msgid = self.doctree.set_id(msg)
                    self.doctree.messages += msg
                    prb = nodes.problematic(
                          ref.rawsource, ref.rawsource, refid=msgid)
                    prbid = self.doctree.set_id(prb)
                    msg.add_backref(prbid)
                    ref.parent.replace(ref, prb)
        self.doctree.substitution_refs = None  # release replaced references
@


1.12
log
@  - API update.
@
text
@d5 2
a6 2
:Revision: $Revision: 1.11 $
:Date: $Date: 2002/03/13 02:47:35 $
d25 1
a25 95
    """
    Resolve the various types of hyperlink targets and references.

    Shown in isolation, the following individual transforms are performed:

    1. Anonymous references and targets::

           <paragraph>
               <reference anonymous="1">
                   text
           <target anonymous="1">

       Corresponding references and targets are assigned ids::

           <paragraph>
               <reference anonymous="1" refid="id1">
                   text
           <target anonymous="1" id="id1">

    2. Chained targets::

           <target id="id1" name="chained">
           <target id="id2" name="external hyperlink" refuri="http://uri">

       Attributes "refuri" and "refname" are migrated from the final concrete
       target up the chain of contiguous adjacent internal targets::

           <target id="id1" name="chained" refuri="http://uri">
           <target id="id2" name="external hyperlink" refuri="http://uri">

    3. a) Indirect targets::

              <paragraph>
                  <reference refname="indirect external">
                      indirect external
              <target id="id1" name="direct external"
                  refuri="http://indirect">
              <target id="id2" name="indirect external"
                  refname="direct external">

          Attributes "refuri" and "refname" are migrated back to all indirect
          targets from the final concrete target (i.e. not referring to
          another indirect target)::

              <paragraph>
                  <reference refname="indirect external">
                      indirect external
              <target id="id1" name="direct external"
                  refuri="http://indirect">
              <target id="id2" name="indirect external"
                  refuri="http://indirect">

          If the "refuri" attribute is migrated, the preexisting "refname"
          attribute is dropped. This turns indirect external references into
          direct external references.

       b) Indirect internal references::

              <target id="id1" name="final target">
              <paragraph>
                  <reference refname="indirect internal">
                      indirect internal
              <target id="id2" name="indirect internal 2"
                  refname="final target">
              <target id="id3" name="indirect internal"
                  refname="indirect internal 2">

          Targets which indirectly refer to an internal target become one-hop
          indirect (their "refname" attributes are directly set to the
          internal target's "name"). References which indirectly refer to an
          internal target become direct internal references::

              <target id="id1" name="final target">
              <paragraph>
                  <reference refname="final target">
                      indirect internal
              <target id="id2" name="indirect internal 2"
                  refname="final target">
              <target id="id3" name="indirect internal"
                  refname="final target">

    4. External references::

           <paragraph>
               <reference refname="direct external">
                   direct external
           <target id="id1" name="direct external" refuri="http://direct">

       The "refname" attribute is replaced by the direct "refuri" attribute::

           <paragraph>
               <reference refuri="http://direct">
                   direct external
           <target id="id1" name="direct external" refuri="http://direct">
    """
d28 4
d33 1
a33 1
        self.resolve_chained_targets()
d35 18
a52 1
        self.resolve_external_references()
d55 22
d84 7
a92 2
            name = '_:%s:_' % self.doctree.anonymous_start
            self.doctree.anonymous_start += 1
a93 2
            ref['refname'] = name
            self.doctree.note_refname(ref)
d95 7
a101 11
            target['name'] = name
            id = self.doctree.set_id(target)
            self.doctree.note_implicit_target(target, self.doctree)
            if target.hasattr('refname'):
                #ref['refname'] = target['refname']
                self.doctree.note_indirect_target(target)
            elif target.hasattr('refuri'):
                #ref['refuri'] = target['refuri']
                self.doctree.note_external_target(target)
            #else:
            #    ref['refid'] = id
d103 3
a105 3
    def resolve_chained_targets(self):
        visitor = ChainedTargetResolver(self.doctree)
        self.doctree.walk(visitor)
d107 49
a155 2
    def resolve_indirect(self):
        for name, target in self.doctree.indirect_targets.items():
d157 2
a158 4
                self.one_indirect_target(target)
            if target.hasattr('refname'):
                self.one_indirect_reference(target['name'],
                                            target['refname'])
d160 1
a160 2
    def one_indirect_target(self, target):
        name = target['name']
d162 1
d164 1
a164 16
            try:
                reftarget = self.doctree.explicit_targets[refname]
            except KeyError:
                self.nonexistent_indirect_target(name, refname, target)
                return
            if reftarget.hasattr('name'):
                if not reftarget.resolved and reftarget.hasattr('refname'):
                    self.one_indirect_target(reftarget) # multiply indirect
                if reftarget.hasattr('refuri'):
                    target['refuri'] = reftarget['refuri']
                    del target['refname']
                    self.doctree.note_external_target(target)
                elif reftarget.hasattr('refname'):
                    target['refname'] = reftarget['refname']
                #else: # @@@@@@ ?
                #    target['refid'] = reftarget['refid']
d167 14
d182 2
a183 1
                target['refname'] = reftarget['name']
d185 1
a185 1
                self.nonexistent_indirect_target(name, refname, target)
d187 1
a187 3
        else:
            self.nonexistent_indirect_target(name, refname, target)
            return
d189 1
d191 5
a195 3
    def nonexistent_indirect_target(self, name, refname, target):
        if target.hasattr('anonymous'):
            naming = '(id="%s")' % target['id']
d197 2
a198 1
            naming = '"%s"' % name
d201 1
a201 1
              'which does not exist.' % (naming, refname))
d203 8
d212 10
a221 8
    def one_indirect_reference(self, name, refname):
        try:
            reflist = self.doctree.refnames[name]
        except KeyError, instance:
            msg = self.doctree.reporter.info(
                  'Indirect hyperlink target "%s" is not referenced.'
                  % name)
            self.doctree.messages += msg
d223 30
a252 1
        for ref in self.doctree.refnames[name]:
d255 4
a258 1
            ref['refname'] = refname
d261 11
a271 1
                self.one_indirect_reference(ref['name'], refname)
d273 8
a280 2
    def resolve_external_references(self):
        for name, target in self.doctree.external_targets.items():
d282 20
a301 1
                self.one_external_reference(name, target['refuri'])
d303 33
a335 10
    def one_external_reference(self, name, refuri):
        try:
            reflist = self.doctree.refnames[name]
        except KeyError, instance:
            msg = self.doctree.reporter.info(
                  'External hyperlink target "%s" is not referenced.' % name)
            self.doctree.messages += msg
            return
        for ref in self.doctree.refnames[name]:
            if ref.resolved:
d337 7
a343 5
            ref['refuri'] = refuri
            del ref['refname']
            ref.resolved = 1
            if isinstance(ref, nodes.target):
                self.one_external_reference(ref['name'], refuri)
d352 1
a352 1
    "point to" an external or indirect target. After the transform, all
d358 4
a361 4
            <target name="a">
            <target name="b">
            <target name="c" refuri="http://chained.external.targets">
            <target name="d">
d364 3
a366 3
            <target name="e">
            <target name="f">
            <target name="g" refname="d">
d371 4
a374 4
            <target name="a" refuri="http://chained.external.targets">
            <target name="b" refuri="http://chained.external.targets">
            <target name="c" refuri="http://chained.external.targets">
            <target name="d">
d377 3
a379 3
            <target name="e" refname="d">
            <target name="f" refname="d">
            <target name="g" refname="d">
d387 2
a388 10
            refuri = node['refuri']
            index = node.parent.index(node)
            for i in range(index - 1, -1, -1):
                sibling = node.parent[i]
                if not isinstance(sibling, nodes.target) \
                      or sibling.hasattr('refuri') \
                      or sibling.hasattr('refname'):
                    break
                sibling['refuri'] = refuri
                self.doctree.note_external_target(sibling)
d390 19
a408 10
            refname = node['refname']
            index = node.parent.index(node)
            for i in range(index - 1, -1, -1):
                sibling = node.parent[i]
                if not isinstance(sibling, nodes.target) \
                      or sibling.hasattr('refuri') \
                      or sibling.hasattr('refname'):
                    break
                sibling['refname'] = refname
                self.doctree.note_indirect_target(sibling)
d414 2
a415 1
    Assign numbers and resolve links to autonumbered footnotes and references.
d422 1
a422 1
                <footnote_reference auto="1" refname="footnote">
d425 2
a426 2
                <footnote_reference auto="1">
            <footnote auto="1">
d429 1
a429 1
            <footnote auto="1" name="footnote">
d444 1
a444 1
                <footnote_reference auto="1" refname="footnote">
d448 1
a448 1
                <footnote_reference auto="1" refname="1">
d450 1
a450 1
            <footnote auto="1" name="1">
d455 1
a455 1
            <footnote auto="1" name="footnote">
d463 4
a466 4
    The labels and reference text are added to the auto-numbered
    ``footnote`` and ``footnote_reference`` elements. The unlabeled
    auto-numbered footnote and reference are assigned name and refname
    attributes respectively, being the footnote number.
d495 1
a495 1
        self.number_footnotes()
d498 1
d500 1
a500 1
    def number_footnotes(self):
d504 2
a505 2
        For labeled footnotes, copy the number over to corresponding footnote
        references.
d509 2
a510 2
                label = str(self.doctree.autofootnote_start)
                self.doctree.autofootnote_start += 1
d520 4
d529 1
d532 1
a532 1
        """Assign numbers to unlabeled autonumbered footnote references."""
d535 1
a535 1
            if ref.resolved or ref.hasattr('refname'):
d538 1
a538 2
                ref += nodes.Text(self.autofootnote_labels[i])
                ref['refname'] = self.autofootnote_labels[i]
d547 7
a553 5
                    if not (ref.resolved or ref.hasattr('refname')):
                        prb = nodes.problematic(ref.rawsource, ref.rawsource,
                                                refid=msgid)
                        ref.parent.replace(ref, prb)
                        # @@@@@@ insert reference to each prb in msg?
d555 5
a577 1
                ref['refid'] = self.doctree.symbol_footnotes[i]['id']
d585 7
a591 5
                    if not (ref.resolved or ref.hasattr('refid')):
                        prb = nodes.problematic(ref.rawsource, ref.rawsource,
                                                refid=msgid)
                        ref.parent.replace(ref, prb)
                        # @@@@@@ insert reference to each prb in msg?
d593 29
d623 2
a624 1
            i += 1
d666 1
a666 1
                          ref.rawsource, '', refid=msgid, *ref.getchildren())
d668 1
a669 1
                    msg['refid'] = prbid
@


1.11
log
@minor changes (warmup)
@
text
@d5 2
a6 2
:Revision: $Revision: 1.10 $
:Date: $Date: 2002/03/11 03:40:58 $
d121 1
a121 2
    def transform(self, doctree):
        self.setup_transform(doctree)
d252 1
a252 1
    Copy reference attributes up a length of hyperlink target chain.
d393 1
a393 2
    def transform(self, doctree):
        self.setup_transform(doctree)
d395 1
a395 1
        startnum = doctree.autofootnote_start
d512 1
a512 5
    def transform(self, doctree):
        self.setup_transform(doctree)
        self.do_substitutions()

    def do_substitutions(self):
@


1.10
log
@fixes & additions (system_message cross-references)
@
text
@d5 2
a6 2
:Revision: $Revision: 1.9 $
:Date: $Date: 2002/03/08 04:31:44 $
d37 1
a37 1
       Corresponding references and targets are assigned names::
d40 1
a40 1
               <reference anonymous="1" refname="_:1:_">
d42 1
a42 1
           <target anonymous="1" id="id1" name="_:1:_">
a141 1
            #del ref['anonymous']
d145 1
a145 1
            #del target['anonymous']
d148 1
d150 2
a151 1
            if target.hasattr('refuri'):
d153 2
d323 1
a323 1
                A labeled autonumbered footnote referece: 
d326 1
a326 1
                An unlabeled autonumbered footnote referece: 
d345 1
a345 1
                A labeled autonumbered footnote referece: 
d349 1
a349 1
                An unlabeled autonumbered footnote referece: 
d369 1
a369 1
    
d378 1
a378 1
          # The first six entries below are from section 12.51 of
a383 1
          # (Should be parallels; perhaps u'\u2016' &Verbar;? Not in HTML.)
d385 1
a388 1
          u'\u2663',                    # club suit &clubs;
d391 1
d493 1
a493 1
                The 
d507 1
a507 1
                The 
@


1.9
log
@fixes & additions
@
text
@d5 2
a6 2
:Revision: $Revision: 1.8 $
:Date: $Date: 2002/03/07 04:01:40 $
d37 1
a37 2
       Corresponding references and targets are assigned names, and the
       "anonymous" attributes are dropped::
d40 1
a40 1
               <reference refname="_:1:_">
d42 1
a42 1
           <target id="id1" name="_:1:_">
d142 1
a142 1
            del ref['anonymous']
d146 1
a146 1
            del target['anonymous']
d168 26
a193 8
        try:
            reftarget = self.doctree.explicit_targets[refname]
        except KeyError:                # @@@@@@ something wrong here
            # @@@@@@ give id for anonymous targets
            msg = self.doctree.reporter.warning(
                  'Indirect hyperlink target "%s" refers to target "%s", '
                  'which does not exist.' % (name, refname))
            self.doctree.messages += msg
a194 9
        if reftarget.hasattr('name'):
            if not reftarget.resolved and reftarget.hasattr('refname'):
                self.one_indirect_target(reftarget)
            if reftarget.hasattr('refuri'):
                target['refuri'] = reftarget['refuri']
                del target['refname']
                self.doctree.note_external_target(target)
            elif reftarget.hasattr('refname'):
                target['refname'] = reftarget['refname']
d197 10
d219 1
a219 8
            try:
                ref['refname'] = refname
            except KeyError, instance:
                msg = self.doctree.reporter.error(
                      'Indirect hyperlink target "%s" has no "refname" '
                      'attribute.' % name)
                self.doctree.messages += msg
                continue
d240 1
a240 8
            try:
                ref['refuri'] = refuri
            except KeyError, instance:
                msg = self.doctree.reporter.error(
                      'External hyperlink target "%s" has no "refuri" '
                      'attribute.' % name)
                self.doctree.messages += msg
                continue
d439 1
d443 4
a446 3
                        ref.parent.replace(
                              ref, nodes.problematic(ref.rawsource,
                                                     ref.rawsource))
d471 1
d475 4
a478 3
                        ref.parent.replace(
                              ref, nodes.problematic(ref.rawsource,
                                                     ref.rawsource))
d524 1
d526 5
a530 2
                    ref.parent.replace(ref, nodes.problematic(
                          ref.rawsource, '', *ref.getchildren()))
@


1.8
log
@  - Added support for symbolic footnotes and mixed    manual/auto-numbered footnotes.
@
text
@d5 2
a6 2
:Revision: $Revision: 1.7 $
:Date: $Date: 2002/02/22 02:11:24 $
d171 2
a172 1
        except KeyError:
d177 1
@


1.7
log
@  - Modified post-parse system message storage.
@
text
@d5 2
a6 2
:Revision: $Revision: 1.6 $
:Date: $Date: 2002/02/20 04:14:15 $
d368 17
d391 1
d401 5
a405 2
            label = str(self.doctree.autofootnote_start)
            self.doctree.autofootnote_start += 1
d434 5
d443 29
@


1.6
log
@updated docs & fixed ChainedTargetResolver visitor.
@
text
@d5 2
a6 2
:Revision: $Revision: 1.5 $
:Date: $Date: 2002/02/06 02:50:31 $
d132 1
a132 1
            sw = self.doctree.reporter.error(
d136 1
a136 1
            self.doctree += sw
d172 1
a172 1
            sw = self.doctree.reporter.warning(
d175 1
a175 1
            self.doctree += sw
d191 1
a191 1
            sw = self.doctree.reporter.info(
d194 1
a194 1
            self.doctree += sw
d202 1
a202 1
                sw = self.doctree.reporter.error(
d205 1
a205 1
                self.doctree += sw
d220 1
a220 1
            sw = self.doctree.reporter.info(
d222 1
a222 1
            self.doctree += sw
d230 1
a230 1
                sw = self.doctree.reporter.error(
d233 1
a233 1
                self.doctree += sw
d408 1
a408 1
                sw = self.doctree.reporter.error(
d412 1
a412 1
                self.doctree += sw
d457 1
a457 1
                    sw = self.doctree.reporter.error(
d459 1
a459 1
                    self.doctree += sw
@


1.5
log
@``utils.Reporter``, ``nodes.NodeVisitor`` reform.
@
text
@d5 2
a6 2
:Revision: $Revision: 1.4 $
:Date: $Date: 2002/01/30 04:52:17 $
d43 1
a43 1
           <target name="_:1:_">
d47 2
a48 2
           <target name="chained">
           <target name="external hyperlink" refuri="http://uri">
d53 2
a54 2
           <target name="chained" refuri="http://uri">
           <target name="external hyperlink" refuri="http://uri">
d61 4
a64 2
              <target name="direct external" refuri="http://indirect">
              <target name="indirect external" refname="direct external">
d73 4
a76 2
              <target name="direct external" refuri="http://indirect">
              <target name="indirect external" refuri="http://indirect">
d84 1
a84 1
              <target name="final target">
d88 4
a91 2
              <target name="indirect internal 2" refname="final target">
              <target name="indirect internal" refname="indirect internal 2">
d98 1
a98 1
              <target name="final target">
d102 4
a105 2
              <target name="indirect internal 2" refname="final target">
              <target name="indirect internal" refname="final target">
d112 1
a112 1
           <target name="direct external" refuri="http://direct">
d119 1
a119 1
           <target name="direct external" refuri="http://direct">
d276 3
@


1.4
log
@  - Simplified target record keeping.
@
text
@d5 2
a6 2
:Revision: $Revision: 1.3 $
:Date: $Date: 2002/01/29 02:17:32 $
d183 1
a183 1
            sw = self.doctree.reporter.information(
d212 2
a213 3
            sw = self.doctree.reporter.information(
                  'External hyperlink target "%s" is not referenced.'
                  % name)
d233 1
a233 1
class ChainedTargetResolver(nodes.Visitor):
d269 1
a269 1
    def visit_target(self, node, ancestry):
d272 1
a272 1
            parent, index = ancestry[-1]
d274 1
a274 1
                sibling = parent[i]
d283 1
a283 1
            parent, index = ancestry[-1]
d285 1
a285 1
                sibling = parent[i]
@


1.3
log
@updated
@
text
@d5 2
a6 2
:Revision: $Revision: 1.2 $
:Date: $Date: 2002/01/28 02:19:47 $
d151 6
a156 8
        for name, targets in self.doctree.indirect_targets.items():
            if len(targets) == 1:
                target = targets[-1]
                if not target.resolved:
                    self.one_indirect_target(target)
                if target.hasattr('refname'):
                    self.one_indirect_reference(target['name'],
                                                target['refname'])
d162 1
a162 1
            reftargetlist = self.doctree.explicit_targets[refname]
a167 1
        reftarget = reftargetlist[-1]
d204 1
a204 2
        for name, targets in self.doctree.external_targets.items():
            target = targets[-1]
d206 1
a206 1
                self.one_external_reference(name, targets[-1]['refuri'])
@


1.2
log
@  - Added footnote numbering transform.
@
text
@d5 2
a6 2
:Revision: $Revision: 1.1 $
:Date: $Date: 2002/01/26 00:10:09 $
d147 2
a148 1
        ChainedTargetResolver(self.doctree).walk()
d302 55
d359 3
d364 1
a365 1
        self.autofootnote_labels = []
d370 6
d393 1
d415 23
d441 16
a456 1
        pass
@


1.1
log
@Transforms for resolving references:hyperlinks, footnotes, and substitutions.
@
text
@d5 2
a6 2
:Revision: $Revision$
:Date: $Date$
d304 40
a343 1
        pass
@

