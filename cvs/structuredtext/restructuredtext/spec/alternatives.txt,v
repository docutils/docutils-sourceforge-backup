head	1.19;
access;
symbols;
locks; strict;
comment	@# @;


1.19
date	2002.03.28.04.27.18;	author goodger;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.16.05.35.08;	author goodger;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.07.03.44.32;	author goodger;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.01.03.02.46;	author goodger;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.25.23.44.41;	author goodger;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.19.04.19.52;	author goodger;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.15.23.36.00;	author goodger;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.15.03.04.19;	author goodger;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.13.03.16.45;	author goodger;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.09.23.17.51;	author goodger;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.06.00.49.35;	author goodger;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.01.04.10.49;	author goodger;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.26.04.33.17;	author goodger;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.19.03.06.28;	author goodger;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.18.03.49.26;	author goodger;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.01.15.46.43;	author goodger;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.28.03.10.15;	author goodger;	state Exp;
branches;
next	1.2;

1.2
date	2001.08.22.03.44.10;	author goodger;	state Exp;
branches;
next	1.1;

1.1
date	2001.08.16.02.43.09;	author goodger;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Clarifications, updates, & fixes.
@
text
@==================================================
 A Record of reStructuredText Syntax Alternatives
==================================================
:Author: David Goodger
:Contact: goodger@@users.sourceforge.net
:Revision: $Revision: 1.18 $
:Date: $Date: 2002/03/16 05:35:08 $

The following are ideas, alternatives, and justifications that were
considered for reStructuredText syntax, which did not originate with
Setext_ or StructuredText_. For an analysis of constructs which *did*
originate with StructuredText or Setext, please see `Problems With
StructuredText`_. See the `reStructuredText Markup Specification`_ for
full details of the established syntax.

.. _Setext: http://docutils.sourceforge.net/mirror/setext.html
.. _StructuredText:
   http://dev.zope.org/Members/jim/StructuredTextWiki/FrontPage
.. _Problems with StructuredText:
    http://structuredtext.sourceforge.net/spec/problems.txt
.. _reStructuredText Markup Specification:
   http://structuredtext.sourceforge.net/spec/reStructuredText.txt


.. contents::


Field Lists
===========

Prior to the syntax for field lists being finalized, several
alternatives were proposed.

1. Unadorned RFC822_ everywhere::

       Author: Me
       Version: 1

   Advantages: clean, precedent (RFC822-compliant). Disadvantage:
   ambiguous (these paragraphs are a prime example).

   Conclusion: rejected.

2. Special case: use unadorned RFC822_ for the very first or very last
   text block of a document::

       """
       Author: Me
       Version: 1

       The rest of the document...
       """

   Advantages: clean, precedent (RFC822-compliant). Disadvantages:
   special case, flat (unnested) field lists only, still ambiguous::

       """
       Usage: cmdname [options] arg1 arg2 ...

       We obviously *don't* want the like above to be interpreted as a
       field list item. Or do we?
       """

   Conclusion: rejected for the general case, accepted for specific
   contexts (PEPs, email).

3. Use a directive::

       .. fields::

          Author: Me
          Version: 1

   Advantages: explicit and unambiguous, RFC822-compliant.
   Disadvantage: cumbersome.

   Conclusion: rejected for the general case (but such a directive
   could certainly be written).

4. Use Javadoc-style::

       @@Author: Me
       @@Version: 1
       @@param a: integer

   Advantages: unambiguous, precedent, flexible. Disadvantages:
   non-intuitive, ugly, not RFC822-compliant.

   Conclusion: rejected.

5. Use leading colons::

       :Author: Me
       :Version: 1

   Advantages: unambiguous, obvious (*almost* RFC822-compliant),
   flexible, perhaps even elegant. Disadvantages: no precedent, not
   quite RFC822-compliant.

   Conclusion: accepted!

6. Use double colons::

       Author:: Me
       Version:: 1

   Advantages: unambiguous, obvious? (*almost* RFC822-compliant),
   flexible, similar to syntax already used for literal blocks and
   directives. Disadvantages: no precedent, not quite
   RFC822-compliant, similar to syntax already used for literal blocks
   and directives.

   Conclusion: rejected because of the syntax similarity & conflicts.

Why is RFC822 compliance important? It's a universal Internet
standard, and super obvious. Also, I'd like to support the PEP format
(ulterior motive: get PEPs to use reStructuredText as their standard).
But it *would* be easy to get used to an alternative (easy even to
convert PEPs; probably harder to convert python-deviants ;-).

Unfortunately, without well-defined context (such as in email headers:
RFC822 only applies before any blank lines), the RFC822 format is
ambiguous. It is very common in ordinary text. To implement field
lists unambiguously, we need explicit syntax.

The following question was posed in a footnote:

   Should "bibliographic field lists" be defined at the parser level,
   or at the DPS transformation level? In other words, are they
   reStructuredText-specific, or would they also be applicable to
   another (many/every other?) syntax?

The answer is that bibliographic fields are a
reStructuredText-specific markup convention. Other syntaxes may
implement the bibliographic elements explicitly. For example, there
would be no need for such a transformation for an XML-based markup
syntax.

.. _RFC822: http://www.rfc-editor.org/rfc/rfc822.txt


Interpreted Text "Roles"
========================

The original purpose of interpreted text was as a mechanism for
descriptive markup, to describe the nature or role of a word or
phrase. For example, in XML we could say "<function>len</function>" to
mark up "len" as a function. It is envisaged that within Python
docstrings (inline documentation in Python module source files, the
primary market for reStructuredText) the role of a piece of
interpreted text can be inferred implicitly from the context of the
docstring within the program source. For other applications, however,
the role may have to be indicated explicitly.

Interpreted text is enclosed in single backquotes (`).

1. Initially, it was proposed that an explicit role could be indicated
   as a word or phrase within the enclosing backquotes:

   - As a prefix, separated by a colon and whitespace::

         `role: interpreted text`

   - As a suffix, separated by whitespace and a colon::

         `interpreted text :role`

   There are problems with the initial approach:

   - There could be ambiguity with interpreted text containing colons.
     For example, an index entry of "Mission: Impossible" would
     require a backslash-escaped colon.

   - The explicit role is descriptive markup, not content, and will
     not be visible in the processed output. Putting it inside the
     backquotes doesn't feel right; the *role* isn't being quoted.

2. Tony Ibbs suggested that the role be placed outside the
   backquotes::

       role:`prefix` or `suffix`:role

   This removes the embedded-colons ambiguity, but limits the role
   identifier to be a single word (whitespace would be illegal). Since
   roles are not meant to be visible after processing, the lack of
   whitespace support is not important.

   The suggested syntax remains ambiguous with respect to ratios and
   some writing styles. For example, suppose there is a "signal"
   identifier, and we write::

       ...calculate the `signal`:noise ratio.

   "noise" looks like a role.

3. As an improvement on #2, we can bracket the role with colons::

       :role:`prefix` or `suffix`:role:

   This syntax is similar to that of field lists, which is fine since
   both are doing similar things: describing.

   This is the syntax chosen for reStructuredText.

4. Another alternative is two colons instead of one::

       role::`prefix` or `suffix`::role

   But this is used for analogies ("A:B::C:D": "A is to B as C is to
   D").

   Both alternative #2 and #4 lack delimiters on both sides of the
   role, making it difficult to parse (by the reader).

5. Some kind of bracketing could be used:

   - Parentheses::

         (role)`prefix` or `suffix`(role)

   - Braces::

         {role}`prefix` or `suffix`{role}

   - Square brackets::

         [role]`prefix` or `suffix`[role]

   - Angle brackets::

         <role>`prefix` or `suffix`<role>

     (The overlap of \*ML tags with angle brackets would be too
     confusing and precludes their use.)

Syntax #3 was chosen for reStructuredText.


Comments
========

A problem with comments (actually, with all indented constructs) is
that they cannot be followed by an indented block -- a block quote --
without swallowing it up.

I thought that perhaps comments should be one-liners only. But would
this mean that footnotes, hyperlink targets, and directives must then
also be one-liners? Not a good solution.

Tony Ibbs suggested a "comment" directive. I added that we could limit
a comment to a single text block, and that a "multi-block comment"
could use "comment-start" and "comment-end" directives. This would
remove the indentation incompatibility. A "comment" directive
automatically suggests "footnote" and (hyperlink) "target" directives
as well. This could go on forever! Bad choice.

Garth Kidd suggested that an "empty comment", a ".." explicit markup
start with nothing on the first line (except possibly whitespace) and
a blank line immediately following, could serve as an "unindent". An
empty comment does **not** swallow up indented blocks following it,
so block quotes are safe. "A tiny but practical wart." Accepted.


Anonymous Hyperlinks
====================

Alan Jaffray came up with this idea, along with the following syntax::

    Search the `Python DOC-SIG mailing list archives`{}_.

    .. _: http://mail.python.org/pipermail/doc-sig/

The idea is sound and useful. I suggested a "double underscore"
syntax::

    Search the `Python DOC-SIG mailing list archives`__.

    .. __: http://mail.python.org/pipermail/doc-sig/

But perhaps single underscores are okay? The syntax looks better, but
the hyperlink itself doesn't explicitly say "anonymous"::

    Search the `Python DOC-SIG mailing list archives`_.

    .. _: http://mail.python.org/pipermail/doc-sig/

Mixing anonymous and named hyperlinks becomes confusing. The order of
targets is not significant for named hyperlinks, but it is for
anonymous hyperlinks::

    Hyperlinks: anonymous_, named_, and another anonymous_.

    .. _named: named
    .. _: anonymous1
    .. _: anonymous2

Without the extra syntax of double underscores, determining which
hyperlink references are anonymous may be difficult. We'd have to
check which references don't have corresponding targets, and match
those up with anonymous targets. Keeping to a simple consistent
ordering (as with auto-numbered footnotes) seems simplest.

reStructuredText will use the explicit double-underscore syntax for
anonymous hyperlinks.  An alternative (see `Reworking Explicit
Markup`_ below) for the somewhat awkward ".. __:" syntax is "__"::

    An anonymous__ reference.

    __ http://anonymous


Reworking Explicit Markup
=========================

Alan Jaffray came up with the idea of `anonymous hyperlinks`_, added
to reStructuredText. Subsequently it was asserted that hyperlinks
(especially anonymous hyperlinks) would play an increasingly important
role in reStructuredText documents, and therefore they require a
simpler and more concise syntax. This prompted a review of the current
and proposed explicit markup syntaxes with regards to improving
usability.

1. Original syntax::

       .. _blah:                     internal hyperlink target
       .. _blah: http://somewhere    external hyperlink target
       .. _blah: blahblah_           indirect hyperlink target
       .. __:                        anonymous internal target
       .. __: http://somewhere       anonymous external target
       .. __: blahblah_              anonymous indirect target
       .. [blah] http://somewhere    footnote
       .. blah:: http://somewhere    directive
       .. blah: http://somewhere     comment

   .. Note::

      The comment text was intentionally made to look like a hyperlink
      target.

   Origins:

   * Except for the colon (a delimiter necessary to allow for
     phrase-links), hyperlink target ``.. _blah:`` comes from Setext.
   * Comment syntax from Setext.
   * Footnote syntax from StructuredText ("named links").
   * Directives and anonymous hyperlinks original to reStructuredText.

   Advantages:

   + Consistent explicit markup indicator: "..".
   + Consistent hyperlink syntax: ".. _" & ":".

   Disadvantages:

   - Anonymous target markup is awkward: ".. __:".
   - The explicit markup indicator ("..") is excessively overloaded?
   - Comment text is limited (can't look like a footnote, hyperlink,
     or directive). But this is probably not important.

2. Alan Jaffray's proposed syntax #1::

       __ _blah                      internal hyperlink target
       __ blah: http://somewhere     external hyperlink target
       __ blah: blahblah_            indirect hyperlink target
       __                            anonymous internal target
       __ http://somewhere           anonymous external target
       __ blahblah_                  anonymous indirect target
       __ [blah] http://somewhere    footnote
       .. blah:: http://somewhere    directive
       .. blah: http://somewhere     comment

   The hyperlink-connoted underscores have become first-level syntax.

   Advantages:

   + Anonymous targets are simpler.
   + All hyperlink targets are one character shorter.

   Disadvantages:

   - Inconsistent internal hyperlink targets. Unlike all other named
     hyperlink targets, there's no colon. There's an extra leading
     underscore, but we can't drop it because without it, "blah" looks
     like a relative URI. Unless we restore the colon::

         __ blah:                      internal hyperlink target

   - Obtrusive markup?

3. Alan Jaffray's proposed syntax #2::

       .. _blah                      internal hyperlink target
       .. blah: http://somewhere     external hyperlink target
       .. blah: blahblah_            indirect hyperlink target
       ..                            anonymous internal target
       .. http://somewhere           anonymous external target
       .. blahblah_                  anonymous indirect target
       .. [blah] http://somewhere    footnote
       !! blah: http://somewhere     directive
       ## blah: http://somewhere     comment

   Leading underscores have been (almost) replaced by "..", while
   comments and directives have gained their own syntax.

   Advantages:

   + Anonymous hyperlinks are simpler.
   + Unique syntax for comments. Connotation of "comment" from
     some programming languages (including our favorite).
   + Unique syntax for directives. Connotation of "action!".

   Disadvantages:

   - Inconsistent internal hyperlink targets. Again, unlike all other
     named hyperlink targets, there's no colon. There's a leading
     underscore, matching the trailing underscores of references,
     which no other hyperlink targets have. We can't drop that one
     leading underscore though: without it, "blah" looks like a
     relative URI. Again, unless we restore the colon::

         .. blah:                      internal hyperlink target

   - All (except for internal) hyperlink targets lack their leading
     underscores, losing the "hyperlink" connotation.

   - Obtrusive syntax for comments. Alternatives::

         ;; blah: http://somewhere
            (also comment syntax in Lisp & others)
         ,, blah: http://somewhere
            ("comma comma": sounds like "comment"!)

   - Iffy syntax for directives. Alternatives?

4. Tony Ibbs' proposed syntax::

       .. _blah:                     internal hyperlink target
       .. _blah: http://somewhere    external hyperlink target
       .. _blah: blahblah_           indirect hyperlink target
       ..                            anonymous internal target
       .. http://somewhere           anonymous external target
       .. blahblah_                  anonymous indirect target
       .. [blah] http://somewhere    footnote
       .. blah:: http://somewhere    directive
       .. blah: http://somewhere     comment

   This is the same as the current syntax, except for anonymous
   targets which drop their "__: ".

   Advantage:

   + Anonymous targets are simpler.

   Disadvantages:

   - Anonymous targets lack their leading underscores, losing the
     "hyperlink" connotation.
   - Anonymous targets are almost indistinguishable from comments.
     (Better to know "up front".)

5. David Goodger's proposed syntax: Perhaps going back to one of
   Alan's earlier suggestions might be the best solution. How about
   simply adding "__ " as a synonym for ".. __: " in the original
   syntax? These would become equivalent::

       .. __:                        anonymous internal target
       .. __: http://somewhere       anonymous external target
       .. __: blahblah_              anonymous indirect target

       __                            anonymous internal target
       __ http://somewhere           anonymous external target
       __ blahblah_                  anonymous indirect target

Alternative 5 has been adopted.


Backquotes in Phrase-Links
==========================

[From a 2001-06-05 Doc-SIG post in reply to questions from Doug
Hellmann.]

The first draft of the spec, posted to the Doc-SIG in November 2000,
used square brackets for phrase-links. I changed my mind because:

1. In the first draft, I had already decided on single-backquotes for
   inline literal text.

2. However, I wanted to minimize the necessity for backslash escapes,
   for example when quoting Python repr-equivalent syntax that uses
   backquotes.

3. The processing of identifiers (funtion/method/attribute/module/etc.
   names) into hyperlinks is a useful feature. PyDoc recognizes
   identifiers heuristically, but it doesn't take much imagination to
   come up with counter-examples where PyDoc's heuristics would result
   in embarassing failure. I wanted to do it deterministically, and
   that called for syntax. I called this construct 'interpreted text'.

4. Leveraging off the *emphasis*/**strong** syntax, lead to the idea
   of using double-backquotes as syntax.

5. I worked out some rules for inline markup recognition.

6. In combination with #5, double backquotes lent themselves to inline
   literals, neatly satisfying #2, minimizing backslash escapes. In
   fact, the spec says that no interpretation of any kind is done
   within double-backquote inline literal text; backslashes do *no*
   escaping within literal text.

7. Single backquotes are then freed up for interpreted text.

8. I already had square brackets required for footnote references.

9. Since interpreted text will typically turn into hyperlinks, it was a
   natural fit to use backquotes as the phrase-quoting syntax for
   trailing-underscore hyperlinks.

The original inspiration for the trailing underscore hyperlink syntax
was Setext. But for phrases Setext used a very cumbersome
``underscores_between_words_like_this_`` syntax.

The underscores can be viewed as if they were right-pointing arrows:
'-->'. So ``hyperlink_`` points away from the reference, and
``.. _hyperlink:`` points toward the target.


Substitution Mechanism
======================

Substitutions arose out of a Doc-SIG thread begun on 2001-10-28 by
Alan Jaffray, "reStructuredText inline markup".  It reminded me of a
missing piece of the reStructuredText puzzle, first referred to in my
contribution to "Documentation markup & processing / PEPs" (Doc-SIG
2001-06-21).

Substitutions allow the power and flexibility of directives to be
shared by inline text.  They are a way to allow arbitrarily complex
inline objects, while keeping the details out of the flow of text.
They are the equivalent of SGML/XML's named entities.  For example, an
inline image (using reference syntax alternative 4d (vertical bars)
and definition alternative 3, the alternatives chosen for inclusion in
the spec)::

    The |biohazard| symbol must be used on containers used to dispose
    of medical waste.

    .. |biohazard| image:: biohazard.png
       [height=20 width=20]

The ``|biohazard|`` substitution reference will be replaced in-line by
whatever the ``.. |biohazard|`` substitution definition generates (in
this case, an image).  A substitution definition contains the
substitution text bracketed with vertical bars, followed by a an
embedded inline-compatible directive, such as "image".  A transform is
required to complete the substitution.

Syntax alternatives for the reference:

1. Use the existing interpreted text syntax, with a predefined role
   such as "sub"::

       The `biohazard`:sub: symbol...

   Advantages: existing syntax, explicit.  Disadvantages: verbose,
   obtrusive.

2. Use a variant of the interpreted text syntax, with a new suffix
   akin to the underscore in phrase-link references::

       (a) `name`@@
       (b) `name`#
       (c) `name`&
       (d) `name`/
       (e) `name`<
       (f) `name`::
       (g) `name`:


   Due to incompatibility with other constructs and ordinary text
   usage, (f) and (g) are not possible.

3. Use interpreted text syntax with a fixed internal format::

       (a) `:name:`
       (b) `name:`
       (c) `name::`
       (d) `::name::`
       (e) `%name%`
       (f) `#name#`
       (g) `/name/`
       (h) `&name&`
       (i) `|name|`
       (j) `[name]`
       (k) `<name>`
       (l) `&name;`
       (m) `'name'`

   To avoid ML confusion (k) and (l) are definitely out.  Square
   brackets (j) won't work in the target (the substitution definition
   would be indistinguishable from a footnote).

   The ```/name/``` syntax (g) is reminiscent of "s/find/sub"
   substitution syntax in ed-like languages.  However, it may have a
   misleading association with regexps, and looks like an absolute
   POSIX path.  (i) is visually equivalent and lacking the
   connotations.

   A disadvantage of all of these is that they limit interpreted text,
   albeit only slightly.

4. Use specialized syntax, something new::

       (a) #name#
       (b) @@name@@
       (c) /name/
       (d) |name|
       (e) <<name>>
       (f) //name//
       (g) ||name||
       (h) ^name^
       (i) [[name]]
       (j) ~name~
       (k) !name!
       (l) =name=
       (m) ?name?
       (n) >name<

   "#" (a) and "@@" (b) are obtrusive.  "/" (c) without backquotes
   looks just like a POSIX path; it is likely for such usage to appear
   in text.

   "|" (d) and "^" (h) are feasible.

5. Redefine the trailing underscore syntax. See definition syntax
   alternative 4, below.

Syntax alternatives for the definition:

1. Use the existing directive syntax, with a predefined directive such
   as "sub".  It contains a further embedded directive resolving to an
   inline-compatible object::

       .. sub:: biohazard
          .. image:: biohazard.png
             [height=20 width=20]

       .. sub:: parrot
          That bird wouldn't *voom* if you put 10,000,000 volts
          through it!

   The advantages and disadvantages are the same as in inline
   alternative 1.

2. Use syntax as in #1, but with an embedded directivecompressed::

       .. sub:: biohazard image:: biohazard.png
          [height=20 width=20]

   This is a bit better than alternative 1, but still too much.

3. Use a variant of directive syntax, incorporating the substitution
   text, obviating the need for a special "sub" directive name.  If we
   assume reference alternative 4d (vertical bars), the matching
   definition would look like this::

       .. |biohazard| image:: biohazard.png
          [height=20 width=20]

4. (Suggested by Alan Jaffray on Doc-SIG from 2001-11-06.)

   Instead of adding new syntax, redefine the trailing underscore
   syntax to mean "substitution reference" instead of "hyperlink
   reference".  Alan's example::

       I had lunch with Jonathan_ today.  We talked about Zope_.

       .. _Jonathan: lj [user=jhl]
       .. _Zope: http://www.zope.org/

   A problem with the proposed syntax is that URIs which look like
   simple reference names (alphanum plus ".", "-", "_") would be
   indistinguishable from substitution directive names.  A more
   consistent syntax would be::

       I had lunch with Jonathan_ today.  We talked about Zope_.

       .. _Jonathan: lj:: user=jhl
       .. _Zope: http://www.zope.org/

   (``::`` after ``.. _Jonathan: lj``.)

   The "Zope" target is a simple external hyperlink, but the
   "Jonathan" target contains a directive.  Alan proposed is that the
   reference text be replaced by whatever the referenced directive
   (the "directive target") produces.  A directive reference becomes a
   hyperlink reference if the contents of the directive target resolve
   to a hyperlink.  If the directive target resolves to an icon, the
   reference is replaced by an inline icon.  If the directive target
   resolves to a hyperlink, the directive reference becomes a
   hyperlink reference.

   This seems too indirect and complicated for easy comprehension.

   The reference in the text will sometimes become a link, sometimes
   not.  Sometimes the reference text will remain, sometimes not.  We
   don't know *at the reference*::

       This is a `hyperlink reference`_; its text will remain.
       This is an `inline icon`_; its text will disappear.

   That's a problem.

The syntax that has been incorporated into the spec and parser is
reference alternative 4d with definition alternative 3::

    The |biohazard| symbol...

    .. |biohazard| image:: biohazard.png
       [height=20 width=20]

We can also combine substitution references with hyperlink references,
by appending a "_" (named hyperlink reference) or "__" (anonymous
hyperlink reference) suffix to the substitution reference.  This
allows us to click on an image-link::

    The |biohazard|_ symbol...

    .. |biohazard| image:: biohazard.png
       [height=20 width=20]
    .. _biohazard: http://www.cdc.gov/

There have been several suggestions for the naming of these
constructs, originally called "substitution references" and
"substitutions".

1. Candidate names for the reference construct:

   (a) substitution reference
   (b) tagging reference
   (c) inline directive reference
   (d) directive reference
   (e) indirect inline directive reference
   (f) inline directive placeholder
   (g) inline directive insertion reference
   (h) directive insertion reference
   (i) insertion reference
   (j) directive macro reference
   (k) macro reference
   (l) substitution directive reference

2. Candidate names for the definition construct:

   (a) substitution
   (b) substitution directive
   (c) tag
   (d) tagged directive
   (e) directive target
   (f) inline directive
   (g) inline directive definition
   (h) referenced directive
   (i) indirect directive
   (j) indirect directive definition
   (k) directive definition
   (l) indirect inline directive
   (m) named directive definition
   (n) inline directive insertion definition
   (o) directive insertion definition
   (p) insertion definition
   (q) insertion directive
   (r) substitution definition
   (s) directive macro definition
   (t) macro definition
   (u) substitution directive definition
   (v) substitution definition

"Inline directive reference" (1c) seems to be an appropriate term at
first, but the term "inline" is redundant in the case of the
reference.  Its counterpart "inline directive definition" (2g) is
awkward, because the directive definition itself is not inline.

"Directive reference" (1d) and "directive definition" (2k) are too
vague.  "Directive definition" could be used to refer to any
directive, not just those used for inline substitutions.

One meaning of the term "macro" (1k, 2s, 2t) is too
programming-language-specific.  Also, macros are typically simple text
substitution mechanisms: the text is substituted first and evaluated
later.  reStructuredText substitution definitions are evaluated in
place at parse time and substituted afterwards.

"Insertion" (1h, 1i, 2n-2q) is almost right, but it implies that
something new is getting added rather than one construct being
replaced by another.

Which brings us back to "substitution".  The overall best names are
"substitution reference" (1a) and "substitution definition" (2v).  A
long way to go to add one word!


Reworking Footnotes
===================

As a further wrinkle (see `Reworking Explicit Markup`_ above), in the
wee hours of 2002-02-28 I posted several ideas for changes to footnote
syntax:

    - Change footnote syntax from ``.. [1]`` to ``_[1]``? ...
    - Differentiate (with new DTD elements) author-date "citations"
      (``[GVR2002]``) from numbered footnotes? ...
    - Render footnote references as superscripts without "[]"? ...

These ideas are all related, and suggest changes in the
reStructuredText syntax as well as the docutils tree model.

The footnote has been used for both true footnotes (asides expanding
on points or defining terms) and for citations (references to external
works). Rather than dealing with one amalgam construct, we could
separate the current footnote concept into strict footnotes and
citations.  Citations could be interpreted and treated differently
from footnotes.  Footnotes would be limited to numerical labels:
manual ("1") and auto-numbered (anonymous "#", named "#label").

The footnote is the only explicit markup construct (starts with ".. ")
that directly translates to a visible body element.  I've always been
a little bit uncomfortable with the ".. " marker for footnotes because
of this; ".. " has a connotation of "special", but footnotes aren't
especially "special".  Printed texts often put footnotes at the bottom
of the page where the reference occurs (thus "foot note").  Some HTML
designs would leave footnotes to be rendered the same positions where
they're defined.  Other online and printed designs will gather
footnotes into a section near the end of the document, converting them
to "endnotes" (perhaps using a directive in our case); but this
"special processing" is not an intrinsic property of the footnote
itself, but a decision made by the document author or processing
system.

Citations are almost invariably collected in a section at the end of a
document or section.  Citations "disappear" from where they are
defined and are magically reinserted at some well-defined point.
There's more of a connection to the "special" connotation of the ".. "
syntax.  The point at which the list of citations is inserted could be
defined manually by a directive (e.g., ".. citations::"), and/or have
default behavior (e.g., a section automatically inserted at the end of
the document) that might be influenced by options to the Writer.

Syntax proposals:

+ Footnotes:

  - Current syntax::

        .. [1] Footnote 1
        .. [#] Auto-numbered footnote.
        .. [#label] Auto-labeled footnote.

  - The syntax proposed in the original 2002-02-28 Doc-SIG post:
    remove the ".. ", prefix a "_"::

        _[1] Footnote 1
        _[#] Auto-numbered footnote.
        _[#label] Auto-labeled footnote.

    The leading underscore syntax (earlier dropped because
    ``.. _[1]:`` was too verbose) is a useful reminder that footnotes
    are hyperlink targets.

  - Minimal syntax: remove the ".. [" and "]", prefix a "_", and
    suffix a "."::

        _1. Footnote 1.
        _#. Auto-numbered footnote.
        _#label. Auto-labeled footnote.

                 ``_1.``, ``_#.``, and ``_#label.`` are markers,
                 like list markers.

    Footnotes could be rendered something like this in HTML

        | 1. This is a footnote.  The brackets could be dropped
        |    from the label, and a vertical bar could set them
        |    off from the rest of the document in the HTML.

    Two-way hyperlinks on the footnote marker ("1." above) would also
    help to differentiate footnotes from enumerated lists.

    If converted to endnotes (by a directive/transform), a horizontal
    half-line might be used instead.  Page-oriented output formats
    would typically use the horizontal line for true footnotes.

+ Footnote references:

  - Current syntax::

        [1]_, [#]_, [#label]_

  - Minimal syntax to match the minimal footnote syntax above::

        1_, #_, #label_

    As a consequence, pure-numeric hyperlink references would not be
    possible; they'd be interpreted as footnote references.

+ Citation references: no change is proposed from the current footnote
  reference syntax::

      [GVR2001]_

+ Citations:

  - Current syntax (footnote syntax)::

        .. [GVR2001] Python Documentation; van Rossum, Drake, et al.;
           http://www.python.org/doc/

  - Possible new syntax::

        _[GVR2001] Python Documentation; van Rossum, Drake, et al.;
                   http://www.python.org/doc/

        _[DJG2002]
            Docutils: Python Documentation Utilities project; Goodger
            et al.; http://docutils.sourceforge.net/

    Without the ".. " marker, subsequent lines would either have to
    align as in one of the above, or we'd have to allow loose
    alignment (I'd rather not)::

        _[GVR2001] Python Documentation; van Rossum, Drake, et al.;
            http://www.python.org/doc/

I proposed adopting the "minimal" syntax for footnotes and footnote
references, and adding citations and citation references to
reStructuredText's repertoire. The current footnote syntax for
citations is better than the alternatives given.

From a reply by Tony Ibbs on 2002-03-01:

    However, I think easier with examples, so let's create one::

        Fans of Terry Pratchett are perhaps more likely to use
        footnotes [1]_ in their own writings than other people
        [2]_. Of course, in *general*, one only sees footnotes
        in academic or technical writing - it's use in fiction
        and letter writing is not normally considered good
        style [4]_, particularly in emails (not a medium that
        lends itself to footnotes).

        .. [1] That is, little bits of referenced text at the
           bottom of the page.
        .. [2] Because Terry himself does, of course [3]_.
        .. [3] Although he has the distinction of being
           *funny* when he does it, and his fans don't always
           achieve that aim.
        .. [4] Presumably because it detracts from linear
           reading of the text - this is, of course, the point.

    and look at it with the second syntax proposal::

        Fans of Terry Pratchett are perhaps more likely to use
        footnotes [1]_ in their own writings than other people
        [2]_. Of course, in *general*, one only sees footnotes
        in academic or technical writing - it's use in fiction
        and letter writing is not normally considered good
        style [4]_, particularly in emails (not a medium that
        lends itself to footnotes).

        _[1] That is, little bits of referenced text at the
             bottom of the page.
        _[2] Because Terry himself does, of course [3]_.
        _[3] Although he has the distinction of being
             *funny* when he does it, and his fans don't always
             achieve that aim.
        _[4] Presumably because it detracts from linear
             reading of the text - this is, of course, the point.

    (I note here that if I have gotten the indentation of the
    footnotes themselves correct, this is clearly not as nice. And if
    the indentation should be to the left margin instead, I like that
    even less).

    and the third (new) proposal::

        Fans of Terry Pratchett are perhaps more likely to use
        footnotes 1_ in their own writings than other people
        2_. Of course, in *general*, one only sees footnotes
        in academic or technical writing - it's use in fiction
        and letter writing is not normally considered good
        style 4_, particularly in emails (not a medium that
        lends itself to footnotes).

        _1. That is, little bits of referenced text at the
            bottom of the page.
        _2. Because Terry himself does, of course 3_.
        _3. Although he has the distinction of being
            *funny* when he does it, and his fans don't always
            achieve that aim.
        _4. Presumably because it detracts from linear
            reading of the text - this is, of course, the point.

    I think I don't, in practice, mind the targets too much (the use
    of a dot after the number helps a lot here), but I do have a
    problem with the body text, in that I don't naturally separate out
    the footnotes as different than the rest of the text - instead I
    keep wondering why there are numbers interspered in the text. The
    use of brackets around the numbers ([ and ]) made me somehow parse
    the footnote references as "odd" - i.e., not part of the body text
    - and thus both easier to skip, and also (paradoxically) easier to
    pick out so that I could follow them.

    Thus, for the moment (and as always susceptable to argument), I'd
    say -1 on the new form of footnote reference (i.e., I much prefer
    the existing ``[1]_`` over the proposed ``1_``), and ambivalent
    over the proposed target change.

    That leaves David's problem of wanting to distinguish footnotes
    and citations - and the only thing I can propose there is that
    footnotes are numeric or # and citations are not (which, as a
    human being, I can probably cope with!).

From a reply by Paul Moore on 2002-03-01:

    I think the current footnote syntax ``[1]_`` is *exactly* the
    right balance of distinctness vs unobtrusiveness. I very
    definitely don't think this should change.

    On the target change, it doesn't matter much to me.

From a further reply by Tony Ibbs on 2002-03-01, referring to the
"[1]" form and actual usage in email:

    Clearly this is a form people are used to, and thus we should
    consider it strongly (in the same way that the usage of ``*..*``
    to mean emphasis was taken partly from email practise).

    Equally clearly, there is something "magical" for people in the
    use of a similar form (i.e., ``[1]``) for both footnote reference
    and footnote target - it seems natural to keep them similar.

    ...

    I think that this established plaintext usage leads me to strongly
    believe we should retain square brackets at both ends of a
    footnote. The markup of the reference end (a single trailing
    underscore) seems about as minimal as we can get away with. The
    markup of the target end depends on how one envisages the thing -
    if ".." means "I am a target" (as I tend to see it), then that's
    good, but one can also argue that the "_[1]" syntax has a neat
    symmetry with the footnote reference itself, if one wishes (in
    which case ".." presumably means "hidden/special" as David seems
    to think, which is why one needs a ".." *and* a leading underline
    for hyperlink targets.

Given the persuading arguments voiced, we'll leave footnote & footnote
reference syntax alone.  Except that these discussions gave rise to
the "auto-symbol footnote" concept, which has been added.  Citations
and citation references have also been added.


..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   End:
@


1.18
log
@  - Added "contents".  - Minor edits.
@
text
@d1 3
a3 3
================================================
 Record of reStructuredText Syntax Alternatives
================================================
d6 2
a7 2
:Revision: $Revision: 1.17 $
:Date: $Date: 2002/03/07 03:44:32 $
d16 1
a16 1
.. _Setext: http://www.bsdi.com/setext
@


1.17
log
@  - Added replies to "Reworking Footnotes" and conclusions.
@
text
@d6 2
a7 2
:Revision: $Revision: 1.16 $
:Date: $Date: 2002/03/01 03:02:46 $
d25 3
d77 2
a78 1
   Conclusion: rejected.
d97 1
a97 1
   flexible, perhaps even elegant. Disadvantage: no precedent, not
d343 1
a343 1
     phrase-links), hyperlink target ``.. _blah:" comes from Setext.
d638 1
a638 1
Syntax alternatives for the definition::
d891 1
a891 1
+ Footnote references::
@


1.16
log
@  - Added "Reworking Footnotes".
@
text
@d6 2
a7 2
:Revision: $Revision: 1.15 $
:Date: $Date: 2002/01/25 23:44:41 $
d875 1
a875 1
    
d879 1
a879 1
  
d882 1
a882 1
  
d909 1
a909 1
        .. _[GVR2001] Python Documentation; van Rossum, Drake, et al.;
d918 2
a919 2
            Docutils: Python Documentation Utilities project; Goodger et
            al.; http://docutils.sourceforge.net/
d922 2
a923 2
    align as in one of the above, or we'd have to allow loose alignment
    (I'd rather not)::
d928 1
a928 1
I propose adopting the "minimal" syntax for footnotes and footnote
d932 122
@


1.15
log
@updated
@
text
@d6 2
a7 2
:Revision: $Revision: 1.14 $
:Date: $Date: 2001/11/19 04:19:52 $
d332 1
a332 1
   
d535 1
a535 1
inline objects, while keeping the details out of the flow of text. 
d582 5
a586 5
       (b) `name:` 
       (c) `name::` 
       (d) `::name::` 
       (e) `%name%` 
       (f) `#name#` 
d588 4
a591 4
       (h) `&name&` 
       (i) `|name|` 
       (j) `[name]` 
       (k) `<name>` 
d795 137
@


1.14
log
@Reworked "Substitution Mechanism".
@
text
@d6 2
a7 2
:Revision: $Revision: 1.13 $
:Date: $Date: 2001/11/15 23:36:00 $
d300 6
a305 1
anonymous hyperlinks.
d324 1
d331 4
a334 6
   Notes on the examples:

   * Anonymous internal targets are also possible, but probably not
     useful, so they're not included.
   * The comment text was intentionally made to look like a hyperlink
     target.
d361 1
d391 1
d436 1
d459 2
a460 2
   simply adding "__ " as a synonym for ".. __: "? These would become
   equivalent::
d462 3
a464 1
       .. __: http://somewhere
d466 3
a468 1
       __ http://somewhere
d470 1
a470 1
   Would that be sufficient, with no other syntax changes?
@


1.13
log
@more alternatives for substitution syntax & name.
@
text
@d6 2
a7 2
:Revision: $Revision: 1.12 $
:Date: $Date: 2001/11/15 03:04:19 $
d513 2
a514 2
Inline Substitutions
====================
d516 4
a519 4
Inline substitutions arose out of a Doc-SIG thread begun on 2001-10-28
by Alan Jaffray, "reStructuredText inline markup".  It reminded me of
a missing piece of the reStructuredText puzzle, first referred to in
my contribution to "Documentation markup & processing / PEPs" (Doc-SIG
d522 3
a524 3
Inline substitutions allow the power and flexibility of directives to
be shared by inline text.  They are a way to allow arbitrarily complex
inline objects, while keeping the details out of the flow of text.
d526 3
a528 2
inline image (using inline syntax alternative 3/slashes & substitution
alternative 3, the alternatives chosen for inclusion in the spec)::
d530 2
a531 2
    The `/biohazard/` symbol must be used on containers used to
    dispose of medical waste.
d533 1
a533 1
    .. /biohazard/ image:: biohazard.png
d536 6
a541 5
```/biohazard/``` will be replaced in-line by whatever the
``.. /biohazard/`` substitution generates (in this case, an image).  A
substitution contains the substitution name, followed by a directive
block containing a nested inline-compatible directive, such as
"image".  A transform is required to handle the substitution itself.
d543 1
a543 1
Syntax alternatives for the inline part:
d585 1
a585 1
   brackets (j) won't work in the target (the substitution declaration
d588 5
a592 4
   The ```/name/``` syntax (g) is reminiscent of substitution.
   However, it may have a misleading association with regexps, and
   looks like an absolute POSIX path. (i) is visually equivalent and
   lacking the connotations.
d620 1
a620 1
5. Redefine the trailing underscore syntax. See substitution syntax
d623 1
a623 1
Syntax alternatives for the substitution part::
d640 1
a640 2
2. Use syntax as in #1, but compressed.  If the substitution contents
   is a directive, append it to the substitution directive marker::
d648 3
a650 11
   name, obviating the need for a special "sub" directive name.  If we
   assume inline alternative 3 (g) (slashes), the matching
   substitutions would look like this::

       .. /biohazard/ image:: biohazard.png
          [height=20 width=20]

   There is potential conflict with short paths in comments, but
   that can be safely ignored.

   Using vertical bars, as in 4 (d) or 3 (i) above, we get this::
a654 2
   There's no significant conflict here.

d657 2
a658 3
   Instead of adding new substitution syntax, redefine the trailing
   underscore syntax to mean "directive reference" (or "substitution
   reference" or "tagging reference") instead of "hyperlink
d668 2
a669 2
   indistinguishable from directive names.  A more consistent syntax
   would be::
d679 2
a680 2
   "Jonathan" target contains a directive.  Alan's proposition is that
   the reference text be replaced by whatever the referenced directive
d688 1
a688 3
   The reference text would be replaced by the result of the directive
   target. This seems too indirect and complicated for easy
   comprehension.
d699 2
a700 4
The syntax that seems most consistent and suggestive of its intended
purpose is the combination of inline alternative 3/slashes with
substitution alternative 3::

d702 1
a702 1
    The `/biohazard/` symbol...
d704 1
a704 1
    .. /biohazard/ image:: biohazard.png
d712 1
a712 1
    The `/biohazard/`_ symbol...
d714 1
a714 1
    .. /biohazard/ image:: biohazard.png
d718 66
a783 31
This syntax has been incorporated into the spec and parser.

As for naming, here are candidates for the substitution reference
construct:

(a) substitution references
(b) tagging references
(c) inline directive references
(d) directive references
(e) indirect inline directive references
(f) inline directive placeholders
(g) inline directive insertion references
(h) directive insertion references

The following are candidates for naming the substitution construct:

(a) substitutions
(b) substitution directives
(c) tags
(d) tagged directives
(e) directive targets
(f) inline directives
(g) inline directive targets/definitions/declarations
(h) referenced directives
(i) indirect directives
(j) indirect directive definitions/declarations
(k) directive definitions
(l) indirect inline directives
(m) named directive declarations
(n) inline directive insertion definitions/declarations
(o) directive insertion definitions/declarations
@


1.12
log
@Updated substitutions.
@
text
@d6 2
a7 2
:Revision: $Revision: 1.9 $
:Date: $Date: 2001/11/06 00:49:35 $
d600 14
d615 1
a615 4
   "#" and "@@" are obtrusive.  "/" without backquotes looks just like
   a POSIX path; it is likely for such usage to appear in text.

   "|" is feasible.
d733 2
a734 2
As for naming, the following have been suggested for the substitution
reference construct:
d742 2
d745 1
a745 2
The following names have been suggested for the substitution
construct:
d753 9
a761 10
(g) inline directive targets
(h) inline directive definitions
(i) inline directive declarations
(j) referenced directives
(k) indirect directives
(l) indirect directive definitions
(m) indirect directive declarations
(n) directive definitions
(o) indirect inline directives
(p) named directive declarations
@


1.11
log
@updated
@
text
@d554 8
a561 1
       `name`@@ or `name`# or `name`& or `name`/ or `name`<
d564 1
a564 3
   usage, the following are not possible::

       `name`:: and `name`:
d568 22
a589 2
       `:name:` or `name:` or `name::` or `::name::` or `%name%` or
       `#name#` or `/name/` or `&name&` or even `<name>` or `&name;`
d591 2
a592 3
   (To avoid ML confusion those last two are definitely out.)

   The ```/name/``` syntax is reminiscent of substitution.
d596 4
a599 1
       #name# or @@name@@ or /name/ or...
d604 2
d611 3
a613 3
1. Use the existing directive syntax, with a predefined directive
   such as "sub".  It contains either replacement text or another
   directive resolving to an inline-compatible object::
a631 5
   Replacement text could also be (optionally) compressed::

       .. sub:: parrot That bird wouldn't *voom* if you put
          10,000,000 volts through it!

d636 2
a637 2
   assume inline alternative 3 (slashes), the matching substitutions
   would look like this::
a641 3
       .. /parrot/ That bird wouldn't *voom* if you put
          10,000,000 volts through it!

d645 7
d721 30
@


1.10
log
@Added description of Alan Jaffray's proposal for "tagging references" (alternative to substitution references).
@
text
@d646 1
a646 1
   (``::`` after ``.. _Jonathan:``.)
d650 7
a656 5
   the reference text be replaced by the product of the directive
   referred to, the "directive target".  A directive reference becomes
   a hyperlink reference if the contents of the directive target
   resolve to a hyperlink.  If the directive target resolves to an
   icon, the reference is replaced by an inline icon.
@


1.9
log
@updated substitutions
@
text
@d6 2
a7 2
:Revision: $Revision: 1.8 $
:Date: $Date: 2001/11/01 04:10:49 $
d536 1
a536 1
``.. /biohazard`` substitution generates (in this case, an image).  A
d538 2
a539 3
block containing either replacement text (one paragraph) or a nested
inline-compatible directive, such as "image".  A transform is required
to handle the substitution itself.
d577 3
d623 45
@


1.8
log
@  - Rearranged a bit.  - Added "Inline Substitutions".
@
text
@d6 2
a7 2
:Revision: $Revision: 1.7 $
:Date: $Date: 2001/10/26 04:33:17 $
d526 2
a527 2
inline image (using inline syntax alternative 1 & substitution
alternative 1)::
d529 1
a529 1
    The `biohazard`:sub: symbol must be used on containers used to
d532 2
a533 3
    .. sub:: biohazard
       .. image:: biohazard.png
          [height=20 width=20]
d535 6
a540 6
```biohazard`:sub:`` would be replaced in-line by whatever the ``sub::
biohazard`` directive generates.  A "sub" or "substitution" directive
would contain the substitution name as the directive's data, followed
by a directive block containing either replacement text (one
paragraph) or a nested inline-compatible directive, such as "image".
A transform would be required to handle the substitution itself.
d609 3
a611 3
   name, obviating the need for a directive name.  If we assume inline
   alternative 3 (slashes), the matching substitutions would look like
   this::
d622 4
a625 2
At first blush, my favorite combination is inline alternative 3
(slashes) with substitution alternative 3::
d632 4
a635 5
This syntax seems consistent and suggestive of its intended purpose.

I imagine that the next question might be: can we combine inline
substitutions with hyperlinks, so that we could click on an
image-link? Let's try::
d643 1
a643 3
That seems to work well.  Anonymous hyperlinks would also work.  I
don't know about "anonymous substitutions" though; it seems that
substitutions ought to be fully spelled out, always.
@


1.7
log
@*** empty log message ***
@
text
@d6 2
a7 2
:Revision: $Revision: 1.6 $
:Date: $Date: 2001/10/19 03:06:28 $
d11 4
a14 2
Setext_ or StructuredText_. See the `reStructuredText Markup
Specification`_ for full details of the established syntax.
d18 3
a20 1
    http://dev.zope.org/Members/jim/StructuredTextWiki/FrontPage
d22 1
a22 1
    http://structuredtext.sourceforge.net/spec/reStructuredText.txt
d260 43
d306 2
a307 2
Alan Jaffray came up with the idea of anonymous hyperlinks, added to
reStructuredText. Subsequently it was asserted that hyperlinks
d328 1
a328 1
     useful, so they're not included. 
d513 1
a513 1
Anonymous Hyperlinks
d516 90
a605 1
Alan Jaffray came up with this idea, along with the following syntax::
d607 1
a607 1
    Search the `Python DOC-SIG mailing list archives`{}_.
d609 4
a612 1
    .. _: http://mail.python.org/pipermail/doc-sig/
d614 2
a615 2
The idea is sound and useful. I suggested a "double underscore"
syntax::
d617 2
a618 1
    Search the `Python DOC-SIG mailing list archives`__.
d620 2
a621 1
    .. __: http://mail.python.org/pipermail/doc-sig/
d623 2
a624 2
But perhaps single underscores are okay? The syntax looks better, but
the hyperlink itself doesn't explicitly say "anonymous"::
d626 1
a626 1
    Search the `Python DOC-SIG mailing list archives`_.
d628 2
a629 1
    .. _: http://mail.python.org/pipermail/doc-sig/
d631 1
a631 3
Mixing anonymous and named hyperlinks becomes confusing. The order of
targets is not significant for named hyperlinks, but it is for
anonymous hyperlinks::
d633 3
a635 1
    Hyperlinks: anonymous_, named_, and another anonymous_.
d637 1
a637 3
    .. _named: named
    .. _: anonymous1
    .. _: anonymous2
d639 3
a641 5
Without the extra syntax of double underscores, determining which
hyperlink references are anonymous may be difficult. We'd have to
check which references don't have corresponding targets, and match
those up with anonymous targets. Keeping to a simple consistent
ordering (as with auto-numbered footnotes) seems simplest.
d643 3
a645 2
reStructuredText will use the explicit double-underscore syntax for
anonymous hyperlinks.
@


1.6
log
@  - Added "Reworking Explicit Markup" section.
@
text
@d6 2
a7 2
:Revision: $Revision: 1.4 $
:Date: $Date: 2001/09/01 15:46:43 $
d12 1
a12 1
Specification` for full details of the established syntax.
@


1.5
log
@  - Added "anonymous Hyperlinks".
@
text
@d165 1
a165 1
   
d256 159
d472 2
a473 2
   
    .. _: http://mail.python.org/pipermail/doc-sig/    
@


1.4
log
@emacs stanza; minor changes
@
text
@d6 2
a7 2
:Revision: $Revision: 1.3 $
:Date: $Date: 2001/08/28 03:10:15 $
d306 42
@


1.3
log
@minor edits
@
text
@d6 2
a7 2
:Revision: $Revision: 1.2 $
:Date: $Date: 2001/08/22 03:44:10 $
d312 1
@


1.2
log
@  - Added 'Interpreted Text "Roles"', 'Comments',    'Justification for Backquotes in Phrase-Links'.
@
text
@d6 2
a7 2
:Revision: $Revision: 1.1 $
:Date: $Date: 2001/08/16 02:43:09 $
d195 1
a195 1
   Syntax #3 is the current reference implementation.
d228 2
d256 2
a257 2
Justification for Backquotes in Phrase-Links
============================================
d290 1
a290 1
7. Single backquo;tes are then freed up for interpreted text.
d308 6
a313 5
Local Variables:
mode: indented-text
indent-tabs-mode: nil
fill-column: 70
End:
@


1.1
log
@"Record of reStructuredText Syntax Alternatives"
@
text
@d5 8
a12 7
:Contact: dgoodger@@bigfoot.com
:Revision: $Revision$
:Date: $Date$

The following are syntax ideas that were considered for
reStructuredText, which did not originate with Setext_ or
StructuredText_.
d17 2
d133 172
a310 1

@

