head	1.51;
access;
symbols
	RELEASE:1.1.1.1
	Rrefactor-test:1.1.1.1.0.4
	rel-0-3:1.1.1.1.0.2
	open:1.1.1;
locks; strict;
comment	@# @;


1.51
date	2002.04.18.02.46.51;	author goodger;	state Exp;
branches;
next	1.50;

1.50
date	2002.04.13.16.43.53;	author goodger;	state Exp;
branches;
next	1.49;

1.49
date	2002.03.16.05.38.29;	author goodger;	state Exp;
branches;
next	1.48;

1.48
date	2002.03.12.03.27.17;	author goodger;	state Exp;
branches;
next	1.47;

1.47
date	2002.03.11.03.20.41;	author goodger;	state Exp;
branches;
next	1.46;

1.46
date	2002.03.07.03.24.43;	author goodger;	state Exp;
branches;
next	1.45;

1.45
date	2002.03.01.03.10.23;	author goodger;	state Exp;
branches;
next	1.44;

1.44
date	2002.02.23.16.47.34;	author goodger;	state Exp;
branches;
next	1.43;

1.43
date	2002.02.21.03.38.03;	author goodger;	state Exp;
branches;
next	1.42;

1.42
date	2002.02.15.22.57.38;	author goodger;	state Exp;
branches;
next	1.41;

1.41
date	2002.02.12.02.26.53;	author goodger;	state Exp;
branches;
next	1.40;

1.40
date	2002.02.06.02.24.58;	author goodger;	state Exp;
branches;
next	1.39;

1.39
date	2002.01.30.05.01.25;	author goodger;	state Exp;
branches;
next	1.38;

1.38
date	2002.01.28.02.12.41;	author goodger;	state Exp;
branches;
next	1.37;

1.37
date	2002.01.25.23.48.14;	author goodger;	state Exp;
branches;
next	1.36;

1.36
date	2002.01.16.06.16.00;	author goodger;	state Exp;
branches;
next	1.35;

1.35
date	2001.11.22.04.20.49;	author goodger;	state Exp;
branches;
next	1.34;

1.34
date	2001.11.19.04.27.54;	author goodger;	state Exp;
branches;
next	1.33;

1.33
date	2001.11.13.03.15.42;	author goodger;	state Exp;
branches;
next	1.32;

1.32
date	2001.11.06.00.51.33;	author goodger;	state Exp;
branches;
next	1.31;

1.31
date	2001.11.01.04.08.18;	author goodger;	state Exp;
branches;
next	1.30;

1.30
date	2001.10.31.05.52.39;	author goodger;	state Exp;
branches;
next	1.29;

1.29
date	2001.10.30.05.01.53;	author goodger;	state Exp;
branches;
next	1.28;

1.28
date	2001.10.27.05.18.35;	author goodger;	state Exp;
branches;
next	1.27;

1.27
date	2001.10.23.03.36.44;	author goodger;	state Exp;
branches;
next	1.26;

1.26
date	2001.10.20.02.52.35;	author goodger;	state Exp;
branches;
next	1.25;

1.25
date	2001.10.18.03.53.42;	author goodger;	state Exp;
branches;
next	1.24;

1.24
date	2001.09.26.03.42.06;	author goodger;	state Exp;
branches;
next	1.23;

1.23
date	2001.09.22.02.41.39;	author goodger;	state Exp;
branches;
next	1.22;

1.22
date	2001.09.18.21.27.24;	author goodger;	state Exp;
branches;
next	1.21;

1.21
date	2001.09.18.04.37.36;	author goodger;	state Exp;
branches;
next	1.20;

1.20
date	2001.09.17.04.24.20;	author goodger;	state Exp;
branches;
next	1.19;

1.19
date	2001.09.13.22.32.37;	author goodger;	state Exp;
branches;
next	1.18;

1.18
date	2001.09.13.02.25.32;	author goodger;	state Exp;
branches;
next	1.17;

1.17
date	2001.09.12.03.54.33;	author goodger;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.10.04.32.48;	author goodger;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.07.01.35.08;	author goodger;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.05.02.49.04;	author goodger;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.04.04.13.27;	author goodger;	state Exp;
branches;
next	1.12;

1.12
date	2001.09.02.13.49.29;	author goodger;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.01.15.53.13;	author goodger;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.28.03.11.29;	author goodger;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.25.02.05.16;	author goodger;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.23.04.17.43;	author goodger;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.22.03.33.54;	author goodger;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.14.03.49.25;	author goodger;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.11.02.13.23;	author goodger;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.02.02.11.19;	author goodger;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.01.03.00.54;	author goodger;	state Exp;
branches;
next	1.2;

1.2
date	2001.07.28.05.16.59;	author goodger;	state Exp;
branches;
next	1.1;

1.1
date	2001.07.21.22.14.09;	author goodger;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.07.21.22.14.09;	author goodger;	state Exp;
branches;
next	;


desc
@@


1.51
log
@Fixed option list bug.
@
text
@"""
:Author: David Goodger
:Contact: goodger@@users.sourceforge.net
:Revision: $Revision: 1.50 $
:Date: $Date: 2002/04/13 16:43:53 $
:Copyright: This module has been placed in the public domain.

This is the ``dps.parsers.restructuredtext.states`` module, the core of the
reStructuredText parser. It defines the following:

:Classes:
    - `RSTStateMachine`: reStructuredText parser's entry point.
    - `NestedStateMachine`: recursive StateMachine.
    - `RSTState`: reStructuredText State superclass.
    - `Body`: Generic classifier of the first line of a block.
    - `BulletList`: Second and subsequent bullet_list list_items
    - `DefinitionList`: Second and subsequent definition_list_items.
    - `EnumeratedList`: Second and subsequent enumerated_list list_items.
    - `FieldList`: Second and subsequent fields.
    - `OptionList`: Second and subsequent option_list_items.
    - `Explicit`: Second and subsequent explicit markup constructs.
    - `SubstitutionDef`: For embedded directives in substitution definitions.
    - `Text`: Classifier of second line of a text block.
    - `Definition`: Second line of potential definition_list_item.
    - `Line`: Second line of overlined section title or transition marker.
    - `Stuff`: An auxilliary collection class.

:Exception classes:
    - `MarkupError`
    - `ParserError`
    - `TransformationError`

:Functions:
    - `escape2null()`: Return a string, escape-backslashes converted to nulls.
    - `unescape()`: Return a string, nulls removed or restored to backslashes.
    - `normname()`: Return a case- and whitespace-normalized name.

:Attributes:
    - `stateclasses`: set of State classes used with `RSTStateMachine`.

Parser Overview
===============

The reStructuredText parser is implemented as a state machine, examining its
input one line at a time. To understand how the parser works, please first
become familiar with the `dps.statemachine` module. In the description below,
references are made to classes defined in this module; please see the
individual classes for details.

Parsing proceeds as follows:

1. The state machine examines each line of input, checking each of the
   transition patterns of the state `Body`, in order, looking for a match. The
   implicit transitions (blank lines and indentation) are checked before any
   others. The 'text' transition is a catch-all (matches anything).

2. The method associated with the matched transition pattern is called.

   A. Some transition methods are self-contained, appending elements to the
      document tree ('doctest' parses a doctest block). The parser's current
      line index is advanced to the end of the element, and parsing continues
      with step 1.

   B. Others trigger the creation of a nested state machine, whose job is to
      parse a compound construct ('indent' does a block quote, 'bullet' does a
      bullet list, 'overline' does a section [first checking for a valid
      section header]).

      - In the case of lists and explicit markup, a new state machine is
        created and run to parse the first item.

      - A new state machine is created and its initial state is set to the
        appropriate specialized state (`BulletList` in the case of the
        'bullet' transition). This state machine is run to parse the compound
        element (or series of explicit markup elements), and returns as soon
        as a non-member element is encountered. For example, the `BulletList`
        state machine aborts as soon as it encounters an element which is not
        a list item of that bullet list. The optional omission of
        inter-element blank lines is handled by the nested state machine.

      - The current line index is advanced to the end of the elements parsed,
        and parsing continues with step 1.

   C. The result of the 'text' transition depends on the next line of text.
      The current state is changed to `Text`, under which the second line is
      examined. If the second line is:

      - Indented: The element is a definition list item, and parsing proceeds
        similarly to step 2.B, using the `DefinitionList` state.

      - A line of uniform punctuation characters: The element is a section
        header; again, parsing proceeds as in step 2.B, and `Body` is still
        used.

      - Anything else: The element is a paragraph, which is examined for
        inline markup and appended to the parent element. Processing continues
        with step 1.
"""

__docformat__ = 'reStructuredText'


import sys, re, string
from dps import nodes, statemachine, utils, roman, urischemes
from dps.statemachine import StateMachineWS, StateWS
from dps.utils import normname
import directives, languages
from tableparser import TableParser, TableMarkupError


class MarkupError(Exception): pass
class ParserError(Exception): pass


class Stuff:

    """Stores a bunch of stuff for dotted-attribute access."""

    def __init__(self, **keywordargs):
        self.__dict__.update(keywordargs)


class RSTStateMachine(StateMachineWS):

    """
    reStructuredText's master StateMachine.

    The entry point to reStructuredText parsing is the `run()` method.
    """

    def run(self, inputlines, docroot, inputoffset=0, matchtitles=1):
        """
        Parse `inputlines` and return a `dps.nodes.document` instance.

        Extend `StateMachineWS.run()`: set up parse-global data, run the
        StateMachine, and return the resulting
        document.
        """
        self.language = languages.getlanguage(docroot.languagecode)
        self.matchtitles = matchtitles
        self.memo = Stuff(document=docroot,
                          reporter=docroot.reporter,
                          language=self.language,
                          titlestyles=[],
                          sectionlevel=0)
        self.node = docroot
        results = StateMachineWS.run(self, inputlines, inputoffset)
        assert results == [], 'RSTStateMachine.run() results should be empty.'
        self.node = self.memo = None    # remove unneeded references


class NestedStateMachine(StateMachineWS):

    """
    StateMachine run from within other StateMachine runs, to parse nested
    document structures.
    """

    def run(self, inputlines, inputoffset, memo, node, matchtitles=1):
        """
        Parse `inputlines` and populate a `dps.nodes.document` instance.

        Extend `StateMachineWS.run()`: set up document-wide data.
        """
        self.matchtitles = matchtitles
        self.memo = memo
        self.node = node
        results = StateMachineWS.run(self, inputlines, inputoffset)
        assert results == [], 'NestedStateMachine.run() results should be empty'
        return results


class RSTState(StateWS):

    """
    reStructuredText State superclass.

    Contains methods used by all State subclasses.
    """

    nestedSM = NestedStateMachine

    def __init__(self, statemachine, debug=0):
        self.nestedSMkwargs = {'stateclasses': stateclasses,
                               'initialstate': 'Body'}
        StateWS.__init__(self, statemachine, debug)

    def gotoline(self, abslineoffset):
        """Jump to input line `abslineoffset`, ignoring jumps past the end."""
        try:
            self.statemachine.gotoline(abslineoffset)
        except IndexError:
            pass

    def bof(self, context):
        """Called at beginning of file."""
        return [], []

    def nestedparse(self, block, inputoffset, node, matchtitles=0,
                      statemachineclass=None, statemachinekwargs=None):
        """
        Create a new StateMachine rooted at `node` and run it over the input
        `block`.
        """
        if statemachineclass is None:
            statemachineclass = self.nestedSM
        if statemachinekwargs is None:
            statemachinekwargs = self.nestedSMkwargs
        statemachine = statemachineclass(debug=self.debug, **statemachinekwargs)
        statemachine.run(block, inputoffset, memo=self.statemachine.memo,
                         node=node, matchtitles=matchtitles)
        statemachine.unlink()
        return statemachine.abslineoffset()

    def nestedlistparse(self, block, inputoffset, node, initialstate,
                        blankfinish, blankfinishstate=None, extrasettings={},
                        matchtitles=0, statemachineclass=None,
                        statemachinekwargs=None):
        """
        Create a new StateMachine rooted at `node` and run it over the input
        `block`. Also keep track of optional intermdediate blank lines and the
        required final one.
        """
        if statemachineclass is None:
            statemachineclass = self.nestedSM
        if statemachinekwargs is None:
            statemachinekwargs = self.nestedSMkwargs.copy()
        statemachinekwargs['initialstate'] = initialstate
        statemachine = statemachineclass(debug=self.debug, **statemachinekwargs)
        if blankfinishstate is None:
            blankfinishstate = initialstate
        statemachine.states[blankfinishstate].blankfinish = blankfinish
        for key, value in extrasettings.items():
            setattr(statemachine.states[initialstate], key, value)
        statemachine.run(block, inputoffset, memo=self.statemachine.memo,
                         node=node, matchtitles=matchtitles)
        blankfinish = statemachine.states[blankfinishstate].blankfinish
        statemachine.unlink()
        return statemachine.abslineoffset(), blankfinish

    def section(self, title, source, style, lineno):
        """
        When a new section is reached that isn't a subsection of the current
        section, back up the line count (use previousline(-x)), then raise
        EOFError. The current StateMachine will finish, then the calling
        StateMachine can re-examine the title. This will work its way back up
        the calling chain until the correct section level isreached.

        Alternative: Evaluate the title, store the title info & level, and
        back up the chain until that level is reached. Store in memo? Or
        return in results?
        """
        if self.checksubsection(source, style, lineno):
            self.newsubsection(title, lineno)

    def checksubsection(self, source, style, lineno):
        """
        Check for a valid subsection header. Return 1 (true) or None (false).

        :Exception: `EOFError` when a sibling or supersection encountered.
        """
        memo = self.statemachine.memo
        titlestyles = memo.titlestyles
        mylevel = memo.sectionlevel
        try:                            # check for existing title style
            level = titlestyles.index(style) + 1
        except ValueError:              # new title style
            if len(titlestyles) == memo.sectionlevel: # new subsection
                titlestyles.append(style)
                return 1
            else:                       # not at lowest level
                self.statemachine.node += self.titleinconsistent(source, lineno)
                return None
        if level <= mylevel:            # sibling or supersection
            memo.sectionlevel = level   # bubble up to parent section
            # back up 2 lines for underline title, 3 for overline title
            self.statemachine.previousline(len(style) + 1)
            raise EOFError              # let parent section re-evaluate
        if level == mylevel + 1:        # immediate subsection
            return 1
        else:                           # invalid subsection
            self.statemachine.node += self.titleinconsistent(source, lineno)
            return None

    def titleinconsistent(self, sourcetext, lineno):
        literalblock = nodes.literal_block('', sourcetext)
        error = self.statemachine.memo.reporter.severe(
              'Title level inconsistent at line %s:' % lineno, '', literalblock)
        return error

    def newsubsection(self, title, lineno):
        """Append new subsection to document tree. On return, check level."""
        memo = self.statemachine.memo
        mylevel = memo.sectionlevel
        memo.sectionlevel += 1
        sectionnode = nodes.section()
        self.statemachine.node += sectionnode
        textnodes, messages = self.inline_text(title, lineno)
        titlenode = nodes.title(title, '', *textnodes)
        name = normname(titlenode.astext())
        sectionnode['name'] = name
        sectionnode += titlenode
        sectionnode += messages
        memo.document.note_implicit_target(sectionnode, sectionnode)
        offset = self.statemachine.lineoffset + 1
        absoffset = self.statemachine.abslineoffset() + 1
        newabsoffset = self.nestedparse(
              self.statemachine.inputlines[offset:], inputoffset=absoffset,
              node=sectionnode, matchtitles=1)
        self.gotoline(newabsoffset)
        if memo.sectionlevel <= mylevel: # can't handle next section?
            raise EOFError              # bubble up to supersection
        # reset sectionlevel; next pass will detect it properly
        memo.sectionlevel = mylevel

    def paragraph(self, lines, lineno):
        """
        Return a list (paragraph & messages) and a boolean: literal_block next?
        """
        data = '\n'.join(lines).rstrip()
        if data[-2:] == '::':
            if len(data) == 2:
                return [], 1
            elif data[-3] == ' ':
                text = data[:-3].rstrip()
            else:
                text = data[:-1]
            literalnext = 1
        else:
            text = data
            literalnext = 0
        textnodes, messages = self.inline_text(text, lineno)
        p = nodes.paragraph(data, '', *textnodes)
        return [p] + messages, literalnext

    inline = Stuff()
    """Patterns and constants used for inline markup recognition."""

    inline.openers = '\'"([{<'
    inline.closers = '\'")]}>'
    inline.start_string_prefix = (r'(?:(?<=^)|(?<=[ \n%s]))'
                                  % re.escape(inline.openers))
    inline.end_string_suffix = (r'(?:(?=$)|(?=[- \n.,:;!?%s]))'
                                % re.escape(inline.closers))
    inline.non_whitespace_before = r'(?<![ \n])'
    inline.non_whitespace_escape_before = r'(?<![ \n\x00])'
    inline.non_whitespace_after = r'(?![ \n])'
    inline.simplename = r'[a-zA-Z0-9](?:[-_.a-zA-Z0-9]*[a-zA-Z0-9])?'
    inline.uric = r"""[-_.!~*'()[\];/:@@&=+$,%a-zA-Z0-9]"""
    inline.urilast = r"""[_~/\]a-zA-Z0-9]"""
    inline.emailc = r"""[-_!~*'{|}/#?^`&=+$%a-zA-Z0-9]"""
    inline.identity = string.maketrans('', '')
    inline.null2backslash = string.maketrans('\x00', '\\')
    inline.patterns = Stuff(
          initial=re.compile(r"""
                             %s             # start-string prefix
                             (
                               (              # start-strings only (group 2):
                                   \*\*         # strong
                                 |
                                   \*           # emphasis
                                   (?!\*)         # but not strong
                                 |
                                   ``           # literal
                                 |
                                   _`           # inline hyperlink target
                                 |
                                   \|           # substitution_reference start
                               )
                               %s             # no whitespace after
                             |              # *OR*
                               (              # whole constructs (group 3):
                                   (%s)         # reference name (4)
                                   (__?)        # end-string (5)
                                 |
                                   \[           # footnote_reference or
                                                # citation_reference start
                                   (            # label (group 6):
                                       [0-9]+     # manually numbered
                                     |          # *OR*
                                       \#(?:%s)?  # auto-numbered (w/ label?)
                                     |          # *OR*
                                       \*         # auto-symbol
                                     |          # *OR*
                                       (%s)       # citation reference (group 7)
                                   )
                                   (\]_)        # end-string (group 8)
                               )
                               %s             # end-string suffix
                             |              # *OR*
                               ((?::%s:)?)    # optional role (group 9)
                               (              # start-string (group 10)
                                 `              # interpreted text
                                                # or phrase reference
                                 (?!`)          # but not literal
                               )
                               %s             # no whitespace after
                             )
                             """ % (inline.start_string_prefix,
                                    inline.non_whitespace_after,
                                    inline.simplename,
                                    inline.simplename,
                                    inline.simplename,
                                    inline.end_string_suffix,
                                    inline.simplename,
                                    inline.non_whitespace_after,),
                             re.VERBOSE),
          emphasis=re.compile(inline.non_whitespace_escape_before
                              + r'(\*)' + inline.end_string_suffix),
          strong=re.compile(inline.non_whitespace_escape_before
                            + r'(\*\*)' + inline.end_string_suffix),
          interpreted_or_phrase_ref=re.compile(
                '%s(`(:%s:|__?)?)%s' % (inline.non_whitespace_escape_before,
                                        inline.simplename,
                                        inline.end_string_suffix)),
          literal=re.compile(inline.non_whitespace_before + '(``)'
                             + inline.end_string_suffix),
          target=re.compile(inline.non_whitespace_escape_before
                            + r'(`)' + inline.end_string_suffix),
          substitution_ref=re.compile(inline.non_whitespace_escape_before
                                      + r'(\|_{0,2})'
                                      + inline.end_string_suffix),
          uri=re.compile(
                r"""
                %s                          # start-string prefix
                (
                  (                           # absolute URI (group 2)
                    (                           # scheme (http, ftp, mailto)
                      [a-zA-Z][a-zA-Z0-9.+-]*     # (group 3)
                    )
                    :
                    (?:
                      (?:                         # either:
                        (?://?)?                    # hierarchical URI
                        %s*                         # URI characters
                        %s                          # final URI char
                      )
                      (?:                         # optional query
                        \?%s*                       # URI characters
                        %s                          # final URI char
                      )?
                      (?:                         # optional fragment
                        \#%s*                       # URI characters
                        %s                          # final URI char
                      )?
                    )
                  )
                |                           # *OR*
                  (                           # email address (group 4)
                    %s+(?:\.%s+)*               # name
                    @@                           # at
                    %s+(?:\.%s*)*               # host
                    %s                          # final URI char
                  )
                )
                %s                          # end-string suffix
                """ % (inline.start_string_prefix,
                       inline.uric, inline.urilast,
                       inline.uric, inline.urilast,
                       inline.uric, inline.urilast,
                       inline.emailc, inline.emailc,
                       inline.emailc, inline.emailc,
                       inline.urilast,
                       inline.end_string_suffix,),
                re.VERBOSE))
    inline.groups = Stuff(initial=Stuff(start=2, whole=3, refname=4, refend=5,
                                        footnotelabel=6, citationlabel=7,
                                        fnend=8, role=9, backquote=10),
                          interpreted_or_phrase_ref=Stuff(suffix=2),
                          uri=Stuff(whole=1, absolute=2, scheme=3, email=4))

    def quotedstart(self, match):
        """Return 1 if inline markup start-string is 'quoted', 0 if not."""
        string = match.string
        start = match.start()
        end = match.end()
        if start == 0:                  # start-string at beginning of text
            return 0
        prestart = string[start - 1]
        try:
            poststart = string[end]
            if self.inline.openers.index(prestart) \
                  == self.inline.closers.index(poststart):   # quoted
                return 1
        except IndexError:              # start-string at end of text
            return 1
        except ValueError:              # not quoted
            pass
        return 0

    def inlineobj(self, match, lineno, pattern, nodeclass,
                  restorebackslashes=0):
        string = match.string
        matchstart = match.start(self.inline.groups.initial.start)
        matchend = match.end(self.inline.groups.initial.start)
        if self.quotedstart(match):
            return (string[:matchend], [], string[matchend:], [], '')
        endmatch = pattern.search(string[matchend:])
        if endmatch and endmatch.start(1):  # 1 or more chars
            text = unescape(endmatch.string[:endmatch.start(1)],
                            restorebackslashes)
            rawsource = unescape(string[matchstart:matchend+endmatch.end(1)], 1)
            return (string[:matchstart], [nodeclass(rawsource, text)],
                    string[matchend:][endmatch.end(1):], [], endmatch.group(1))
        msg = self.statemachine.memo.reporter.warning(
              'Inline %s start-string without end-string '
              'at line %s.' % (nodeclass.__name__, lineno))
        text = unescape(string[matchstart:matchend], 1)
        rawsource = unescape(string[matchstart:matchend], 1)
        prb = self.problematic(text, rawsource, msg)
        return string[:matchstart], [prb], string[matchend:], [msg], ''

    def problematic(self, text, rawsource, message):
        msgid = self.statemachine.memo.document.set_id(message,
                                                       self.statemachine.node)
        problematic = nodes.problematic(rawsource, text, refid=msgid)
        prbid = self.statemachine.memo.document.set_id(problematic)
        message.add_backref(prbid)
        return problematic

    def emphasis(self, match, lineno):
        before, inlines, remaining, sysmessages, endstring = self.inlineobj(
              match, lineno, self.inline.patterns.emphasis, nodes.emphasis)
        return before, inlines, remaining, sysmessages

    def strong(self, match, lineno):
        before, inlines, remaining, sysmessages, endstring = self.inlineobj(
              match, lineno, self.inline.patterns.strong, nodes.strong)
        return before, inlines, remaining, sysmessages

    def interpreted_or_phrase_ref(self, match, lineno):
        pattern = self.inline.patterns.interpreted_or_phrase_ref
        rolegroup = self.inline.groups.initial.role
        backquote = self.inline.groups.initial.backquote
        string = match.string
        matchstart = match.start(backquote)
        matchend = match.end(backquote)
        rolestart = match.start(rolegroup)
        role = match.group(rolegroup)
        position = ''
        if role:
            role = role[1:-1]
            position = 'prefix'
        elif self.quotedstart(match):
            return (string[:matchend], [], string[matchend:], [])
        endmatch = pattern.search(string[matchend:])
        if endmatch and endmatch.start(1):  # 1 or more chars
            escaped = endmatch.string[:endmatch.start(1)]
            text = unescape(escaped, 0)
            rawsource = unescape(
                  string[match.start():matchend+endmatch.end()], 1)
            if rawsource[-1:] == '_':
                if role:
                    msg = self.statemachine.memo.reporter.warning(
                          'Mismatch: inline interpreted text start-string and '
                          'role with phrase-reference end-string at line %s.'
                          % lineno)
                    text = unescape(string[matchstart:matchend], 1)
                    rawsource = unescape(string[matchstart:matchend], 1)
                    prb = self.problematic(text, rawsource, msg)
                    return (string[:matchstart], [prb], string[matchend:],
                            [msg])
                return self.phrase_ref(
                      string[:matchstart], string[matchend:][endmatch.end():],
                      text, rawsource)
            else:
                return self.interpreted(
                      string[:rolestart], string[matchend:][endmatch.end():],
                      endmatch, role, position, lineno,
                      escaped, rawsource, text)
        msg = self.statemachine.memo.reporter.warning(
              'Inline interpreted text or phrase reference start-string '
              'without end-string at line %s.' % lineno)
        text = unescape(string[matchstart:matchend], 1)
        rawsource = unescape(string[matchstart:matchend], 1)
        prb = self.problematic(text, rawsource, msg)
        return string[:matchstart], [prb], string[matchend:], [msg]

    def phrase_ref(self, before, after, text, rawsource):
        refname = normname(text)
        reference = nodes.reference(rawsource, text)
        if rawsource[-2:] == '__':
            reference['anonymous'] = 1
            self.statemachine.memo.document.note_anonymous_ref(reference)
        else:
            reference['refname'] = refname
            self.statemachine.memo.document.note_refname(reference)
        return before, [reference], after, []

    def interpreted(self, before, after, endmatch, role, position, lineno,
                    escaped, rawsource, text):
        suffix = self.inline.groups.interpreted_or_phrase_ref.suffix
        if endmatch.group(suffix):
            if role:
                msg = self.statemachine.memo.reporter.warning(
                      'Multiple roles in interpreted text at line %s.'
                      % lineno)
                return (before + rawsource, [], after, [msg])
            role = endmatch.group(suffix)[1:-1]
            position = 'suffix'
        if role:
            atts = {'role': role, 'position': position}
        else:
            atts = {}
        return before, [nodes.interpreted(rawsource, text, **atts)], after, []

    def literal(self, match, lineno):
        before, inlines, remaining, sysmessages, endstring = self.inlineobj(
              match, lineno, self.inline.patterns.literal, nodes.literal,
              restorebackslashes=1)
        return before, inlines, remaining, sysmessages

    def inline_target(self, match, lineno):
        before, inlines, remaining, sysmessages, endstring = self.inlineobj(
              match, lineno, self.inline.patterns.target, nodes.target)
        if inlines and isinstance(inlines[0], nodes.target):
            assert len(inlines) == 1
            target = inlines[0]
            name = normname(target.astext())
            target['name'] = name
            self.statemachine.memo.document.note_explicit_target(
                  target, self.statemachine.node)
        return before, inlines, remaining, sysmessages

    def substitution_reference(self, match, lineno):
        before, inlines, remaining, sysmessages, endstring = self.inlineobj(
              match, lineno, self.inline.patterns.substitution_ref,
              nodes.substitution_reference)
        if inlines:
            assert len(inlines) == 1
            subrefnode = inlines[0]
            assert isinstance(subrefnode, nodes.substitution_reference)
            subreftext = subrefnode.astext()
            refname = normname(subreftext)
            subrefnode['refname'] = refname
            self.statemachine.memo.document.note_substitution_ref(subrefnode)
            if endstring[-1:] == '_':
                referencenode = nodes.reference('|%s%s' % (subreftext, endstring), '')
                if endstring[-2:] == '__':
                    referencenode['anonymous'] = 1
                    self.statemachine.memo.document.note_anonymous_ref(referencenode)
                else:
                    referencenode['refname'] = refname
                    self.statemachine.memo.document.note_refname(referencenode)
                referencenode += subrefnode
                inlines = [referencenode]
        return before, inlines, remaining, sysmessages

    def footnote_reference(self, match, lineno):
        """
        Handles `nodes.footnote_reference` and `nodes.citation_reference`
        elements.
        """
        label = match.group(self.inline.groups.initial.footnotelabel)
        refname = normname(label)
        if match.group(self.inline.groups.initial.citationlabel):
            refnode = nodes.citation_reference('[%s]_' % label, refname=refname)
            refnode += nodes.Text(label)
            self.statemachine.memo.document.note_citation_ref(refnode)
        else:
            refnode = nodes.footnote_reference('[%s]_' % label)
            if refname[0] == '#':
                refname = refname[1:]
                refnode['auto'] = 1
                self.statemachine.memo.document.note_autofootnote_ref(refnode)
            elif refname == '*':
                refname = ''
                refnode['auto'] = '*'
                self.statemachine.memo.document.note_symbol_footnote_ref(
                      refnode)
            else:
                refnode += nodes.Text(label)
            if refname:
                refnode['refname'] = refname
                self.statemachine.memo.document.note_footnote_ref(refnode)
        string = match.string
        matchstart = match.start(self.inline.groups.initial.whole)
        matchend = match.end(self.inline.groups.initial.whole)
        return (string[:matchstart], [refnode], string[matchend:], [])

    def reference(self, match, lineno, anonymous=None):
        referencename = match.group(self.inline.groups.initial.refname)
        refname = normname(referencename)
        referencenode = nodes.reference(
              referencename + match.group(self.inline.groups.initial.refend),
              referencename)
        if anonymous:
            referencenode['anonymous'] = 1
            self.statemachine.memo.document.note_anonymous_ref(referencenode)
        else:
            referencenode['refname'] = refname
            self.statemachine.memo.document.note_refname(referencenode)
        string = match.string
        matchstart = match.start(self.inline.groups.initial.whole)
        matchend = match.end(self.inline.groups.initial.whole)
        return (string[:matchstart], [referencenode], string[matchend:], [])

    def anonymous_reference(self, match, lineno):
        return self.reference(match, lineno, anonymous=1)

    def standalone_uri(self, text, lineno):
        pattern = self.inline.patterns.uri
        whole = self.inline.groups.uri.whole
        scheme = self.inline.groups.uri.scheme
        email = self.inline.groups.uri.email
        remainder = text
        textnodes = []
        start = 0
        while 1:
            match = pattern.search(remainder, start)
            if match:
                if not match.group(scheme) or \
                      urischemes.schemes.has_key(match.group(scheme).lower()):
                    if match.start(whole) > 0:
                        textnodes.append(nodes.Text(unescape(
                              remainder[:match.start(whole)])))
                    if match.group(email):
                        addscheme = 'mailto:'
                    else:
                        addscheme = ''
                    text = match.group(whole)
                    unescaped = unescape(text, 0)
                    textnodes.append(
                          nodes.reference(unescape(text, 1), unescaped,
                                          refuri=addscheme + unescaped))
                    remainder = remainder[match.end(whole):]
                    start = 0
                else:                   # not a valid scheme
                    start = match.end(whole)
            else:
                if remainder:
                    textnodes.append(nodes.Text(unescape(remainder)))
                break
        return textnodes

    inline.dispatch = {'*': emphasis,
                       '**': strong,
                       '`': interpreted_or_phrase_ref,
                       '``': literal,
                       '_`': inline_target,
                       ']_': footnote_reference,
                       '|': substitution_reference,
                       '_': reference,
                       '__': anonymous_reference}

    def inline_text(self, text, lineno):
        """
        Return 2 lists: nodes (text and inline elements), and system_messages.

        Using a `pattern` matching start-strings (for emphasis, strong,
        interpreted, phrase reference, literal, substitution reference, and
        inline target) or complete constructs (simple reference, footnote
        reference) we search for a candidate. When one is found, we check for
        validity (e.g., not a quoted '*' character). If valid, search for the
        corresponding end string if applicable, and check for validity. If not
        found or invalid, generate a warning and ignore the start-string.
        Standalone hyperlinks are found last.
        """
        pattern = self.inline.patterns.initial
        dispatch = self.inline.dispatch
        start = self.inline.groups.initial.start - 1
        backquote = self.inline.groups.initial.backquote - 1
        refend = self.inline.groups.initial.refend - 1
        fnend = self.inline.groups.initial.fnend - 1
        remaining = escape2null(text)
        processed = []
        unprocessed = []
        messages = []
        while remaining:
            match = pattern.search(remaining)
            if match:
                groups = match.groups()
                before, inlines, remaining, sysmessages = \
                      dispatch[groups[start] or groups[backquote]
                               or groups[refend]
                               or groups[fnend]](self, match, lineno)
                unprocessed.append(before)
                messages += sysmessages
                if inlines:
                    processed += self.standalone_uri(''.join(unprocessed),
                                                     lineno)
                    processed += inlines
                    unprocessed = []
            else:
                break
        remaining = ''.join(unprocessed) + remaining
        if remaining:
            processed += self.standalone_uri(remaining, lineno)
        return processed, messages

    def unindentwarning(self):
        return self.statemachine.memo.reporter.warning(
              ('Unindent without blank line at line %s.'
                  % (self.statemachine.abslineno() + 1)))


class Body(RSTState):

    """
    Generic classifier of the first line of a block.
    """

    enum = Stuff()
    """Enumerated list parsing information."""

    enum.formatinfo = {
          'parens': Stuff(prefix='(', suffix=')', start=1, end=-1),
          'rparen': Stuff(prefix='', suffix=')', start=0, end=-1),
          'period': Stuff(prefix='', suffix='.', start=0, end=-1)}
    enum.formats = enum.formatinfo.keys()
    enum.sequences = ['arabic', 'loweralpha', 'upperalpha',
                      'lowerroman', 'upperroman'] # ORDERED!
    enum.sequencepats = {'arabic': '[0-9]+',
                         'loweralpha': '[a-z]',
                         'upperalpha': '[A-Z]',
                         'lowerroman': '[ivxlcdm]+',
                         'upperroman': '[IVXLCDM]+',}
    enum.converters = {'arabic': int,
                       'loweralpha':
                       lambda s, zero=(ord('a')-1): ord(s) - zero,
                       'upperalpha':
                       lambda s, zero=(ord('A')-1): ord(s) - zero,
                       'lowerroman':
                       lambda s: roman.fromRoman(s.upper()),
                       'upperroman': roman.fromRoman}

    enum.sequenceregexps = {}
    for sequence in enum.sequences:
        enum.sequenceregexps[sequence] = re.compile(enum.sequencepats[sequence]
                                                + '$')

    tabletoppat = re.compile(r'\+-[-+]+-\+ *$')
    """Matches the top (& bottom) of a table)."""

    tableparser = TableParser()

    pats = {}
    """Fragments of patterns used by transitions."""

    pats['nonalphanum7bit'] = '[!-/:-@@[-`{-~]'
    pats['alpha'] = '[a-zA-Z]'
    pats['alphanum'] = '[a-zA-Z0-9]'
    pats['alphanumplus'] = '[a-zA-Z0-9_-]'
    pats['enum'] = ('(%(arabic)s|%(loweralpha)s|%(upperalpha)s|%(lowerroman)s'
                    '|%(upperroman)s)' % enum.sequencepats)
    pats['optname'] = '%(alphanum)s%(alphanumplus)s*' % pats
    pats['optarg'] = '%(alpha)s%(alphanumplus)s*' % pats
    pats['option'] = r'(--?|\+|/)%(optname)s([ =]%(optarg)s)?' % pats

    for format in enum.formats:
        pats[format] = '(?P<%s>%s%s%s)' % (
              format, re.escape(enum.formatinfo[format].prefix),
              pats['enum'], re.escape(enum.formatinfo[format].suffix))

    patterns = {'bullet': r'[-+*]( +|$)',
                'enumerator': r'(%(parens)s|%(rparen)s|%(period)s)( +|$)'
                % pats,
                'field_marker': r':[^: ]([^:]*[^: ])?:( +|$)',
                'option_marker': r'%(option)s(, %(option)s)*(  +| ?$)' % pats,
                'doctest': r'>>>( +|$)',
                'tabletop': tabletoppat,
                'explicit_markup': r'\.\.( +|$)',
                'anonymous': r'__( +|$)',
                'line': r'(%(nonalphanum7bit)s)\1\1\1+ *$' % pats,
                #'rfc822': r'[!-9;-~]+:( +|$)',
                'text': r''}
    initialtransitions = ['bullet',
                          'enumerator',
                          'field_marker',
                          'option_marker',
                          'doctest',
                          'tabletop',
                          'explicit_markup',
                          'anonymous',
                          'line',
                          'text']

    def indent(self, match, context, nextstate):
        """Block quote."""
        indented, indent, lineoffset, blankfinish = \
              self.statemachine.getindented()
        blockquote = self.block_quote(indented, lineoffset)
        self.statemachine.node += blockquote
        if not blankfinish:
            self.statemachine.node += self.unindentwarning()
        return context, nextstate, []

    def block_quote(self, indented, lineoffset):
        blockquote = nodes.block_quote()
        self.nestedparse(indented, lineoffset, blockquote)
        return blockquote

    def bullet(self, match, context, nextstate):
        """Bullet list item."""
        bulletlist = nodes.bullet_list()
        self.statemachine.node += bulletlist
        bulletlist['bullet'] = match.string[0]
        i, blankfinish = self.list_item(match.end())
        bulletlist += i
        offset = self.statemachine.lineoffset + 1   # next line
        newlineoffset, blankfinish = self.nestedlistparse(
              self.statemachine.inputlines[offset:],
              inputoffset=self.statemachine.abslineoffset() + 1,
              node=bulletlist, initialstate='BulletList',
              blankfinish=blankfinish)
        if not blankfinish:
            self.statemachine.node += self.unindentwarning()
        self.gotoline(newlineoffset)
        return [], nextstate, []

    def list_item(self, indent):
        indented, lineoffset, blankfinish = \
              self.statemachine.getknownindented(indent)
        listitem = nodes.list_item('\n'.join(indented))
        if indented:
            self.nestedparse(indented, inputoffset=lineoffset, node=listitem)
        return listitem, blankfinish

    def enumerator(self, match, context, nextstate):
        """Enumerated List Item"""
        format, sequence, text, ordinal = self.parse_enumerator(match)
        if ordinal is None:
            msg = self.statemachine.memo.reporter.error(
                  ('Enumerated list start value invalid at line %s: '
                   '%r (sequence %r)' % (self.statemachine.abslineno(),
                                         text, sequence)))
            self.statemachine.node += msg
            indented, lineoffset, blankfinish = \
                  self.statemachine.getknownindented(match.end())
            bq = self.block_quote(indented, lineoffset)
            self.statemachine.node += bq
            if not blankfinish:
                self.statemachine.node += self.unindentwarning()
            return [], nextstate, []
        if ordinal != 1:
            msg = self.statemachine.memo.reporter.info(
                  ('Enumerated list start value not ordinal-1 at line %s: '
                      '%r (ordinal %s)' % (self.statemachine.abslineno(),
                                           text, ordinal)))
            self.statemachine.node += msg
        enumlist = nodes.enumerated_list()
        self.statemachine.node += enumlist
        enumlist['enumtype'] = sequence
        if ordinal != 1:
            enumlist['start'] = ordinal
        enumlist['prefix'] = self.enum.formatinfo[format].prefix
        enumlist['suffix'] = self.enum.formatinfo[format].suffix
        listitem, blankfinish = self.list_item(match.end())
        enumlist += listitem
        offset = self.statemachine.lineoffset + 1   # next line
        newlineoffset, blankfinish = self.nestedlistparse(
              self.statemachine.inputlines[offset:],
              inputoffset=self.statemachine.abslineoffset() + 1,
              node=enumlist, initialstate='EnumeratedList',
              blankfinish=blankfinish,
              extrasettings={'lastordinal': ordinal, 'format': format})
        if not blankfinish:
            self.statemachine.node += self.unindentwarning()
        self.gotoline(newlineoffset)
        return [], nextstate, []

    def parse_enumerator(self, match, expectedsequence=None):
        """
        Analyze an enumerator and return the results.

        :Return:
            - the enumerator format ('period', 'parens', or 'rparen'),
            - the sequence used ('arabic', 'loweralpha', 'upperroman', etc.),
            - the text of the enumerator, stripped of formatting, and
            - the ordinal value of the enumerator ('a' -> 1, 'ii' -> 2, etc.;
              ``None`` is returned for invalid enumerator text).

        The enumerator format has already been determined by the regular
        expression match. If `expectedsequence` is given, that sequence is
        tried first. If not, we check for Roman numeral 1. This way,
        single-character Roman numerals (which are also alphabetical) can be
        matched. If no sequence has been matched, all sequences are checked in
        order.
        """
        groupdict = match.groupdict()
        sequence = ''
        for format in self.enum.formats:
            if groupdict[format]:       # was this the format matched?
                break                   # yes; keep `format`
        else:                           # shouldn't happen
            raise ParserError, 'enumerator format not matched'
        text = groupdict[format][self.enum.formatinfo[format].start
                                 :self.enum.formatinfo[format].end]
        if expectedsequence:
            try:
                if self.enum.sequenceregexps[expectedsequence].match(text):
                    sequence = expectedsequence
            except KeyError:            # shouldn't happen
                raise ParserError, 'unknown sequence: %s' % sequence
        else:
            if text == 'i':
                sequence = 'lowerroman'
            elif text == 'I':
                sequence = 'upperroman'
        if not sequence:
            for sequence in self.enum.sequences:
                if self.enum.sequenceregexps[sequence].match(text):
                    break
            else:                       # shouldn't happen
                raise ParserError, 'enumerator sequence not matched'
        try:
            ordinal = self.enum.converters[sequence](text)
        except roman.InvalidRomanNumeralError:
            ordinal = None
        return format, sequence, text, ordinal

    def field_marker(self, match, context, nextstate):
        """Field list item."""
        fieldlist = nodes.field_list()
        self.statemachine.node += fieldlist
        field, blankfinish = self.field(match)
        fieldlist += field
        offset = self.statemachine.lineoffset + 1   # next line
        newlineoffset, blankfinish = self.nestedlistparse(
              self.statemachine.inputlines[offset:],
              inputoffset=self.statemachine.abslineoffset() + 1,
              node=fieldlist, initialstate='FieldList',
              blankfinish=blankfinish)
        if not blankfinish:
            self.statemachine.node += self.unindentwarning()
        self.gotoline(newlineoffset)
        return [], nextstate, []

    def field(self, match):
        name, args = self.parse_field_marker(match)
        indented, indent, lineoffset, blankfinish = \
              self.statemachine.getfirstknownindented(match.end())
        fieldnode = nodes.field()
        fieldnode += nodes.field_name(name, name)
        for arg in args:
            fieldnode += nodes.field_argument(arg, arg)
        fieldbody = nodes.field_body('\n'.join(indented))
        fieldnode += fieldbody
        if indented:
            self.nestedparse(indented, inputoffset=lineoffset, node=fieldbody)
        return fieldnode, blankfinish

    def parse_field_marker(self, match):
        """Extract & return name & argument list from a field marker match."""
        field = match.string[1:]        # strip off leading ':'
        field = field[:field.find(':')] # strip off trailing ':' etc.
        tokens = field.split()
        return tokens[0], tokens[1:]    # first == name, others == args

    def option_marker(self, match, context, nextstate):
        """Option list item."""
        optionlist = nodes.option_list()
        try:
            listitem, blankfinish = self.option_list_item(match)
        except MarkupError, detail:     # shouldn't happen; won't match pattern
            msg = self.statemachine.memo.reporter.error(
                  ('Invalid option list marker at line %s: %s'
                      % (self.statemachine.abslineno(), detail)))
            self.statemachine.node += msg
            indented, indent, lineoffset, blankfinish = \
                  self.statemachine.getfirstknownindented(match.end())
            blockquote = self.block_quote(indented, lineoffset)
            self.statemachine.node += blockquote
            if not blankfinish:
                self.statemachine.node += self.unindentwarning()
            return [], nextstate, []
        self.statemachine.node += optionlist
        optionlist += listitem
        offset = self.statemachine.lineoffset + 1   # next line
        newlineoffset, blankfinish = self.nestedlistparse(
              self.statemachine.inputlines[offset:],
              inputoffset=self.statemachine.abslineoffset() + 1,
              node=optionlist, initialstate='OptionList',
              blankfinish=blankfinish)
        if not blankfinish:
            self.statemachine.node += self.unindentwarning()
        self.gotoline(newlineoffset)
        return [], nextstate, []

    def option_list_item(self, match):
        options = self.parse_option_marker(match)
        indented, indent, lineoffset, blankfinish = \
              self.statemachine.getfirstknownindented(match.end())
        if not indented:                # not an option list item
            raise statemachine.TransitionCorrection('text')
        option_group = nodes.option_group('', *options)
        description = nodes.description('\n'.join(indented))
        option_list_item = nodes.option_list_item('', option_group, description)
        if indented:
            self.nestedparse(indented, inputoffset=lineoffset, node=description)
        return option_list_item, blankfinish

    def parse_option_marker(self, match):
        """
        Return a list of `node.option` and `node.option_argument` objects,
        parsed from an option marker match.

        :Exception: `MarkupError` for invalid option markers.
        """
        optlist = []
        optionstrings = match.group().rstrip().split(', ')
        for optionstring in optionstrings:
            tokens = optionstring.split()
            delimiter = ' '
            firstopt = tokens[0].split('=')
            if len(firstopt) > 1:
                tokens[:1] = firstopt
                delimiter = '='
            if 0 < len(tokens) <= 2:
                option = nodes.option(optionstring)
                option += nodes.option_string(tokens[0], tokens[0])
                if len(tokens) > 1:
                    option += nodes.option_argument(tokens[1], tokens[1],
                                                    delimiter=delimiter)
                optlist.append(option)
            else:
                raise MarkupError('wrong numer of option tokens (=%s), '
                                  'should be 1 or 2: %r' % (len(tokens),
                                                            optionstring))
        return optlist

    def doctest(self, match, context, nextstate):
        data = '\n'.join(self.statemachine.gettextblock())
        self.statemachine.node += nodes.doctest_block(data, data)
        return [], nextstate, []

    def tabletop(self, match, context, nextstate):
        """Top border of a table."""
        nodelist, blankfinish = self.table()
        self.statemachine.node += nodelist
        if not blankfinish:
            msg = self.statemachine.memo.reporter.warning(
                  'Blank line required after table at line %s.'
                  % (self.statemachine.abslineno() + 1))
            self.statemachine.node += msg
        return [], nextstate, []

    def table(self):
        """Parse a table."""
        block, messages, blankfinish = self.isolatetable()
        if block:
            try:
                tabledata = self.tableparser.parse(block)
                tableline = self.statemachine.abslineno() - len(block) + 1
                table = self.buildtable(tabledata, tableline)
                nodelist = [table] + messages
            except TableMarkupError, detail:
                nodelist = self.malformedtable(block, str(detail)) + messages
        else:
            nodelist = messages
        return nodelist, blankfinish

    def isolatetable(self):
        messages = []
        blankfinish = 1
        try:
            block = self.statemachine.getunindented()
        except statemachine.UnexpectedIndentationError, instance:
            block, lineno = instance.args
            messages.append(self.statemachine.memo.reporter.error(
                  'Unexpected indentation at line %s.' % lineno))
            blankfinish = 0
        width = len(block[0].strip())
        for i in range(len(block)):
            block[i] = block[i].strip()
            if block[i][0] not in '+|': # check left edge
                blankfinish = 0
                self.statemachine.previousline(len(block) - i)
                del block[i:]
                break
        if not self.tabletoppat.match(block[-1]): # find bottom
            blankfinish = 0
            # from second-last to third line of table:
            for i in range(len(block) - 2, 1, -1):
                if self.tabletoppat.match(block[i]):
                    self.statemachine.previousline(len(block) - i + 1)
                    del block[i+1:]
                    break
            else:
                messages.extend(self.malformedtable(block))
                return [], messages, blankfinish
        for i in range(len(block)):     # check right edge
            if len(block[i]) != width or block[i][-1] not in '+|':
                messages.extend(self.malformedtable(block))
                return [], messages, blankfinish
        return block, messages, blankfinish

    def malformedtable(self, block, detail=''):
        data = '\n'.join(block)
        message = 'Malformed table at line %s; formatting as a ' \
                  'literal block.' % (self.statemachine.abslineno()
                                      - len(block) + 1)
        if detail:
            message += '\n' + detail
        nodelist = [self.statemachine.memo.reporter.error(message),
                    nodes.literal_block(data, data)]
        return nodelist

    def buildtable(self, tabledata, tableline):
        colspecs, headrows, bodyrows = tabledata
        table = nodes.table()
        tgroup = nodes.tgroup(cols=len(colspecs))
        table += tgroup
        for colspec in colspecs:
            tgroup += nodes.colspec(colwidth=colspec)
        if headrows:
            thead = nodes.thead()
            tgroup += thead
            for row in headrows:
                thead += self.buildtablerow(row, tableline)
        tbody = nodes.tbody()
        tgroup += tbody
        for row in bodyrows:
            tbody += self.buildtablerow(row, tableline)
        return table

    def buildtablerow(self, rowdata, tableline):
        row = nodes.row()
        for cell in rowdata:
            if cell is None:
                continue
            morerows, morecols, offset, cellblock = cell
            attributes = {}
            if morerows:
                attributes['morerows'] = morerows
            if morecols:
                attributes['morecols'] = morecols
            entry = nodes.entry(**attributes)
            row += entry
            if ''.join(cellblock):
                self.nestedparse(cellblock, inputoffset=tableline+offset,
                                 node=entry)
        return row


    explicit = Stuff()
    """Patterns and constants used for explicit markup recognition."""

    explicit.patterns = Stuff(
          target=re.compile(r"""
                            (?:
                              _           # anonymous target
                            |           # *OR*
                              (`?)        # optional open quote
                              (?![ `])    # first char. not space or backquote
                              (           # reference name
                                .+?
                              )
                              %s          # not whitespace or escape
                              \1          # close quote if open quote used
                            )
                            %s          # not whitespace or escape
                            :           # end of reference name
                            (?:[ ]+|$)  # followed by whitespace
                            """
                            % (RSTState.inline.non_whitespace_escape_before,
                               RSTState.inline.non_whitespace_escape_before),
                            re.VERBOSE),
          reference=re.compile(r"""
                               (?:
                                 (%s)_       # simple reference name
                               |           # *OR*
                                 `           # open backquote
                                 (?![ ])     # not space
                                 (.+?)       # hyperlink phrase
                                 %s          # not whitespace or escape
                                 `_          # close backquote & reference mark
                               )
                               $           # end of string
                               """ %
                               (RSTState.inline.simplename,
                                RSTState.inline.non_whitespace_escape_before,),
                               re.VERBOSE),
          substitution=re.compile(r"""
                                  (?:
                                    (?![ ])     # first char. not space
                                    (.+?)       # substitution text
                                    %s          # not whitespace or escape
                                    \|          # close delimiter
                                  )
                                  (?:[ ]+|$)    # followed by whitespace
                                  """ %
                                  RSTState.inline.non_whitespace_escape_before,
                                  re.VERBOSE),)
    explicit.groups = Stuff(
          target=Stuff(quote=1, name=2),
          reference=Stuff(simple=1, phrase=2),
          substitution=Stuff(name=1))

    def footnote(self, match):
        indented, indent, offset, blankfinish = \
              self.statemachine.getfirstknownindented(match.end())
        label = match.group(1)
        name = normname(label)
        footnote = nodes.footnote('\n'.join(indented))
        if name[0] == '#':              # auto-numbered
            name = name[1:]             # autonumber label
            footnote['auto'] = 1
            if name:
                footnote['name'] = name
            self.statemachine.memo.document.note_autofootnote(footnote)
        elif name == '*':               # auto-symbol
            name = ''
            footnote['auto'] = '*'
            self.statemachine.memo.document.note_symbol_footnote(footnote)
        else:                           # manually numbered
            footnote += nodes.label('', label)
            footnote['name'] = name
            self.statemachine.memo.document.note_footnote(footnote)
        if name:
            self.statemachine.memo.document.note_explicit_target(footnote,
                                                                 footnote)
        if indented:
            self.nestedparse(indented, inputoffset=offset, node=footnote)
        return [footnote], blankfinish

    def citation(self, match):
        indented, indent, offset, blankfinish = \
              self.statemachine.getfirstknownindented(match.end())
        label = match.group(1)
        name = normname(label)
        citation = nodes.citation('\n'.join(indented))
        citation += nodes.label('', label)
        citation['name'] = name
        self.statemachine.memo.document.note_citation(citation)
        self.statemachine.memo.document.note_explicit_target(citation, citation)
        if indented:
            self.nestedparse(indented, inputoffset=offset, node=citation)
        return [citation], blankfinish

    def hyperlink_target(self, match):
        pattern = self.explicit.patterns.target
        namegroup = self.explicit.groups.target.name
        lineno = self.statemachine.abslineno()
        block, indent, offset, blankfinish = \
              self.statemachine.getfirstknownindented(match.end(), uptoblank=1,
                                                      stripindent=0)
        blocktext = match.string[:match.end()] + '\n'.join(block)
        block = [escape2null(line) for line in block]
        escaped = block[0]
        blockindex = 0
        while 1:
            targetmatch = pattern.match(escaped)
            if targetmatch:
                break
            blockindex += 1
            try:
                escaped += block[blockindex]
            except (IndexError, MarkupError):
                raise MarkupError('malformed hyperlink target at line %s.'
                                  % lineno)
        del block[:blockindex]
        block[0] = (block[0] + ' ')[targetmatch.end()-len(escaped)-1:].strip()
        if block and block[-1].strip()[-1:] == '_': # possible indirect target
            reference = ' '.join([line.strip() for line in block])
            refname = self.isreference(reference)
            if refname:
                target = nodes.target(blocktext, '', refname=refname)
                self.addtarget(targetmatch.group(namegroup), '', target)
                self.statemachine.memo.document.note_indirect_target(target)
                return [target], blankfinish
        nodelist = []
        reference = ''.join([line.strip() for line in block])
        if reference.find(' ') != -1:
            warning = self.statemachine.memo.reporter.warning(
                  'Hyperlink target at line %s contains whitespace. '
                  'Perhaps a footnote was intended?'
                  % (self.statemachine.abslineno() - len(block) + 1), '',
                  nodes.literal_block(blocktext, blocktext))
            nodelist.append(warning)
        else:
            unescaped = unescape(reference)
            target = nodes.target(blocktext, '')
            self.addtarget(targetmatch.group(namegroup), unescaped, target)
            nodelist.append(target)
        return nodelist, blankfinish

    def isreference(self, reference):
        match = self.explicit.patterns.reference.match(normname(reference))
        if not match:
            return None
        return unescape(match.group(self.explicit.groups.reference.simple)
                        or match.group(self.explicit.groups.reference.phrase))

    def addtarget(self, targetname, refuri, target):
        if targetname:
            name = normname(unescape(targetname))
            target['name'] = name
            if refuri:
                target['refuri'] = refuri
                self.statemachine.memo.document.note_external_target(target)
            else:
                self.statemachine.memo.document.note_internal_target(target)
            self.statemachine.memo.document.note_explicit_target(
                  target, self.statemachine.node)
        else:                       # anonymous target
            if refuri:
                target['refuri'] = refuri
            target['anonymous'] = 1
            self.statemachine.memo.document.note_anonymous_target(target)

    def substitutiondef(self, match):
        pattern = self.explicit.patterns.substitution
        lineno = self.statemachine.abslineno()
        block, indent, offset, blankfinish = \
              self.statemachine.getfirstknownindented(match.end(),
                                                      stripindent=0)
        blocktext = (match.string[:match.end()] + '\n'.join(block))
        block = [escape2null(line) for line in block]
        escaped = block[0].rstrip()
        blockindex = 0
        while 1:
            subdefmatch = pattern.match(escaped)
            if subdefmatch:
                break
            blockindex += 1
            try:
                escaped = escaped + ' ' + block[blockindex].strip()
            except (IndexError, MarkupError):
                raise MarkupError('malformed substitution definition '
                                  'at line %s.' % lineno)
        del block[:blockindex]          # strip out the substitution marker
        block[0] = (block[0] + ' ')[subdefmatch.end()-len(escaped)-1:].strip()
        if not block[0]:
            del block[0]
            offset += 1
        subname = subdefmatch.group(self.explicit.groups.substitution.name)
        name = normname(subname)
        substitutionnode = nodes.substitution_definition(
              blocktext, name=name, alt=subname)
        if block:
            block[0] = block[0].strip()
            newabsoffset, blankfinish = self.nestedlistparse(
                  block, inputoffset=offset, node=substitutionnode,
                  initialstate='SubstitutionDef', blankfinish=blankfinish)
            self.statemachine.previousline(
                  len(block) + offset - newabsoffset - 1)
            i = 0
            for node in substitutionnode[:]:
                if not (isinstance(node, nodes.Inline) or
                        isinstance(node, nodes.Text)):
                    self.statemachine.node += substitutionnode[i]
                    del substitutionnode[i]
                else:
                    i += 1
            if len(substitutionnode) == 0:
                msg = self.statemachine.memo.reporter.warning(
                      'Substitution definition "%s" empty or invalid at line '
                      '%s.' % (subname, self.statemachine.abslineno()), '',
                      nodes.literal_block(blocktext, blocktext))
                self.statemachine.node += msg
            else:
                del substitutionnode['alt']
                self.statemachine.memo.document.note_substitution_def(
                      substitutionnode, self.statemachine.node)
                return [substitutionnode], blankfinish
        else:
            msg = self.statemachine.memo.reporter.warning(
                  'Substitution definition "%s" missing contents at line %s.'
                  % (subname, self.statemachine.abslineno()), '',
                  nodes.literal_block(blocktext, blocktext))
            self.statemachine.node += msg
        return [], blankfinish

    def directive(self, match, **attributes):
        typename = match.group(1)
        directivefunction = directives.directive(
              typename, self.statemachine.memo.language)
        data = match.string[match.end():].strip()
        if directivefunction:
            return directivefunction(match, typename, data, self,
                                     self.statemachine, attributes)
        else:
            return self.unknowndirective(typename, data)

    def unknowndirective(self, typename, data):
        lineno = self.statemachine.abslineno()
        indented, indent, offset, blankfinish = \
              self.statemachine.getfirstknownindented(0, stripindent=0)
        text = '\n'.join(indented)
        error = self.statemachine.memo.reporter.error(
              'Unknown directive type "%s" at line %s.' % (typename, lineno),
              '', nodes.literal_block(text, text))
        return [error], blankfinish

    def parse_extension_attributes(self, attribute_spec, datalines, blankfinish):
        """
        Parse `datalines` for a field list containing extension attributes
        matching `attribute_spec`.

        :Parameters:
            - `attribute_spec`: a mapping of attribute name to conversion
              function, which should raise an exception on bad input.
            - `datalines`: a list of input strings.
            - `blankfinish`:

        :Return:
            - Success value, 1 or 0.
            - An attribute dictionary on success, an error string on failure.
            - Updated `blankfinish` flag.
        """
        node = nodes.field_list()
        newlineoffset, blankfinish = self.nestedlistparse(
              datalines, 0, node, initialstate='FieldList',
              blankfinish=blankfinish)
        if newlineoffset != len(datalines): # incomplete parse of block
            return 0, 'invalid attribute block', blankfinish
        try:
            attributes = utils.extract_extension_attributes(node, attribute_spec)
        except KeyError, detail:
            return 0, ('unknown attribute: "%s"' % detail), blankfinish
        except (ValueError, TypeError), detail:
            return 0, ('invalid attribute value:\n%s' % detail), blankfinish
        except utils.ExtensionAttributeError, detail:
            return 0, ('invalid attribute data: %s' % detail), blankfinish
        return 1, attributes, blankfinish

    def comment(self, match):
        if not match.string[match.end():].strip() \
              and self.statemachine.nextlineblank(): # an empty comment?
            return [nodes.comment()], 1 # "A tiny but practical wart."
        indented, indent, offset, blankfinish = \
              self.statemachine.getfirstknownindented(match.end())
        text = '\n'.join(indented)
        return [nodes.comment(text, text)], blankfinish

    explicit.constructs = [
          (footnote,
           re.compile(r"""
                      \.\.[ ]+          # explicit markup start
                      \[
                      (                 # footnote label:
                          [0-9]+          # manually numbered footnote
                        |               # *OR*
                          \#              # anonymous auto-numbered footnote
                        |               # *OR*
                          \#%s            # auto-number ed?) footnote label
                        |               # *OR*
                          \*              # auto-symbol footnote
                      )
                      \]
                      (?:[ ]+|$)        # whitespace or end of line
                      """ % RSTState.inline.simplename, re.VERBOSE)),
          (citation,
           re.compile(r"""
                      \.\.[ ]+          # explicit markup start
                      \[(%s)\]          # citation label
                      (?:[ ]+|$)        # whitespace or end of line
                      """ % RSTState.inline.simplename, re.VERBOSE)),
          (hyperlink_target,
           re.compile(r"""
                      \.\.[ ]+          # explicit markup start
                      _                 # target indicator
                      (?![ ])           # first char. not space
                      """, re.VERBOSE)),
          (substitutiondef,
           re.compile(r"""
                      \.\.[ ]+          # explicit markup start
                      \|                # substitution indicator
                      (?![ ])           # first char. not space
                      """, re.VERBOSE)),
          (directive,
           re.compile(r"""
                      \.\.[ ]+          # explicit markup start
                      (%s)              # directive name
                      ::                # directive delimiter
                      (?:[ ]+|$)        # whitespace or end of line
                      """ % RSTState.inline.simplename, re.VERBOSE))]

    def explicit_markup(self, match, context, nextstate):
        """Footnotes, hyperlink targets, directives, comments."""
        nodelist, blankfinish = self.explicit_construct(match)
        self.statemachine.node += nodelist
        self.explicitlist(blankfinish)
        return [], nextstate, []

    def explicit_construct(self, match):
        """Determine which explicit construct this is, parse & return it."""
        errors = []
        for method, pattern in self.explicit.constructs:
            expmatch = pattern.match(match.string)
            if expmatch:
                try:
                    return method(self, expmatch)
                except MarkupError, detail: # never reached?
                    errors.append(
                          self.statemachine.memo.reporter.warning('%s: %s'
                          % (detail.__class__.__name__, detail)))
                    break
        nodelist, blankfinish = self.comment(match)
        return nodelist + errors, blankfinish

    def explicitlist(self, blankfinish):
        """
        Create a nested state machine for a series of explicit markup constructs
        (including anonymous hyperlink targets).
        """
        offset = self.statemachine.lineoffset + 1   # next line
        newlineoffset, blankfinish = self.nestedlistparse(
              self.statemachine.inputlines[offset:],
              inputoffset=self.statemachine.abslineoffset() + 1,
              node=self.statemachine.node, initialstate='Explicit',
              blankfinish=blankfinish)
        self.gotoline(newlineoffset)
        if not blankfinish:
            self.statemachine.node += self.unindentwarning()

    def anonymous(self, match, context, nextstate):
        """Anonymous hyperlink targets."""
        nodelist, blankfinish = self.anonymous_target(match)
        self.statemachine.node += nodelist
        self.explicitlist(blankfinish)
        return [], nextstate, []

    def anonymous_target(self, match):
        block, indent, offset, blankfinish \
              = self.statemachine.getfirstknownindented(match.end(),
                                                        uptoblank=1)
        blocktext = match.string[:match.end()] + '\n'.join(block)
        if block and block[-1].strip()[-1:] == '_': # possible indirect target
            reference = escape2null(' '.join([line.strip() for line in block]))
            refname = self.isreference(reference)
            if refname:
                target = nodes.target(blocktext, '', refname=refname,
                                      anonymous=1)
                self.statemachine.memo.document.note_anonymous_target(target)
                self.statemachine.memo.document.note_indirect_target(target)
                return [target], blankfinish
        nodelist = []
        reference = escape2null(''.join([line.strip() for line in block]))
        if reference.find(' ') != -1:
            warning = self.statemachine.memo.reporter.warning(
                  'Anonymous hyperlink target at line %s contains whitespace. '
                  'Perhaps a footnote was intended?'
                  % (self.statemachine.abslineno() - len(block) + 1), '',
                  nodes.literal_block(blocktext, blocktext))
            nodelist.append(warning)
        else:
            target = nodes.target(blocktext, '', anonymous=1)
            if reference:
                unescaped = unescape(reference)
                target['refuri'] = unescaped
            self.statemachine.memo.document.note_anonymous_target(target)
            nodelist.append(target)
        return nodelist, blankfinish

    def line(self, match, context, nextstate):
        """Section title overline or transition marker."""
        if self.statemachine.matchtitles:
            return [match.string], 'Line', []
        else:
            blocktext = self.statemachine.line
            msg = self.statemachine.memo.reporter.severe(
                  'Unexpected section title or transition at line %s.'
                  % self.statemachine.abslineno(), '',
                  nodes.literal_block(blocktext, blocktext))
            self.statemachine.node += msg
            return [], nextstate, []

    def text(self, match, context, nextstate):
        """Titles, definition lists, paragraphs."""
        return [match.string], 'Text', []


class SpecializedBody(Body):

    """
    Superclass for second and subsequent compound element members.

    All transition methods are disabled. Override individual methods in
    subclasses to re-enable.
    """

    def invalid_input(self, match=None, context=None, nextstate=None):
        """Not a compound element member. Abort this state machine."""
        self.statemachine.previousline()  # back up so parent SM can reassess
        raise EOFError

    indent = invalid_input
    bullet = invalid_input
    enumerator = invalid_input
    field_marker = invalid_input
    option_marker = invalid_input
    doctest = invalid_input
    tabletop = invalid_input
    explicit_markup = invalid_input
    anonymous = invalid_input
    line = invalid_input
    text = invalid_input


class BulletList(SpecializedBody):

    """Second and subsequent bullet_list list_items."""

    def bullet(self, match, context, nextstate):
        """Bullet list item."""
        if match.string[0] != self.statemachine.node['bullet']:
            # different bullet: new list
            self.invalid_input()
        listitem, blankfinish = self.list_item(match.end())
        self.statemachine.node += listitem
        self.blankfinish = blankfinish
        return [], 'BulletList', []


class DefinitionList(SpecializedBody):

    """Second and subsequent definition_list_items."""

    def text(self, match, context, nextstate):
        """Definition lists."""
        return [match.string], 'Definition', []


class EnumeratedList(SpecializedBody):

    """Second and subsequent enumerated_list list_items."""

    def enumerator(self, match, context, nextstate):
        """Enumerated list item."""
        format, sequence, text, ordinal = self.parse_enumerator(
              match, self.statemachine.node['enumtype'])
        if (sequence != self.statemachine.node['enumtype'] or
            format != self.format or
            ordinal != self.lastordinal + 1):
            # different enumeration: new list
            self.invalid_input()
        listitem, blankfinish = self.list_item(match.end())
        self.statemachine.node += listitem
        self.blankfinish = blankfinish
        self.lastordinal = ordinal
        return [], 'EnumeratedList', []


class FieldList(SpecializedBody):

    """Second and subsequent field_list fields."""

    def field_marker(self, match, context, nextstate):
        """Field list field."""
        field, blankfinish = self.field(match)
        self.statemachine.node += field
        self.blankfinish = blankfinish
        return [], 'FieldList', []


class OptionList(SpecializedBody):

    """Second and subsequent option_list option_list_items."""

    def option_marker(self, match, context, nextstate):
        """Option list item."""
        try:
            option_list_item, blankfinish = self.option_list_item(match)
        except MarkupError, detail:
            self.invalid_input()
        self.statemachine.node += option_list_item
        self.blankfinish = blankfinish
        return [], 'OptionList', []


class RFC822List(SpecializedBody):

    """Second and subsequent RFC822 field_list fields."""

    pass


class Explicit(SpecializedBody):

    """Second and subsequent explicit markup construct."""

    def explicit_markup(self, match, context, nextstate):
        """Footnotes, hyperlink targets, directives, comments."""
        nodelist, blankfinish = self.explicit_construct(match)
        self.statemachine.node += nodelist
        self.blankfinish = blankfinish
        return [], nextstate, []

    def anonymous(self, match, context, nextstate):
        """Anonymous hyperlink targets."""
        nodelist, blankfinish = self.anonymous_target(match)
        self.statemachine.node += nodelist
        self.blankfinish = blankfinish
        return [], nextstate, []


class SubstitutionDef(Body):

    """
    Parser for the contents of a substitution_definition element.
    """

    patterns = {
          'embedded_directive': r'(%s)::( +|$)' % RSTState.inline.simplename,
          'text': r''}
    initialtransitions = ['embedded_directive', 'text']

    def embedded_directive(self, match, context, nextstate):
        if self.statemachine.node.has_key('alt'):
            attributes = {'alt': self.statemachine.node['alt']}
        else:
            attributes = {}
        nodelist, blankfinish = self.directive(match, **attributes)
        self.statemachine.node += nodelist
        if not self.statemachine.ateof():
            self.blankfinish = blankfinish
        raise EOFError

    def text(self, match, context, nextstate):
        if not self.statemachine.ateof():
            self.blankfinish = self.statemachine.nextlineblank()
        raise EOFError


class Text(RSTState):

    """
    Classifier of second line of a text block.

    Could be a paragraph, a definition list item, or a title.
    """

    patterns = {'underline': Body.patterns['line'],
                'text': r''}
    initialtransitions = [('underline', 'Body'), ('text', 'Body')]

    def blank(self, match, context, nextstate):
        """End of paragraph."""
        paragraph, literalnext = self.paragraph(
              context, self.statemachine.abslineno() - 1)
        self.statemachine.node += paragraph
        if literalnext:
            self.statemachine.node += self.literal_block()
        return [], 'Body', []

    def eof(self, context):
        if context:
            paragraph, literalnext = self.paragraph(
                  context, self.statemachine.abslineno() - 1)
            self.statemachine.node += paragraph
            if literalnext:
                self.statemachine.node += self.literal_block()
        return []

    def indent(self, match, context, nextstate):
        """Definition list item."""
        definitionlist = nodes.definition_list()
        definitionlistitem, blankfinish = self.definition_list_item(context)
        definitionlist += definitionlistitem
        self.statemachine.node += definitionlist
        offset = self.statemachine.lineoffset + 1   # next line
        newlineoffset, blankfinish = self.nestedlistparse(
              self.statemachine.inputlines[offset:],
              inputoffset=self.statemachine.abslineoffset() + 1,
              node=definitionlist, initialstate='DefinitionList',
              blankfinish=blankfinish, blankfinishstate='Definition')
        if not blankfinish:
            self.statemachine.node += self.unindentwarning()
        self.gotoline(newlineoffset)
        return [], 'Body', []

    def underline(self, match, context, nextstate):
        """Section title."""
        lineno = self.statemachine.abslineno()
        if not self.statemachine.matchtitles:
            blocktext = context[0] + '\n' + self.statemachine.line
            msg = self.statemachine.memo.reporter.severe(
                  'Unexpected section title at line %s.' % lineno, '',
                  nodes.literal_block(blocktext, blocktext))
            self.statemachine.node += msg
            return [], nextstate, []
        title = context[0].rstrip()
        underline = match.string.rstrip()
        source = title + '\n' + underline
        if len(title) > len(underline):
            blocktext = context[0] + '\n' + self.statemachine.line
            msg = self.statemachine.memo.reporter.info(
                  'Title underline too short at line %s.' % lineno, '',
                  nodes.literal_block(blocktext, blocktext))
            self.statemachine.node += msg
        style = underline[0]
        context[:] = []
        self.section(title, source, style, lineno - 1)
        return [], nextstate, []

    def text(self, match, context, nextstate):
        """Paragraph."""
        startline = self.statemachine.abslineno() - 1
        msg = None
        try:
            block = self.statemachine.getunindented()
        except statemachine.UnexpectedIndentationError, instance:
            block, lineno = instance.args
            msg = self.statemachine.memo.reporter.error(
                  'Unexpected indentation at line %s.' % lineno)
        lines = context + block
        paragraph, literalnext = self.paragraph(lines, startline)
        self.statemachine.node += paragraph
        self.statemachine.node += msg
        if literalnext:
            try:
                self.statemachine.nextline()
            except IndexError:
                pass
            self.statemachine.node += self.literal_block()
        return [], nextstate, []

    def literal_block(self):
        """Return a list of nodes."""
        indented, indent, offset, blankfinish = \
              self.statemachine.getindented()
        nodelist = []
        while indented and not indented[-1].strip():
            indented.pop()
        if indented:
            data = '\n'.join(indented)
            nodelist.append(nodes.literal_block(data, data))
            if not blankfinish:
                nodelist.append(self.unindentwarning())
        else:
            nodelist.append(self.statemachine.memo.reporter.warning(
                  'Literal block expected at line %s; none found.'
                  % self.statemachine.abslineno()))
        return nodelist

    def definition_list_item(self, termline):
        indented, indent, lineoffset, blankfinish = \
              self.statemachine.getindented()
        definitionlistitem = nodes.definition_list_item('\n'.join(termline
                                                                  + indented))
        termlist, messages = self.term(termline,
                                       self.statemachine.abslineno() - 1)
        definitionlistitem += termlist
        definition = nodes.definition('', *messages)
        definitionlistitem += definition
        if termline[0][-2:] == '::':
            definition += self.statemachine.memo.reporter.info(
                  'Blank line missing before literal block? Interpreted as a '
                  'definition list item. At line %s.' % (lineoffset + 1))
        self.nestedparse(indented, inputoffset=lineoffset, node=definition)
        return definitionlistitem, blankfinish

    def term(self, lines, lineno):
        """Return a definition_list's term and optional classifier."""
        assert len(lines) == 1
        nodelist = []
        parts = lines[0].split(' : ', 1)  # split into 1 or 2 parts
        termpart = parts[0].rstrip()
        textnodes, messages = self.inline_text(termpart, lineno)
        nodelist = [nodes.term(termpart, '', *textnodes)]
        if len(parts) == 2:
            classifierpart = parts[1].lstrip()
            textnodes, cpmessages = self.inline_text(classifierpart, lineno)
            nodelist.append(nodes.classifier(classifierpart, '', *textnodes))
            messages += cpmessages
        return nodelist, messages


class SpecializedText(Text):

    """
    Superclass for second and subsequent lines of Text-variants.

    All transition methods are disabled. Override individual methods in
    subclasses to re-enable.
    """

    def eof(self, context):
        """Incomplete construct."""
        return []

    def invalid_input(self, match=None, context=None, nextstate=None):
        """Not a compound element member. Abort this state machine."""
        raise EOFError

    blank = invalid_input
    indent = invalid_input
    underline = invalid_input
    text = invalid_input


class Definition(SpecializedText):

    """Second line of potential definition_list_item."""

    def eof(self, context):
        """Not a definition."""
        self.statemachine.previousline(2) # back up so parent SM can reassess
        return []

    def indent(self, match, context, nextstate):
        """Definition list item."""
        definitionlistitem, blankfinish = self.definition_list_item(context)
        self.statemachine.node += definitionlistitem
        self.blankfinish = blankfinish
        return [], 'DefinitionList', []


class Line(SpecializedText):

    """Second line of over- & underlined section title or transition marker."""

    eofcheck = 1                        # @@@@@@ ???
    """Set to 0 while parsing sections, so that we don't catch the EOF."""

    def eof(self, context):
        """Transition marker at end of section or document."""
        if self.eofcheck:               # ignore EOFError with sections
            transition = nodes.transition(context[0])
            self.statemachine.node += transition
            msg = self.statemachine.memo.reporter.error(
                  'Document or section may not end with a transition '
                  '(line %s).' % (self.statemachine.abslineno() - 1))
            self.statemachine.node += msg
        self.eofcheck = 1
        return []

    def blank(self, match, context, nextstate):
        """Transition marker."""
        transition = nodes.transition(context[0])
        if len(self.statemachine.node) == 0:
            msg = self.statemachine.memo.reporter.error(
                  'Document or section may not begin with a transition '
                  '(line %s).' % (self.statemachine.abslineno() - 1))
            self.statemachine.node += msg
        elif isinstance(self.statemachine.node[-1], nodes.transition):
            msg = self.statemachine.memo.reporter.error(
                  'At least one body element must separate transitions; '
                  'adjacent transitions at line %s.'
                  % (self.statemachine.abslineno() - 1))
            self.statemachine.node += msg
        self.statemachine.node += transition
        return [], 'Body', []

    def text(self, match, context, nextstate):
        """Potential over- & underlined title."""
        lineno = self.statemachine.abslineno() - 1
        overline = context[0]
        title = match.string
        underline = ''
        try:
            underline = self.statemachine.nextline()
        except IndexError:
            blocktext = overline + '\n' + title
            msg = self.statemachine.memo.reporter.severe(
                  'Incomplete section title at line %s.' % lineno, '',
                  nodes.literal_block(blocktext, blocktext))
            self.statemachine.node += msg
            return [], 'Body', []
        source = '%s\n%s\n%s' % (overline, title, underline)
        overline = overline.rstrip()
        underline = underline.rstrip()
        if not self.transitions['underline'][0].match(underline):
            msg = self.statemachine.memo.reporter.severe(
                  'Missing underline for overline at line %s.' % lineno, '',
                  nodes.literal_block(source, source))
            self.statemachine.node += msg
            return [], 'Body', []
        elif overline != underline:
            msg = self.statemachine.memo.reporter.severe(
                  'Title overline & underline mismatch at ' 'line %s.' % lineno,
                  '', nodes.literal_block(source, source))
            self.statemachine.node += msg
            return [], 'Body', []
        title = title.rstrip()
        if len(title) > len(overline):
            msg = self.statemachine.memo.reporter.info(
                  'Title overline too short at line %s.'% lineno, '',
                  nodes.literal_block(source, source))
            self.statemachine.node += msg
        style = (overline[0], underline[0])
        self.eofcheck = 0               # @@@@@@ not sure this is correct
        self.section(title.lstrip(), source, style, lineno + 1)
        self.eofcheck = 1
        return [], 'Body', []

    indent = text                       # indented title

    def underline(self, match=None, context=None, nextstate=None):
        blocktext = context[0] + '\n' + self.statemachine.line
        msg = self.statemachine.memo.reporter.error(
              'Invalid section title or transition marker at line %s.'
              % (self.statemachine.abslineno() - 1), '',
              nodes.literal_block(blocktext, blocktext))
        self.statemachine.node += msg
        return [], 'Body', []


stateclasses = [Body, BulletList, DefinitionList, EnumeratedList, FieldList,
                OptionList, RFC822List, Explicit, Text, Definition, Line,
                SubstitutionDef]
"""Standard set of State classes used to start `RSTStateMachine`."""


def escape2null(text):
    """Return a string with escape-backslashes converted to nulls."""
    parts = []
    start = 0
    while 1:
        found = text.find('\\', start)
        if found == -1:
            parts.append(text[start:])
            return ''.join(parts)
        parts.append(text[start:found])
        parts.append('\x00' + text[found+1:found+2])
        start = found + 2               # skip character after escape

def unescape(text, restorebackslashes=0):
    """Return a string with nulls removed or restored to backslashes."""
    if restorebackslashes:
        return text.translate(RSTState.inline.null2backslash)
    else:
        return text.translate(RSTState.inline.identity, '\x00')
@


1.50
log
@reworked reference bookkeeping
@
text
@d4 2
a5 2
:Revision: $Revision: 1.49 $
:Date: $Date: 2002/03/16 05:38:29 $
a110 4
__all__ = ['RSTStateMachine', 'MarkupError', 'ParserError',
           'TransformationError']


a112 1
class TransformationError(Exception): pass
a1052 1
        self.statemachine.node += optionlist
d1067 1
d1084 2
@


1.49
log
@  - Added Body.parse_extension_attributes().
@
text
@d4 2
a5 2
:Revision: $Revision: 1.48 $
:Date: $Date: 2002/03/12 03:27:17 $
d523 1
a523 1
        message['refid'] = prbid
a1297 20
        footnotenode = nodes.footnote('\n'.join(indented))
        if name[0] == '#':
            name = name[1:]
            footnotenode['auto'] = 1
            self.statemachine.memo.document.note_autofootnote(footnotenode)
        else:
            footnotenode += nodes.label('', label)
        if name:
            footnotenode['name'] = name
            self.statemachine.memo.document.note_explicit_target(
                  footnotenode, footnotenode)
        if indented:
            self.nestedparse(indented, inputoffset=offset, node=footnotenode)
        return [footnotenode], blankfinish

    def footnote(self, match):
        indented, indent, offset, blankfinish = \
              self.statemachine.getfirstknownindented(match.end())
        label = match.group(1)
        name = normname(label)
d1302 2
d1311 2
a1313 1
            footnote['name'] = name
d1328 1
d1363 1
a1363 2
                if target.has_key('name'):
                    self.statemachine.memo.document.note_indirect_target(target)
d1395 2
d1630 1
@


1.48
log
@  - Removed gratuitous pseudo-default arguments from functions &    methods.  - Added literal blocks to system messages whenever the erroneous    source text was omitted.  - Wrapped problematic inline markup in "problematic" elements, added    links to & from system messages.
@
text
@d4 2
a5 2
:Revision: $Revision: 1.47 $
:Date: $Date: 2002/03/11 03:20:41 $
d1503 32
@


1.47
log
@  - Updated for Reporter.
@
text
@d4 2
a5 2
:Revision: $Revision: 1.46 $
:Date: $Date: 2002/03/07 03:24:43 $
d508 1
a508 2
            inlineobj = nodeclass(rawsource, text)
            return (string[:matchstart], [inlineobj],
d510 1
a510 1
        sw = self.statemachine.memo.reporter.warning(
d513 12
a524 1
        return string[:matchend], [], string[matchend:], [sw], ''
d526 1
a526 1
    def emphasis(self, match, lineno, pattern=inline.patterns.emphasis):
d528 1
a528 1
              match, lineno, pattern, nodes.emphasis)
d531 1
a531 1
    def strong(self, match, lineno, pattern=inline.patterns.strong):
d533 1
a533 1
              match, lineno, pattern, nodes.strong)
d536 4
a539 5
    def interpreted_or_phrase_ref(
          self, match, lineno,
          pattern=inline.patterns.interpreted_or_phrase_ref,
          rolegroup=inline.groups.initial.role,
          backquote=inline.groups.initial.backquote):
d559 3
a561 3
                    sw = self.statemachine.memo.reporter.warning(
                          'Mismatch: inline interpreted text start-string '
                          'and role with phrase-reference end-string at line %s.'
d563 5
a567 1
                    return (string[:matchend], [], string[matchend:], [sw])
d576 1
a576 1
        sw = self.statemachine.memo.reporter.warning(
d579 4
a582 1
        return string[:matchend], [], string[matchend:], [sw]
d596 2
a597 2
                    escaped, rawsource, text,
                    suffix=inline.groups.interpreted_or_phrase_ref.suffix):
d600 1
a600 1
                sw = self.statemachine.memo.reporter.warning(
d603 1
a603 1
                return (before + rawsource, [], after, [sw])
d612 1
a612 1
    def literal(self, match, lineno, pattern=inline.patterns.literal):
d614 2
a615 1
              match, lineno, pattern, nodes.literal, restorebackslashes=1)
d618 1
a618 1
    def inline_target(self, match, lineno, pattern=inline.patterns.target):
d620 2
a621 2
              match, lineno, pattern, nodes.target)
        if inlines:
a624 1
            assert isinstance(target, nodes.target)
d630 1
a630 2
    def substitution_reference(self, match, lineno,
                               pattern=inline.patterns.substitution_ref):
d632 2
a633 1
              match, lineno, pattern, nodes.substitution_reference)
d706 5
a710 5
    def standalone_uri(self, text, lineno,
                       pattern=inline.patterns.uri,
                       whole=inline.groups.uri.whole,
                       scheme=inline.groups.uri.scheme,
                       email=inline.groups.uri.email):
d928 1
a928 1
            sw = self.statemachine.memo.reporter.error(
d932 1
a932 1
            self.statemachine.node += sw
d941 1
a941 1
            sw = self.statemachine.memo.reporter.info(
d945 1
a945 1
            self.statemachine.node += sw
d1062 1
a1062 1
            sw = self.statemachine.memo.reporter.error(
d1065 1
a1065 1
            self.statemachine.node += sw
d1135 1
a1135 1
            sw = self.statemachine.memo.reporter.warning(
d1138 1
a1138 1
            self.statemachine.node += sw
d1350 3
a1352 3
    def hyperlink_target(self, match,
                         pattern=explicit.patterns.target,
                         namegroup=explicit.groups.target.name):
d1388 2
a1389 2
                  % (self.statemachine.abslineno() - len(block) + 1))
            warning += nodes.literal_block(blocktext, blocktext)
d1398 2
a1399 5
    def isreference(self, reference,
                    pattern=explicit.patterns.reference,
                    simplegroup=explicit.groups.reference.simple,
                    phrasegroup=explicit.groups.reference.phrase):
        match = pattern.match(normname(reference))
d1402 2
a1403 1
        return unescape(match.group(simplegroup) or match.group(phrasegroup))
d1420 2
a1421 3
    def substitutiondef(self, match,
                        pattern=explicit.patterns.substitution,
                        namegroup=explicit.groups.substitution.name):
d1424 3
a1426 3
              self.statemachine.getfirstknownindented(match.end(), stripindent=0)
        blocktext = (match.string[:match.end()]
                     + '\n'.join(block))
d1440 1
a1440 2
        # strip out the substitution marker
        del block[:blockindex]
d1445 1
a1445 1
        subname = subdefmatch.group(namegroup)
d1454 2
a1455 1
            self.statemachine.previousline(len(block) + offset - newabsoffset - 1)
d1465 5
a1469 4
                sw = self.statemachine.memo.reporter.warning(
                      'Substitution definition "%s" empty or invalid at line %s.'
                      % (subname, self.statemachine.abslineno()))
                self.statemachine.node += sw
d1476 1
a1476 1
            sw = self.statemachine.memo.reporter.warning(
d1478 3
a1480 2
                  % (subname, self.statemachine.abslineno()))
            self.statemachine.node += sw
d1500 3
a1502 6
              'Unknown directive type "%s" at line %s.\n'
              'Rendering the directive as a literal block.' % (typename,
                                                               lineno))
        literalblock = nodes.literal_block(text, text)
        nodelist = [error, literalblock]
        return nodelist, blankfinish
d1563 1
a1563 2
    def explicit_construct(self, match,
                           constructs=explicit.constructs):
d1566 1
a1566 1
        for method, pattern in constructs:
d1571 1
a1571 1
                except MarkupError, detail:
d1620 2
a1621 2
                  % (self.statemachine.abslineno() - len(block) + 1))
            warning += nodes.literal_block(blocktext, blocktext)
d1637 2
a1638 1
            sw = self.statemachine.memo.reporter.severe(
d1640 3
a1642 2
                  % self.statemachine.abslineno())
            self.statemachine.node += sw
d1853 5
a1857 3
            sw = self.statemachine.memo.reporter.severe(
                  'Unexpected section title at line %s.' % lineno)
            self.statemachine.node += sw
d1863 5
a1867 3
            self.statemachine.node += \
                  self.statemachine.memo.reporter.info(
                  'Title underline too short at line %s.' % lineno)
d1876 1
a1876 1
        sw = None
d1881 1
a1881 1
            sw = self.statemachine.memo.reporter.error(
d1886 1
a1886 1
        self.statemachine.node += sw
d1996 3
a1998 1
            sw = self.statemachine.memo.reporter.error(
d2001 1
a2001 1
            self.statemachine.node += sw
d2009 4
a2012 4
            sw = self.statemachine.memo.reporter.error(
              'Document or section may not begin with a transition (line %s).'
              % (self.statemachine.abslineno() - 1))
            self.statemachine.node += sw    # @@@@@@ insert @@0, to make tree valid?
d2014 6
a2019 7
            sw = self.statemachine.memo.reporter.error(
              'At least one body element must separate transitions; adjacent '
              'transitions at line %s.'
              % (self.statemachine.abslineno() - 1))
            self.statemachine.node[-1:-1] = [sw] # leave transition as last @@@@@@?
        else:
            self.statemachine.node += transition
d2031 5
a2035 5
            sw = self.statemachine.memo.reporter.severe(
                  'Incomplete section title at line %s.'
                  % lineno)
            # @@@@@@ add a literal_block of the overline & title here?
            self.statemachine.node += sw
d2041 4
a2044 3
            sw = self.statemachine.memo.reporter.severe(
                  'Missing underline for overline at line %s.' % lineno)
            self.statemachine.node += sw
d2047 4
a2050 4
            sw = self.statemachine.memo.reporter.severe(
                  'Title overline & underline mismatch at ' 'line %s.'
                  % lineno)
            self.statemachine.node += sw
d2054 4
a2057 3
            self.statemachine.node += \
                  self.statemachine.memo.reporter.info(
                  'Title overline too short at line %s.'% lineno)
d2067 2
a2068 1
        sw = self.statemachine.memo.reporter.error(
d2070 3
a2072 2
              % (self.statemachine.abslineno() - 1))
        self.statemachine.node += sw
@


1.46
log
@  - Support for citations, auto-symbol footnotes.
@
text
@d4 2
a5 2
:Revision: $Revision: 1.45 $
:Date: $Date: 2002/03/01 03:10:23 $
d293 1
a293 2
              'Title level inconsistent at line %s:' % lineno,
              children=[literalblock])
d1562 2
a1563 2
                          self.statemachine.memo.reporter.warning(
                          detail.__class__.__name__ + ': ' + str(detail)))
d1993 1
a1993 1
            self.statemachine.node += sw
d1999 1
a1999 1
            self.statemachine.node[-1:-1] = [sw] # leave transition as last
@


1.45
log
@  - Reworked option lists.  - Minor refactoring.
@
text
@d4 2
a5 2
:Revision: $Revision: 1.44 $
:Date: $Date: 2002/02/23 16:47:34 $
d382 4
a385 3
                                   \[           # footnote_reference start,
                                   (            # footnote label (group 6):
                                       \#         # anonymous auto-numbered
d387 5
a391 1
                                       \#?%s      # (auto-numbered?) label
d393 1
a393 1
                                   (\]_)        # end-string (group 7)
d397 2
a398 2
                               ((?::%s:)?)    # optional role (group 8)
                               (              # start-string (group 9)
d409 1
d473 2
a474 2
                                        footnotelabel=6, fnend=7, role=8,
                                        backquote=9),
d640 10
a649 8
        fnname = match.group(self.inline.groups.initial.footnotelabel)
        refname = normname(fnname)
        fnrefnode = nodes.footnote_reference('[%s]_' % fnname)
        if refname[0] == '#':
            refname = refname[1:]
            fnname = fnname[1:]
            fnrefnode['auto'] = 1
            self.statemachine.memo.document.note_autofootnote_ref(fnrefnode)
d651 15
a665 4
            fnrefnode += nodes.Text(fnname)
        if refname:
            fnrefnode['refname'] = refname
            self.statemachine.memo.document.note_footnote_ref(fnrefnode)
d669 1
a669 1
        return (string[:matchstart], [fnrefnode], string[matchend:], [])
d736 1
a736 7
    def inline_text(self, text, lineno,
                    pattern=inline.patterns.initial,
                    dispatch=inline.dispatch,
                    start=inline.groups.initial.start-1,
                    backquote=inline.groups.initial.backquote-1,
                    refend=inline.groups.initial.refend-1,
                    fnend=inline.groups.initial.fnend-1):
d749 6
d1298 37
d1507 4
a1510 2
                      (                 # footnote identifier:
                          \#              # anonymous auto-numbered reference
d1512 3
a1514 1
                          \#?%s           # (auto-numbered?) footnote label
d1517 6
@


1.44
log
@  - Added support for 'option_list' attribute 'optarg_delimiter'.
@
text
@d4 2
a5 2
:Revision: $Revision: 1.43 $
:Date: $Date: 2002/02/21 03:38:03 $
d812 1
d817 3
a819 7
    pats['longname'] = '%(alphanum)s%(alphanumplus)s*' % pats
    # option arguments and long option names look alike:
    pats['optarg'] = pats['longname']
    pats['shortopt'] = '-%(alphanum)s( %(optarg)s)?' % pats
    pats['longopt'] = '--%(longname)s([ =]%(optarg)s)?' % pats
    pats['vmsopt'] = '/%(longname)s([ =]%(optarg)s)?' % pats
    pats['option'] = '(%(shortopt)s|%(longopt)s|%(vmsopt)s)' % pats
d829 2
a830 2
                'fieldmarker': r':[^: ]([^:]*[^: ])?:( +|$)',
                'optionmarker': r'%(option)s(, %(option)s)*(  +| ?$)' % pats,
d833 1
a833 1
                'explicitmarkup': r'\.\.( +|$)',
d840 2
a841 2
                          'fieldmarker',
                          'optionmarker',
d844 1
a844 1
                          'explicitmarkup',
d892 1
a892 1
        format, sequence, text, ordinal = self.parseenumerator(match)
d915 2
a916 1
        enumlist['start'] = text
d933 1
a933 1
    def parseenumerator(self, match, expectedsequence=None):
d983 1
a983 1
    def fieldmarker(self, match, context, nextstate):
d1001 1
a1001 1
        name, args = self.parsefieldmarker(match)
d1014 1
a1014 1
    def parsefieldmarker(self, match):
d1021 1
a1021 1
    def optionmarker(self, match, context, nextstate):
d1026 1
a1026 1
            listitem, blankfinish, delimiter = self.option_list_item(match)
a1038 2
        if delimiter:
            optionlist['optarg_delimiter'] = delimiter
d1052 1
a1052 1
        options, delimiter = self.parseoptionmarker(match)
d1055 1
a1055 1
        optionlistitem = nodes.option_list_item('', *options)
d1057 1
a1057 1
        optionlistitem += description
d1060 1
a1060 1
        return optionlistitem, blankfinish, delimiter
d1062 1
a1062 1
    def parseoptionmarker(self, match):
d1064 2
a1065 1
        Return a list of `node.option` objects from an option marker match.
d1070 2
a1071 4
        options = match.group().rstrip().split(', ')
        optarg_delimiter = None
        for optionstring in options:
            option = nodes.option(optionstring)
d1079 2
a1080 7
                if tokens[0][:2] == '--':
                    option += nodes.long_option(tokens[0], tokens[0][2:])
                elif tokens[0][:1] == '-':
                    option += nodes.short_option(tokens[0], tokens[0][1:])
                    delimiter = ''      # ignore delimiter for short options
                elif tokens[0][:1] == '/':
                    option += nodes.vms_option(tokens[0], tokens[0][1:])
d1082 2
a1083 7
                    option += nodes.option_argument(tokens[1], tokens[1])
                    if delimiter:
                        if optarg_delimiter:
                            if delimiter != optarg_delimiter:
                                optarg_delimiter = "mixed"
                        else:
                            optarg_delimiter = delimiter
d1089 1
a1089 1
        return optlist, optarg_delimiter
d1479 1
a1479 1
    def explicitmarkup(self, match, context, nextstate):
d1589 2
a1590 2
    fieldmarker = invalid_input
    optionmarker = invalid_input
d1593 1
a1593 1
    explicitmarkup = invalid_input
d1629 1
a1629 1
        format, sequence, text, ordinal = self.parseenumerator(
d1647 1
a1647 1
    def fieldmarker(self, match, context, nextstate):
d1659 1
a1659 1
    def optionmarker(self, match, context, nextstate):
d1662 1
a1662 2
            optionlistitem, blankfinish, delimiter = \
                  self.option_list_item(match)
d1665 1
a1665 8
        listnode = self.statemachine.node
        if delimiter:
            if listnode.has_key('optarg_delimiter'):
                if listnode['optarg_delimiter'] != delimiter:
                    listnode['optarg_delimiter'] = "mixed"
            else:
                listnode['optarg_delimiter'] = delimiter
        listnode += optionlistitem
d1681 1
a1681 1
    def explicitmarkup(self, match, context, nextstate):
@


1.43
log
@fixed short options; added option delimiter attribute support (commented out)
@
text
@d4 2
a5 2
:Revision: $Revision: 1.42 $
:Date: $Date: 2002/02/15 22:57:38 $
d1028 1
a1028 1
            listitem, blankfinish = self.option_list_item(match)
d1041 2
d1056 1
a1056 1
        options = self.parseoptionmarker(match)
d1064 1
a1064 1
        return optionlistitem, blankfinish
d1074 1
d1078 1
a1078 1
            #atts = {'delimiter': ' '}
d1082 1
a1082 1
                #atts['delimiter'] = '='
d1088 1
a1088 1
                    #del atts['delimiter']
d1093 6
a1098 1
                                                    #**atts)
d1104 1
a1104 1
        return optlist
d1677 2
a1678 1
            optionlistitem, blankfinish = self.option_list_item(match)
d1681 8
a1688 1
        self.statemachine.node += optionlistitem
@


1.42
log
@  - Changed "system_warning" to "system_message".
@
text
@d4 2
a5 2
:Revision: $Revision: 1.41 $
:Date: $Date: 2002/02/12 02:26:53 $
d816 6
a821 4
    pats['optarg'] = '%(alphanum)s%(alphanumplus)s*' % pats
    pats['shortopt'] = '-%(alphanum)s( %(optarg)s|%(alphanumplus)s+)?' % pats
    pats['longopt'] = '--%(alphanum)s%(alphanumplus)s*([ =]%(optarg)s)?' % pats
    pats['vmsopt'] = '/%(alphanum)s%(alphanumplus)s*([ =]%(optarg)s)?' % pats
d1075 5
a1079 1
            tokens[:1] = tokens[0].split('=')
d1085 1
d1090 1
@


1.41
log
@minor edits
@
text
@d4 2
a5 2
:Revision: $Revision: 1.40 $
:Date: $Date: 2002/02/06 02:24:58 $
d304 1
a304 1
        textnodes, warnings = self.inline_text(title, lineno)
d309 1
a309 1
        sectionnode += warnings
d324 1
a324 1
        Return a list (paragraph & warnings) and a boolean: literal_block next?
d338 1
a338 1
        textnodes, warnings = self.inline_text(text, lineno)
d340 1
a340 1
        return [p] + warnings, literalnext
d512 1
a512 1
        before, inlines, remaining, syswarnings, endstring = self.inlineobj(
d514 1
a514 1
        return before, inlines, remaining, syswarnings
d517 1
a517 1
        before, inlines, remaining, syswarnings, endstring = self.inlineobj(
d519 1
a519 1
        return before, inlines, remaining, syswarnings
d592 1
a592 1
        before, inlines, remaining, syswarnings, endstring = self.inlineobj(
d594 1
a594 1
        return before, inlines, remaining, syswarnings
d597 1
a597 1
        before, inlines, remaining, syswarnings, endstring = self.inlineobj(
d607 1
a607 1
        return before, inlines, remaining, syswarnings
d611 1
a611 1
        before, inlines, remaining, syswarnings, endstring = self.inlineobj(
d631 1
a631 1
        return before, inlines, remaining, syswarnings
d725 1
a725 1
        Return 2 lists: nodes (text and inline elements), and system_warnings.
d733 1
a733 1
        found or invalid, raise a warning and ignore the start-string.
d739 1
a739 1
        warnings = []
d744 1
a744 1
                before, inlines, remaining, syswarnings = \
d749 1
a749 1
                warnings += syswarnings
d760 1
a760 1
        return processed, warnings
d1108 1
a1108 1
        block, warnings, blankfinish = self.isolatetable()
d1114 1
a1114 1
                nodelist = [table] + warnings
d1116 1
a1116 1
                nodelist = self.malformedtable(block, str(detail)) + warnings
d1118 1
a1118 1
            nodelist = warnings
d1122 1
a1122 1
        warnings = []
d1128 1
a1128 1
            warnings.append(self.statemachine.memo.reporter.error(
d1148 2
a1149 2
                warnings.extend(self.malformedtable(block))
                return [], warnings, blankfinish
d1152 3
a1154 3
                warnings.extend(self.malformedtable(block))
                return [], warnings, blankfinish
        return block, warnings, blankfinish
d1835 1
a1835 1
        termlist, warnings = self.term(termline,
d1838 1
a1838 1
        definition = nodes.definition('', *warnings)
d1853 1
a1853 1
        textnodes, warnings = self.inline_text(termpart, lineno)
d1857 1
a1857 1
            textnodes, cpwarnings = self.inline_text(classifierpart, lineno)
d1859 2
a1860 2
            warnings += cpwarnings
        return nodelist, warnings
@


1.40
log
@  - ``Reporter.information()`` -> ``.info``.  - Trim trailing blank lines from literal blocks.
@
text
@d4 2
a5 2
:Revision: $Revision: 1.39 $
:Date: $Date: 2002/01/30 05:01:25 $
d166 1
a166 1
        Parse `inputlines` and return a `dps.nodes.document` instance.
d235 1
a235 1
        if not blankfinishstate:
d1107 1
a1107 1
        """Temporarily parse a table as a literal_block."""
d1702 1
a1702 1
          'inline_directive': r'(%s)::( +|$)' % RSTState.inline.simplename,
d1704 1
a1704 1
    initialtransitions = ['inline_directive', 'text']
d1706 1
a1706 1
    def inline_directive(self, match, context, nextstate):
@


1.39
log
@  - Updated for new document Node creation protocol.
@
text
@d4 2
a5 2
:Revision: $Revision: 1.38 $
:Date: $Date: 2002/01/28 02:12:41 $
d144 1
a144 1
        self.language = languages.language(docroot.languagecode)
d908 1
a908 1
            sw = self.statemachine.memo.reporter.information(
d1783 1
a1783 1
                  self.statemachine.memo.reporter.information(
d1817 2
d1841 1
a1841 1
            definition += self.statemachine.memo.reporter.information(
d1970 1
a1970 1
                  self.statemachine.memo.reporter.information(
@


1.38
log
@mods for footnote transforms
@
text
@d4 2
a5 2
:Revision: $Revision: 1.37 $
:Date: $Date: 2002/01/25 23:48:14 $
d136 1
a136 7
    def __init__(self, stateclasses, initialstate, languagecode, debug=0):
        StateMachineWS.__init__(self, stateclasses, initialstate, debug=debug)
        self.languagecode = languagecode
        self.language = languages.language(self.languagecode)

    def run(self, inputlines, inputoffset=0, warninglevel=1, errorlevel=3,
			matchtitles=1):
d141 1
a141 1
        StateMachine, do some final transformations, and return the resulting
d144 1
a145 2
        reporter = utils.Reporter(warninglevel, errorlevel)
        docroot = nodes.document(reporter, self.languagecode)
d147 1
a147 1
                          reporter=reporter,
d154 1
a154 2
        self.node = self.memo = None
        return docroot
@


1.37
log
@  - Updated for hyperlink transforms.
@
text
@d4 2
a5 2
:Revision: $Revision: 1.36 $
:Date: $Date: 2002/01/16 06:16:00 $
d654 1
a654 1
            self.statemachine.memo.document.note_refname(fnrefnode)
d1280 2
a1281 2
            self.statemachine.memo.document.note_implicit_target(footnotenode,
                                                               footnotenode)
@


1.36
log
@  - Moved 'normname()' to dps/utils.py.  - Updated for languagecode.
@
text
@d4 2
a5 2
:Revision: $Revision: 1.35 $
:Date: $Date: 2001/11/22 04:20:49 $
d314 2
d318 1
a318 2
        memo.document.addimplicittarget(normname(titlenode.astext()),
                                        sectionnode)
d575 2
a576 1
            self.statemachine.memo.document.addanonymousref(reference)
d579 1
a579 1
        self.statemachine.memo.document.addrefname(refname, reference)
d612 3
a614 2
            self.statemachine.memo.document.addexplicittarget(
                  name, target, self.statemachine.node)
d624 1
d627 2
a628 2
            assert isinstance(subrefnode, nodes.substitution_reference)
            self.statemachine.memo.document.addsubstitutionref(refname, subrefnode)
d632 2
a633 1
                    self.statemachine.memo.document.addanonymousref(referencenode)
a634 1
                    self.statemachine.memo.document.addrefname(refname, referencenode)
d636 1
d648 2
a649 2
            self.statemachine.memo.document.addautofootnoteref(refname,
                                                               fnrefnode)
d654 1
a654 1
            self.statemachine.memo.document.addrefname(refname, fnrefnode)
a665 1
        self.statemachine.memo.document.addrefname(refname, referencenode)
d667 2
a668 1
            self.statemachine.memo.document.addanonymousref(referencenode)
d671 1
d1274 2
a1275 1
            self.statemachine.memo.document.addautofootnote(name, footnotenode)
d1279 3
a1281 2
            self.statemachine.memo.document.addimplicittarget(name,
                                                              footnotenode)
d1313 1
a1313 1
                target = nodes.target(blocktext, '')
d1315 2
a1316 2
                self.statemachine.memo.document.addindirecttarget(refname,
                                                                  target)
d1343 1
a1343 1
    def addtarget(self, targetname, reference, target):
d1346 6
a1351 6
            if reference:
                self.statemachine.memo.document.addexternaltarget(
                      name, reference, target, self.statemachine.node)
            else:
                self.statemachine.memo.document.addexplicittarget(
                      name, target, self.statemachine.node)
d1353 4
a1356 3
            self.statemachine.memo.document.addanonymoustarget(target)
            if reference:
                target['refuri'] = reference
d1410 2
a1411 2
                self.statemachine.memo.document.addsubstitutiondef(
                      name, substitutionnode, self.statemachine.node)
d1541 3
a1543 5
                target = nodes.target(blocktext, '')
                self.addtarget('', '', target)
                self.statemachine.memo.document.addanonymoustarget(target)
                self.statemachine.memo.document.addindirecttarget(refname,
                                                                  target)
d1555 5
a1559 4
            unescaped = unescape(reference)
            target = nodes.target(blocktext, '')
            target['refuri'] = unescaped
            self.statemachine.memo.document.addanonymoustarget(target)
d1601 1
a1601 1
    anonymoustarget = invalid_input
@


1.35
log
@  - Added --debug/-d option.  - Minor fixes.
@
text
@d4 2
a5 2
:Revision: $Revision: 1.34 $
:Date: $Date: 2001/11/19 04:27:54 $
d106 2
a107 1
import directives
d136 1
a136 1
    def __init__(self, stateclasses, initialstate, language, debug=0):
d138 2
a139 1
        self.language = language
d152 1
a152 1
        docroot = nodes.document(reporter)
a2010 4

def normname(name):
    """Return a case- and whitespace-normalized name."""
    return ' '.join(name.lower().split())
@


1.34
log
@  - Reimplemented substitution definitions & references.  - Changed "phrase link" to "phrase reference".  - Modified ``RSTState.inlineobj()`` to return end-string.  - Modified directive API to pass attributes.
@
text
@d4 2
a5 2
:Revision: $Revision: 1.33 $
:Date: $Date: 2001/11/13 03:15:42 $
d136 1
a136 1
        StateMachineWS.__init__(self, stateclasses, initialstate, debug=0)
a1275 1
    # @@@@@@ have to allow multi-line hyperlink names
d1279 20
a1298 10
        escaped = escape2null(match.string)
        targetmatch = pattern.match(escaped[match.end():])
        if not targetmatch:
            raise MarkupError('malformed hyperlink target at line %s.'
                              % self.statemachine.abslineno())
        referencestart = match.end() + targetmatch.end()
        block, indent, offset, blankfinish \
              = self.statemachine.getfirstknownindented(referencestart,
                                                        uptoblank=1)
        blocktext = match.string[:referencestart] + '\n'.join(block)
d1300 1
a1300 1
            reference = escape2null(' '.join([line.strip() for line in block]))
d1309 1
a1309 1
        reference = escape2null(''.join([line.strip() for line in block]))
a1346 1
    # @@@@@@ have to allow multi-line substitution text
d1350 24
a1373 10
        escaped = escape2null(match.string)
        subdefmatch = pattern.match(escaped[match.end():])
        if not subdefmatch:
            raise MarkupError('malformed substitution definition at line %s.'
                              % self.statemachine.abslineno())
        directivestart = match.end() + subdefmatch.end()
        indented, indent, offset, blankfinish = \
              self.statemachine.getfirstknownindented(directivestart, uptoblank=1,
                                                      stripindent=0)
        blocktext = match.string[:directivestart] + '\n'.join(indented)
d1378 6
a1383 6
        if indented:
            indented[0] = indented[0].lstrip()
            self.nestedparse(
                  indented, inputoffset=offset, node=substitutionnode,
                  statemachinekwargs={'stateclasses': stateclasses,
                                      'initialstate': 'SubstitutionDef'})
d1423 1
a1423 4
              self.statemachine.getfirstknownindented(0)
        margin = ' ' * indent
        for i in range(1, len(indented)):
            indented[i] = margin + indented[i]
d1510 1
a1512 1
        self.gotoline(newlineoffset)
d1693 1
a1693 1
class SubstitutionDef(SpecializedBody):
d1711 8
a1718 2
        self.blankfinish = blankfinish
        return [], nextstate, []
@


1.33
log
@- Removed "replacement text" aspect of substitutions.
@
text
@d4 2
a5 2
:Revision: $Revision: 1.32 $
:Date: $Date: 2001/11/06 00:51:33 $
d22 1
d378 2
a393 5
                                 |
                                   `/           # substitution_reference start
                                   (%s)         # substitution name (8)
                                   (/`)         # end-string (group 9)
                                   (__?)?       # optional reference (10)
d397 5
a401 4
                               ((?::%s:)?)    # optional role (group 11)
                               (              # start-string (group 12)
                                 `              # interpreted or phrase link
                                 (?![`/])       # but not literal/substitution
a408 1
                                    inline.simplename,
d417 1
a417 1
          interpreted_or_phrase_link=re.compile(
d425 3
d472 3
a474 4
                                        footnotelabel=6, fnend=7, subname=8,
                                        subend=9, subref=10, role=11,
                                        backquote=12),
                          interpreted_or_phrase_link=Stuff(suffix=2),
d502 1
a502 1
            return (string[:matchend], [], string[matchend:], [])
d510 1
a510 1
                    string[matchend:][endmatch.end(1):], [])
d514 1
a514 1
        return (string[:matchend], [], string[matchend:], [sw])
d517 3
a519 1
        return self.inlineobj(match, lineno, pattern, nodes.emphasis)
d522 3
a524 1
        return self.inlineobj(match, lineno, pattern, nodes.strong)
d526 1
a526 1
    def interpreted_or_phrase_link(
d528 1
a528 1
          pattern=inline.patterns.interpreted_or_phrase_link,
d552 1
a552 1
                          'and role with phrase-link end-string at line %s.'
d555 1
a555 1
                return self.phrase_link(
d564 1
a564 1
              'Inline interpreted text or phrase link start-string '
d566 1
a566 1
        return (string[:matchend], [], string[matchend:], [sw])
d568 1
a568 1
    def phrase_link(self, before, after, text, rawsource):
d576 1
a576 1
        return (before, [reference], after, [])
d580 1
a580 1
                    suffix=inline.groups.interpreted_or_phrase_link.suffix):
d596 3
a598 2
        return self.inlineobj(match, lineno, pattern, nodes.literal,
                              restorebackslashes=1)
d601 1
a601 1
        before, inlines, remaining, syswarnings = self.inlineobj(
d612 21
a632 20
    def substitution_reference(self, match, lineno):
        subname = match.group(self.inline.groups.initial.subname)
        refname = normname(subname)
        subrefnode = nodes.substitution_reference('`/%s/`' % subname, subname)
        self.statemachine.memo.document.addsubstitutionref(refname, subrefnode)
        inlineobj = subrefnode
        subref = match.group(self.inline.groups.initial.subref)
        if subref:
            referencenode = nodes.reference('`/%s/`%s' % (subname, subref), '')
            self.statemachine.memo.document.addrefname(refname, referencenode)
            if subref == '__':
                self.statemachine.memo.document.addanonymousref(referencenode)
            else:
                referencenode['refname'] = refname
            referencenode += subrefnode
            inlineobj = referencenode
        string = match.string
        matchstart = match.start(self.inline.groups.initial.whole)
        matchend = match.end(self.inline.groups.initial.whole)
        return (string[:matchstart], [inlineobj], string[matchend:], [])
d709 1
a709 1
                       '`': interpreted_or_phrase_link,
d713 1
a713 1
                       '/`': substitution_reference,
d717 7
a723 1
    def inline_text(self, text, lineno):
d727 5
a731 5
        A pattern matching start-strings (for emphasis, strong, interpreted,
        phrase link, and literal) or complete constructs (simple reference,
        footnote reference) is stored in `self.inline.patterns.initial`. First
        we search for a candidate. When one is found, we check for validity
        (e.g., not a quoted '*' character). If valid, search for the
d734 1
a734 2
        Standalone hyperlinks are found last. Other than that, there is no
        "precedence order" to inline markup, just left-to-right.
a735 7
        pattern = self.inline.patterns.initial
        dispatch = self.inline.dispatch
        start = self.inline.groups.initial.start - 1
        backquote = self.inline.groups.initial.backquote - 1
        refend = self.inline.groups.initial.refend - 1
        fnend = self.inline.groups.initial.fnend - 1
        subend = self.inline.groups.initial.subend - 1
d746 2
a747 2
                               or groups[refend] or groups[fnend]
                               or groups[subend]](self, match, lineno)
d1222 1
a1222 1
                            (?:[ ]+|$)    # followed by whitespace
d1241 12
a1252 1
                               re.VERBOSE))
d1255 2
a1256 1
          reference=Stuff(simple=1, phrase=2))
d1276 1
d1319 1
a1319 1
        match = pattern.match(reference)
d1322 1
a1322 2
        return normname(unescape(match.group(simplegroup)
                                 or match.group(phrasegroup)))
d1338 10
a1347 1
    def substitution(self, match):
d1349 1
a1349 1
              self.statemachine.getfirstknownindented(match.end(), uptoblank=1,
d1351 2
a1352 1
        subname = match.group(1)
d1354 2
a1355 1
        substitutionnode = nodes.substitution('\n'.join(indented))
d1357 5
a1361 3
            self.nestedparse(indented, inputoffset=offset, node=substitutionnode,
                             statemachinekwargs={'stateclasses': stateclasses,
                                                 'initialstate': 'Substitution'})
d1372 1
a1372 1
                      'Substitution "%s" empty or invalid at line %s.'
d1376 2
a1377 1
                self.statemachine.memo.document.addsubstitution(
d1382 1
a1382 1
                  'Substitution "%s" missing contents at line %s.'
d1387 1
a1387 1
    def directive(self, match):
d1391 1
a1391 1
        data = match.string[match.end():].strip() or None
d1394 1
a1394 1
                                     self.statemachine)
d1440 1
d1442 1
a1442 1
          (substitution,
d1445 3
a1447 5
                      /
                      (%s)              # substitution name
                      /
                      (?:[ ]+|$)        # whitespace or end of line
                      """ % RSTState.inline.simplename, re.VERBOSE)),
d1674 1
a1674 1
class Substitution(SpecializedBody):
d1677 1
a1677 1
    Parser for the contents of a substitution element.
d1686 5
a1690 1
        nodelist, blankfinish = self.directive(match)
d1961 1
a1961 1
                Substitution]
@


1.32
log
@  - Added substitutions, substitution references.
@
text
@d4 2
a5 2
:Revision: $Revision: 1.31 $
:Date: $Date: 2001/11/01 04:08:18 $
d1324 2
a1325 1
              self.statemachine.getfirstknownindented(match.end(), uptoblank=1)
a1328 2
        self.statemachine.memo.document.addsubstitution(name, substitutionnode,
                                                        self.statemachine.node)
d1333 8
d1343 2
a1344 2
                      'Substitution contents empty at line %s'
                      % self.statemachine.abslineno())
a1345 3
            elif len(substitutionnode) == 1 \
                  and isinstance(substitutionnode[0], nodes.paragraph):
                substitutionnode[:] = substitutionnode[0][:]
d1347 3
a1349 8
                i = 0
                for node in substitutionnode[:]:
                    if not (isinstance(node, nodes.Inline) or
                            isinstance(node, nodes.Text)):
                        self.statemachine.node += substitutionnode[i]
                        del substitutionnode[i]
                    else:
                        i += 1
d1352 2
a1353 2
                  'Substitution missing contents at line %s'
                  % self.statemachine.abslineno())
d1355 1
a1355 1
        return [substitutionnode], blankfinish
d1398 1
a1398 1
                      (                 # footnote reference identifier:
d1645 18
a1923 17


class Substitution(Body):

    """
    Parser for the contents of a substitution element.
    """

    patterns = {
          'inline_directive': r'(%s)::( +|$)' % RSTState.inline.simplename,
          'text': r''}
    initialtransitions = ['inline_directive', 'text']

    def inline_directive(self, match, context, nextstate):
        nodelist, blankfinish = self.directive(match)
        self.statemachine.node += nodelist
        return [], nextstate, []
@


1.31
log
@  - Added support for IPv6 URIs.
@
text
@d4 2
a5 2
:Revision: $Revision: 1.30 $
:Date: $Date: 2001/10/31 05:52:39 $
d380 3
a382 10
                               ((?::%s:)?)    # optional role (group 3)
                               (              # start-string (group 4)
                                 `              # interpreted or phrase link
                                 (?!`)          # but not literal
                               )
                               %s             # no whitespace after
                             |              # *OR*
                               (              # whole constructs (group 5):
                                   (%s)         # reference name (6)
                                   (__?)        # end-string (7)
d385 1
a385 1
                                   (            # footnote label (group 8):
d390 6
a395 1
                                   (\]_)        # end-string (group 9)
d398 7
a408 1
                                    inline.non_whitespace_after,
d411 3
a413 1
                                    inline.end_string_suffix),
d470 4
a473 3
    inline.groups = Stuff(initial=Stuff(start=2, role=3, backquote=4, whole=5,
                                        refname=6, refend=7, footnotelabel=8,
                                        fnend=9),
d566 1
a566 1
        attributes = {'refname': refname}
d568 5
a572 4
            attributes['anonymous'] = 1
        inlineobj = nodes.reference(rawsource, text, **attributes)
        self.statemachine.memo.document.addrefname(refname, inlineobj)
        return (before, [inlineobj], after, [])
d607 21
a649 1
        attributes = {'refname': refname}
d652 1
a652 1
              referencename, refname=refname)
d656 2
d707 1
d731 1
d742 2
a743 2
                               or groups[refend]
                               or groups[fnend]](self, match, lineno)
d1322 36
d1412 8
d1909 17
d1927 2
a1928 1
                OptionList, RFC822List, Explicit, Text, Definition, Line]
@


1.30
log
@  - Changed "[hyper]link" to "reference".
@
text
@d4 2
a5 2
:Revision: $Revision: 1.29 $
:Date: $Date: 2001/10/30 05:01:53 $
d359 2
a360 2
    inline.uric = r"""[-_.!~*'();/:@@&=+$,%a-zA-Z0-9]"""
    inline.urilast = r"""[_~/a-zA-Z0-9]"""
@


1.29
log
@  - Added inline literal targets.  - Added anonymous hyperlinks (``.. __:`` & ``__`` syntax).  - External targets' URIs now in "refuri" attribute, not data.
@
text
@d4 2
a5 2
:Revision: $Revision: 1.28 $
:Date: $Date: 2001/10/27 05:18:35 $
d388 2
a389 1
                                   (%s)(__?)    # link name, end-string (6,7)
d465 1
a465 1
                                        linkname=6, linkend=7, footnotelabel=8,
d473 2
a474 2
        start = match.start()           # self.inline.groups.initial.start
        end = match.end()               # self.inline.groups.initial.start)
d562 1
a562 1
        inlineobj = nodes.link(rawsource, text, **attributes)
d618 3
a620 3
    def link(self, match, lineno, anonymous=None):
        linkname = match.group(self.inline.groups.initial.linkname)
        refname = normname(linkname)
d622 4
a625 4
        linknode = nodes.link(
              linkname + match.group(self.inline.groups.initial.linkend),
              linkname, refname=refname)
        self.statemachine.memo.document.addrefname(refname, linknode)
d627 1
a627 1
            self.statemachine.memo.document.addanonymousref(linknode)
d631 1
a631 1
        return (string[:matchstart], [linknode], string[matchend:], [])
d633 2
a634 2
    def anonymous_link(self, match, lineno):
        return self.link(match, lineno, anonymous=1)
d658 3
a660 3
                    textnodes.append(nodes.link(unescape(text, 1),
                                                unescaped,
                                                refuri=addscheme + unescaped))
d677 2
a678 2
                       '_': link,
                       '__': anonymous_link}
d685 1
a685 1
        phrase link, and literal) or complete constructs (simple link,
d698 1
a698 1
        linkend = self.inline.groups.initial.linkend - 1
d710 1
a710 1
                               or groups[linkend]
d1178 1
a1178 1
                              (           # hyperlink name
d1185 1
a1185 1
                            :           # end of hyperlink name
d1193 1
a1193 1
                                 (%s)_       # simple hyperlink name
d1762 1
a1785 1
        makesection = 1
d1793 1
a1793 1
                  'Incomplete section title or empty division at line %s.'
d1797 1
a1797 1
            makesection = 0
d1805 1
a1805 1
            makesection = 0
d1811 1
a1811 1
            makesection = 0
d1817 4
a1820 5
        if makesection:
            style = (overline[0], underline[0])
            self.eofcheck = 0           # @@@@@@ not sure this is correct
            self.section(title.lstrip(), source, style, lineno + 1)
            self.eofcheck = 1
@


1.28
log
@  - Fixed option lists.  - Fixed standalone hyperlinks (known schemes only).
@
text
@d4 2
a5 2
:Revision: $Revision: 1.27 $
:Date: $Date: 2001/10/23 03:36:44 $
d24 1
d375 2
d418 2
d586 12
a625 1
            linknode['anonymous'] = 1
d674 1
d797 4
a800 3
                'explicit_markup': r'\.\.( +|$)',
                'overline': r'(%(nonalphanum7bit)s)\1\1\1+ *$' % pats,
                'rfc822': r'[!-9;-~]+:( +|$)',
d808 3
a810 2
                          'explicit_markup',
                          'overline',
d1173 2
a1181 2
                            |           # *OR*
                              (_)         # anonymous target
d1186 1
a1186 1
                            """ 
d1206 1
a1206 1
          target=Stuff(quote=1, name=2, anonymous=3),
d1229 1
a1229 2
                         namegroup=explicit.groups.target.name,
                         anonymousgroup=explicit.groups.target.anonymous):
d1244 1
a1244 1
                target = nodes.target(blocktext, '', refname=refname)
d1260 1
a1260 1
            target = nodes.target(blocktext, unescaped)
d1285 3
a1287 3
            self.statemachine.memo.document.addanonymoustarget(
                      target, self.statemachine.node)

d1351 1
a1351 1
    def explicit_markup(self, match, context, nextstate):
d1355 1
a1355 9
        offset = self.statemachine.lineoffset + 1   # next line
        newlineoffset, blankfinish = self.nestedlistparse(
              self.statemachine.inputlines[offset:],
              inputoffset=self.statemachine.abslineoffset() + 1,
              node=self.statemachine.node, initialstate='Explicit',
              blankfinish=blankfinish)
        if not blankfinish:
            self.statemachine.node += self.unindentwarning()
        self.gotoline(newlineoffset)
d1375 59
a1433 5
    def overline(self, match, context, nextstate):
        """Section title or division marker."""
        makesection = 1
        lineno = self.statemachine.abslineno()
        if not self.statemachine.matchtitles:
d1435 2
a1436 1
                  'Unexpected section title or division at line %s.' % lineno)
a1438 33
        title = underline = ''
        try:
            title = self.statemachine.nextline()
            underline = self.statemachine.nextline()
        except IndexError:
            sw = self.statemachine.memo.reporter.severe(
                  'Incomplete section title or empty division at line %s.'
                  % lineno)
            self.statemachine.node += sw
            makesection = 0
        source = '%s\n%s\n%s' % (match.string, title, underline)
        overline = match.string.rstrip()
        underline = underline.rstrip()
        if not self.transitions['overline'][0].match(underline):
            sw = self.statemachine.memo.reporter.severe(
                  'Missing underline for overline at line %s.' % lineno)
            self.statemachine.node += sw
            makesection = 0
        elif overline != underline:
            sw = self.statemachine.memo.reporter.severe(
                  'Title overline & underline mismatch at ' 'line %s.'
                  % lineno)
            self.statemachine.node += sw
            makesection = 0
        title = title.rstrip()
        if len(title) > len(overline):
            self.statemachine.node += \
                  self.statemachine.memo.reporter.information(
                  'Title overline too short at line %s.'% lineno)
        if makesection:
            style = (overline[0], underline[0])
            self.section(title.lstrip(), source, style, lineno + 1)
        return [], nextstate, []
d1466 3
a1468 2
    explicit_markup = invalid_input
    overline = invalid_input
d1554 1
a1554 1
    def explicit_markup(self, match, context, nextstate):
d1561 7
d1577 1
a1577 1
    patterns = {'underline': r'([!-/:-@@[-`{-~])\1\1\1+ *$',
d1717 1
a1717 2
        """Not a definition."""
        self.statemachine.previousline(2) # back up so parent SM can reassess
d1734 5
d1747 86
d1834 1
a1834 1
                OptionList, RFC822List, Explicit, Text, Definition]
@


1.27
log
@  - Updated for renamed ``add*link`` -> ``add*target``.  - Anonymous hyperlink ref & target support.  - Indirect hyperlink target support.
@
text
@d4 2
a5 2
:Revision: $Revision: 1.26 $
:Date: $Date: 2001/10/20 02:52:35 $
d102 1
a102 1
from dps import nodes, statemachine, utils, roman
d420 3
a422 1
                    [a-zA-Z][a-zA-Z0-9.+-]*     # scheme (http, ftp, mailto)
d441 1
a441 1
                  (                           # email address (group 3)
d462 1
a462 1
                          uri=Stuff(whole=1, absolute=2, email=3))
d619 2
a620 1
    def standalone_uri(self, text, lineno, pattern=inline.patterns.uri,
d622 1
d626 1
d628 1
a628 1
            match = pattern.search(remainder)
d630 18
a647 13
                if match.start(whole) > 0:
                    textnodes.append(nodes.Text(unescape(
                          remainder[:match.start(whole)])))
                if match.group(email):
                    scheme = 'mailto:'
                else:
                    scheme = ''
                text = match.group(whole)
                unescaped = unescape(text, 0)
                textnodes.append(nodes.link(unescape(text, 1),
                                            unescaped,
                                            refuri=scheme + unescaped))
                remainder = remainder[match.end(whole):]
d765 1
a765 1
    pats['vmsopt'] = '/%(alphanum)s( %(optarg)s|%(alphanumplus)s+)?' % pats
d1017 1
a1017 7
            if tokens[0][:2] == '--':
                tokens[:1] = tokens[0].split('=')
            elif tokens[0][:1] in '-/':
                if len(tokens[0]) > 2:
                    tokens[:1] = [tokens[0][:2], tokens[0][2:]]
            else:
                raise MarkupError('not an option marker: %r' % optionstring)
d1020 1
a1020 1
                    option += nodes.long_option(tokens[0], tokens[0])
d1022 1
a1022 1
                    option += nodes.short_option(tokens[0], tokens[0])
d1024 1
a1024 1
                    option += nodes.vms_option(tokens[0], tokens[0])
@


1.26
log
@  - Anonymous hyperlink references done or almost done.  - Began work on divisions.
@
text
@d4 2
a5 2
:Revision: $Revision: 1.25 $
:Date: $Date: 2001/10/18 03:53:42 $
d312 2
a313 1
        memo.document.addimplicitlink(normname(titlenode.astext()), sectionnode)
d579 1
a579 1
    def footnote_reference(self, match, lineno, pattern=None):
d598 1
a598 2
    def link(self, match, lineno, pattern=None, attributes=None):
        attributes = attributes or {}   # initialize if None
d601 1
a601 1
        attributes['refname'] = refname
d604 1
a604 1
              linkname, **attributes)
d606 3
d614 2
a615 2
    def anonymous_link(self, match, lineno, pattern=None):
        return self.link(match, lineno, pattern, {'anonymous': 1})
d1149 10
a1158 4
                            (`?)        # optional open quote
                            (?!=[ ])    # first char. not space
                            (           # hyperlink name
                              .+?
a1160 1
                            \1          # close quote if open quote used
d1163 19
a1181 2
                            """ % RSTState.inline.non_whitespace_escape_before,
                            re.VERBOSE),)
d1183 2
a1184 1
          target=Stuff(quote=1, name=2))
d1198 2
a1199 1
            self.statemachine.memo.document.addimplicitlink(name, footnotenode)
d1206 2
a1207 1
                         namegroup=explicit.groups.target.name):
a1213 1
        name = normname(unescape(targetmatch.group(namegroup)))
a1216 1
        reference = ''.join([line.strip() for line in block])
d1218 9
d1228 1
d1237 19
a1255 1
            target = nodes.target(blocktext, reference)
d1257 1
a1257 1
                self.statemachine.memo.document.addexternallink(
d1260 1
a1260 1
                self.statemachine.memo.document.addexplicitlink(
d1262 4
a1265 2
            nodelist.append(target)
        return nodelist, blankfinish
@


1.25
log
@  - Beginning of modifications for anonymous hyperlinks.
@
text
@d4 2
a5 2
:Revision: $Revision: 1.24 $
:Date: $Date: 2001/09/26 03:42:06 $
a534 3
                if rawsource[-2:] == '__':
                    # @@@@@@
                    pass
d550 4
a553 1
        inlineobj = nodes.link(rawsource, text, refname=normname(text))
d597 2
a598 1
    def link(self, match, lineno, pattern=None):
d601 4
a604 1
        linknode = nodes.link(linkname + '_', linkname, refname=refname)
d612 1
a612 9
        # @@@@@@
        linkname = match.group(self.inline.groups.initial.linkname)
        refname = normname(linkname)
        linknode = nodes.link(linkname + '_', linkname, refname=refname)
        self.statemachine.memo.document.addrefname(refname, linknode)
        string = match.string
        matchstart = match.start(self.inline.groups.initial.whole)
        matchend = match.end(self.inline.groups.initial.whole)
        return (string[:matchstart], [linknode], string[matchend:], [])
d1203 1
a1203 1
                self.statemachine.memo.document.addindirectlink(
d1306 1
a1306 1
        """Section title."""
d1311 1
a1311 1
                  'Unexpected section title at line %s.' % lineno)
d1320 2
a1321 1
                  'Incomplete section title at line %s.' % lineno)
@


1.24
log
@  - Removed section promotion transformation.  - Removed bibliographic field list transformations.
@
text
@d4 2
a5 2
:Revision: $Revision: 1.23 $
:Date: $Date: 2001/09/22 02:41:39 $
d384 1
a384 1
                                   (%s)(_)      # link name, end-string (6,7)
d409 3
a411 3
                '%s(`(:%s:|_)?)%s' % (inline.non_whitespace_escape_before,
                                      inline.simplename,
                                      inline.end_string_suffix)),
d528 1
a528 1
            if rawsource[-1] == '_':
d535 3
d607 11
d650 2
a651 1
                       '_': link}
@


1.23
log
@  - Fixed bibliographic field list conversion for single    paragraphs containing links or formatting.
@
text
@d4 2
a5 2
:Revision: $Revision: 1.22 $
:Date: $Date: 2001/09/18 21:27:24 $
a156 2
        self.promotelonesection()
        self.transformfirstfields()
a158 208

    def promotelonesection(self):
        """
        Promote an only-child section to the document level.

        If the only non-comment child of an untitled document element is a
        section, the section is promoted to the document level. The section's
        title becomes the document title, and the section's contents become
        the document's contents.
        """
        index = self.node.findnonclass((nodes.comment, nodes.system_warning))
        if index is None or len(self.node) > (index + 1):
            return
        candidate = self.node[index]
        if not isinstance(candidate, nodes.section): 
            return
        self.node.attributes.update(candidate.attributes)
        self.node[:] = candidate[:1] + self.node[:index] + candidate[1:]

    def transformfirstfields(self):
        """
        Transform bibliographic field_list fields to elements if found.

        The bibliographic field_list must be the first non-comment child
        (possibly after a title) of the document element itself.
        """
        index = self.node.findnonclass(nodes.comment)
        if index is None:
            return
        candidate = self.node[index]
        if isinstance(candidate, nodes.title):
            titleindex = index
            biblioindex = titleindex + 1
            index = self.node.findnonclass(nodes.comment, titleindex + 1)
            if index is None:
                return
            candidate = self.node[index]
        else:
            biblioindex = 0
            titleindex = None
        if isinstance(candidate, nodes.field_list):
            bibliographic, remainder = self.extractbibliographic(candidate,
                                                                 titleindex)
            if remainder:
                self.node[index] = remainder
            else:
                del self.node[index]
            self.node[biblioindex:biblioindex] = bibliographic

    def extractbibliographic(self, field_list, titleindex):
        nodelist = []
        remainder = []
        bibliofields = self.language.bibliographic_fields
        abstract = None
        title = titleindex is not None
        subtitle = None
        for field in field_list:
            try:
                name = field[0][0].astext()
                normedname = normname(name)
                if not (len(field) == 2 and bibliofields.has_key(normedname)
                        and self.checkemptybibliofield(field, name)):
                    raise TransformationError
                biblioclass = bibliofields[normedname]
                if issubclass(biblioclass, nodes._TextElement):
                    if not self.checkcompoundbibliofield(field, name):
                        raise TransformationError
                    self.filterrcskeywords(field[1][0])
                    if issubclass(biblioclass, nodes.title):
                        self.extracttitle(field, name, title, nodelist)
                        title = 1
                    elif issubclass(biblioclass, nodes.subtitle):
                        self.extractsubtitle(field, name, subtitle, title,
                                             nodelist)
                        subtitle = 1
                    else:
                        nodelist.append(biblioclass('', '', *field[1][0]))
                else:                   # multiple body elements possible
                    if issubclass(biblioclass, nodes.authors):
                        self.extractauthors(field, name, nodelist)
                    elif issubclass(biblioclass, nodes.abstract):
                        if abstract:
                            field[-1] += self.memo.reporter.error(
                                  'There can only be one abstract.')
                            raise TransformationError
                        abstract = nodes.abstract('', *field[1].children)
                    else:
                        nodelist.append(biblioclass('', *field[1].children))
            except TransformationError:
                remainder.append(field)
                continue
        if remainder:
            field_list[:] = remainder
        else:
            field_list = None
        if abstract:
            nodelist.append(abstract)
        return nodelist, field_list

    def checkemptybibliofield(self, field, name):
        if len(field[1]) < 1:
            field[-1] += self.memo.reporter.error(
                  'Cannot extract empty bibliographic field "%s".' % name)
            return None
        return 1

    def checkcompoundbibliofield(self, field, name):
        if len(field[1]) > 1:
            field[-1] += self.memo.reporter.error(
                  'Cannot extract compound bibliographic field "%s".' % name)
            return None
        if not isinstance(field[1][0], nodes.paragraph):
            field[-1] += self.memo.reporter.error(
                  'Cannot extract bibliographic field "%s" containing anything '
                  'other than a single paragraph.'
                  % name)
            return None
        return 1

    def extracttitle(self, field, name, title, nodelist):
        if title:
            field[-1] += self.memo.reporter.error(
                  'Multiple document titles (bibliographic field "%s").'
                  % name)
            raise TransformationError
        nodelist.insert(0, nodes.title('', '', *field[1][0].children))

    def extractsubtitle(self, field, name, subtitle, title, nodelist):
        if not title:
            field[-1] += self.memo.reporter.error(
                  'Subtitle must appear after a title (bibliographic field "%s").'
                  % name)
            raise TransformationError
        if subtitle:
            field[-1] += self.memo.reporter.error(
                  'Multiple document subtitles (bibliographic field "%s").'
                  % name)
            raise TransformationError
        nodelist.insert(1, nodes.subtitle('', '', *field[1][0].children))

    rcskeywordsubstitutions = [
          (re.compile(r'\$' r'Date: (\d\d\d\d)/(\d\d)/(\d\d) [\d:]+ \$$',
                      re.IGNORECASE), r'\1-\2-\3'),
          (re.compile(r'\$' r'RCSfile: (.+),v \$$',
                      re.IGNORECASE), r'\1'),
          (re.compile(r'\$[a-zA-Z]+: (.+) \$$'), r'\1'),]

    def filterrcskeywords(self, paragraph):
        if len(paragraph) == 1 and isinstance(paragraph[0], nodes.Text):
            textnode = paragraph[0]
            for pattern, substitution in self.rcskeywordsubstitutions:
                match = pattern.match(textnode.data)
                if match:
                    textnode.data = pattern.sub(substitution, textnode.data)
                    return

    def extractauthors(self, field, name, nodelist):
        try:
            if len(field[1]) == 1:
                if isinstance(field[1][0], nodes.paragraph):
                    authors = self.authorsfrom1paragraph(field)
                elif isinstance(field[1][0], nodes.bullet_list):
                    authors = self.authorsfrombulletlist(field)
                else:
                    raise TransformationError
            else:
                authors = self.authorsfromparagraphs(field)
            authornodes = [nodes.author('', '', *author)
                           for author in authors if author]
            nodelist.append(nodes.authors('', *authornodes))
        except TransformationError:
            field[-1] += self.memo.reporter.error(
                  'Bibliographic field "%s" incompatible with extraction: '
                  'it must contain either a single paragraph (with authors '
                  'separated by one of "%s"), multiple paragraphs (one per '
                  'author), or a bullet list with one paragraph (one author) '
                  'per item.'
                  % (name, ''.join(self.language.author_separators)))
            raise

    def authorsfrom1paragraph(self, field):
        text = field[1][0].astext().strip()
        if not text:
            raise TransformationError
        for authorsep in self.language.author_separators:
            authornames = text.split(authorsep)
            if len(authornames) > 1:
                break
        authornames = [author.strip() for author in authornames]
        authors = [[nodes.Text(author)] for author in authornames]
        return authors

    def authorsfrombulletlist(self, field):
        authors = []
        for item in field[1][0]:
            if len(item) != 1 or not isinstance(item[0], nodes.paragraph):
                raise TransformationError
            authors.append(item[0].children)
        if not authors:
            raise TransformationError
        return authors

    def authorsfromparagraphs(self, field):
        for item in field[1]:
            if not isinstance(item, nodes.paragraph):
                raise TransformationError
        authors = [item.children for item in field[1]]
        return authors
@


1.22
log
@  - Completed RCS keyword filtering (including fixes so the regexps    themselves aren't recognized as RCS keywords).
@
text
@d4 2
a5 2
:Revision: $Revision: 1.21 $
:Date: $Date: 2001/09/18 04:37:36 $
d221 2
a222 2
                if len(field) != 2 or not bibliofields.has_key(normedname) \
                      or self.checkemptybibliofield(field, name):
d226 1
a226 1
                    if self.checkcompoundbibliofield(field, name):
d228 1
a228 1
                    self.filterrcskeywords(field[1][0][0])
d237 1
a237 1
                        nodelist.append(biblioclass('', '', field[1][0][0]))
d264 2
a265 2
            return 1
        return None
d271 2
a272 4
            return 1
        if not isinstance(field[1][0], nodes.paragraph) \
              or len(field[1][0]) != 1 \
              or not isinstance(field[1][0][0], nodes.Text):
d275 1
a275 1
                  'other than a simple, unformatted paragraph.'
d277 2
a278 2
            return 1
        return None
d308 8
a315 6
    def filterrcskeywords(self, textnode):
        for pattern, substitution in self.rcskeywordsubstitutions:
            match = pattern.match(textnode.data)
            if match:
                textnode.data = pattern.sub(substitution, textnode.data)
                break
@


1.21
log
@  - RCS keyword handling in blibliographic field lists, almost done.  - A little more refactoring.
@
text
@d4 2
a5 2
:Revision: $Revision: 1.20 $
:Date: $Date: 2001/09/17 04:24:20 $
d210 1
a210 1
    def extractbibliographic(self, field_list, title):
d215 2
d228 1
d232 4
a235 2
                    # XXX handle subtitle too
                    # XXX extractrcskeywords for title (& subtitle) too?
d237 1
a237 5
                        contents = field[1][0].children
                        if len(contents) == 1 and isinstance(contents[0],
                                                             nodes.Text):
                            contents = [self.extractrcskeywords(contents[0])]
                        nodelist.append(biblioclass('', '', *contents))
d270 1
a270 2
                  'Cannot extract compound title bibliographic '
                  'field "%s".' % name)
d272 3
a274 1
        if not isinstance(field[1][0], nodes.paragraph):
d276 2
a277 2
                  'Cannot extract bibliographic field "%s" '
                  'containing anything other than a simple paragraph.'
d283 1
a283 1
        if title is not None:
d290 13
d304 1
a304 1
          (re.compile(r'^\$Date: (\d\d\d\d)/(\d\d)/(\d\d) [\d:]+ \$$',
d306 1
a306 1
          (re.compile(r'^\$RCSfile: (.+),v \$$',
d308 1
a308 1
          (re.compile(r'^\$[a-zA-Z]+: (.+) \$$'), r'\1'),]
d310 1
a310 1
    def extractrcskeywords(self, textnode):
a315 1
        return textnode
@


1.20
log
@  - More mild refactoring.  - Updated: 'errorist' -> 'reporter'.
@
text
@d4 2
a5 2
:Revision: $Revision: 1.19 $
:Date: $Date: 2001/09/13 22:32:37 $
d226 1
a226 1
                    if biblioclass is nodes.title:
d229 2
d232 7
a238 4
                        nodelist.append(biblioclass('', '',
                                                    *field[1][0].children))
                else:
                    if biblioclass is nodes.authors:
d240 1
a240 1
                    elif biblioclass is nodes.abstract:
d288 15
d477 1
a477 3
                sw = memo.reporter.severe(
                      'Title level inconsistent at line %s:' % lineno, source)
                self.statemachine.node += sw
d487 1
a487 3
            sw = memo.reporter.severe(
                  'Title level inconsistent at line %s:' % lineno, source)
            self.statemachine.node += sw
d489 7
@


1.19
log
@  - Mild refactoring: meaningful variable names, extracted common    code to methods.  - Removed debug code.Ran 219 tests: OK
@
text
@d4 2
a5 2
:Revision: $Revision: 1.18 $
:Date: $Date: 2001/09/13 02:25:32 $
d147 2
a148 2
        errorist = utils.Errorist(warninglevel, errorlevel)
        docroot = nodes.document(errorist)
d150 1
a150 1
                          errorist=errorist,
d237 1
a237 1
                            field[-1] += self.memo.errorist.error(
d256 1
a256 1
            field[-1] += self.memo.errorist.error(
d263 1
a263 1
            field[-1] += self.memo.errorist.error(
d268 1
a268 1
            field[-1] += self.memo.errorist.error(
d277 1
a277 1
            field[-1] += self.memo.errorist.error(
d298 1
a298 1
            field[-1] += self.memo.errorist.error(
d457 2
a458 3
                sw = memo.errorist.strong_system_warning(
                      'ABORT', 'Title level inconsistent at line %s:' % lineno,
                      source)
d469 2
a470 3
            sw = memo.errorist.strong_system_warning(
                  'ABORT', 'Title level inconsistent at line %s:' % lineno,
                  source)
d668 1
a668 1
        sw = self.statemachine.memo.errorist.warning(
d703 1
a703 1
                    sw = self.statemachine.memo.errorist.warning(
d716 1
a716 1
        sw = self.statemachine.memo.errorist.warning(
d732 1
a732 1
                sw = self.statemachine.memo.errorist.warning(
d858 1
a858 1
        return self.statemachine.memo.errorist.warning(
d988 1
a988 1
            sw = self.statemachine.memo.errorist.error(
d1001 1
a1001 1
            sw = self.statemachine.memo.errorist.information(
d1121 1
a1121 1
            sw = self.statemachine.memo.errorist.error(
d1199 1
a1199 1
            sw = self.statemachine.memo.errorist.warning(
d1227 1
a1227 1
            warnings.append(self.statemachine.memo.errorist.error(
d1262 1
a1262 1
        nodelist = [self.statemachine.memo.errorist.error(message),
d1347 1
d1349 5
a1353 11
        block = self.statemachine.gettextblock()
        reference = unescape(targetmatch.string[targetmatch.end():], 1).strip()
        blankfinish = 1
        for i in range(1,len(block)):
            if block[i][:1] != ' ':
                blankfinish = 0
                self.statemachine.previousline(len(block) - i)
                del block[i:]
                break
            reference += block[i].strip()
        blocktext = '\n'.join(block)
d1356 1
a1356 1
            warning = self.statemachine.memo.errorist.warning(
d1392 1
a1392 1
        error = self.statemachine.memo.errorist.error(
d1401 3
a1403 8
        if not match.string[match.end():].strip(): # text on first line?
            try:                        # no
                if self.statemachine.nextline().strip(): # text on next line?
                    self.statemachine.previousline() # yes; it's not empty
                else:                   # yes; it's an empty comment
                    raise IndexError
            except IndexError:          # "A tiny but practical wart."
                return [nodes.comment()], 1
d1461 1
a1461 1
                          self.statemachine.memo.errorist.warning(
d1472 1
a1472 1
            sw = self.statemachine.memo.errorist.severe(
d1481 1
a1481 1
            sw = self.statemachine.memo.errorist.severe(
d1489 1
a1489 1
            sw = self.statemachine.memo.errorist.severe(
d1494 1
a1494 1
            sw = self.statemachine.memo.errorist.severe(
d1502 1
a1502 1
                  self.statemachine.memo.errorist.information(
d1681 1
a1681 1
            sw = self.statemachine.memo.errorist.severe(
d1690 1
a1690 1
                  self.statemachine.memo.errorist.information(
d1705 1
a1705 1
            sw = self.statemachine.memo.errorist.error(
d1713 1
a1713 1
                line = self.statemachine.nextline()
d1730 1
a1730 1
            nodelist.append(self.statemachine.memo.errorist.warning(
d1746 1
a1746 1
            definition += self.statemachine.memo.errorist.information(
@


1.18
log
@  - Extracted TableParser & update_dictoflists() to tableparser.py.  - Improved directive name recognition.  - Changed indentSM to nestedSM where appropriate.
@
text
@d4 2
a5 2
:Revision: $Revision: 1.17 $
:Date: $Date: 2001/09/12 03:54:33 $
d62 3
a64 3
   B. Others trigger the creation of a subordinate state machine, whose job is
      to parse a compound construct ('indent' for a block quote, 'bullet' for
      a bullet list, 'overline' for a section [first checking for a valid
d77 1
a77 1
        inter-element blank lines is also handled.
d128 3
a130 1
    reStructuredText's customized StateMachine.
d142 3
a144 1
        Extend `StateMachineWS.run()`: set up document-wide data.
a177 1
        #print >>sys.stderr, 'promotelonesection:\n\tcandidate[0]=%r\n\tself.node[:index]=%r\n\tcandidate[1:]=%r' % (candidate[0], self.node[:index], candidate[1:])
d187 1
a187 1
        index = getfirstnoncomment(self.node)
d194 1
a194 2
            index = getfirstnoncomment(
                  self.node[titleindex + 1:])
a196 1
            index += titleindex + 1
a200 1
        #print >>sys.stderr, 'dofirstfields: candidate=%r' % candidate
a212 2
        #print >>sys.stderr, 'extractbibliographic: self.language=%r' % (self.language,)
        #print >>sys.stderr, 'extractbibliographic: dir(self.language)=%r' % (dir(self.language),)
d230 2
a231 1
                        nodelist.append(biblioclass('', '', *field[1][0].children))
a336 7
def getfirstnoncomment(nodelist):
    for index in range(len(nodelist)):
        if not isinstance(nodelist[index], nodes.comment):
            return index
    return None


d340 2
a341 1
    reStructuredText's customized StateMachine.
a350 2
        if self.debug:
            print >>sys.stderr, ('\nNestedStateMachine.run: node=%r' % node)
d354 1
a354 1
        assert results == [], 'NestedStateMachine.run() results should be empty.'
d360 5
a364 1
    """reStructuredText State superclass."""
d373 7
d381 1
d384 1
a384 1
    def nestedparse(self, block, lineoffset, node, matchtitles=0,
d386 4
d395 28
a422 3
        statemachine.run(
              block, inputoffset=lineoffset, memo=self.statemachine.memo,
              node=node, matchtitles=matchtitles)
d424 1
a454 4
                if self.debug:
                    print >>sys.stderr, ('\nstates.RSTState.checksubsection: '
                                         'mylevel=%s, new level=%s (new)'
                                         % (mylevel, len(titlestyles)))
a461 4
        if self.debug:
            print >>sys.stderr, ('\nstates.RSTState.checksubsection: '
                                 'mylevel=%s, new level=%s (exists)'
                                 % (mylevel, level))
d481 2
a482 5
        if self.debug:
            print >>sys.stderr, ('\nstates.RSTState.newsubsection: starting a '
                                 'new subsection (level %s)' % (mylevel + 1))
        s = nodes.section()
        self.statemachine.node += s
d485 3
a487 4
        s += titlenode
        s += warnings
        memo.document.addimplicitlink(normname(titlenode.astext()), s)
        sm = self.nestedSM(debug=self.debug, **self.nestedSMkwargs)
d490 4
a493 14
        sm.run(self.statemachine.inputlines[offset:], inputoffset=absoffset,
               memo=memo, node=s, matchtitles=1)
        sm.unlink()
        if self.debug:
            print >>sys.stderr, ('\nstates.RSTState.newsubsection: back from '
                                 'subsection (mylevel=%s, new level=%s)'
                                 % (mylevel,
                                    memo.sectionlevel))
            print >>sys.stderr, ('                       sm.abslineoffset=%s'
                                 % sm.abslineoffset())
        try:
            self.statemachine.gotoline(sm.abslineoffset())
        except IndexError:
            pass
a515 2
        #print >>sys.stderr, ('paragraph: data=%r, textnodes=%r, warnings=%r'
        #                         % (data, textnodes, warnings))
a634 2
    #print >>sys.stderr, '`RSTState.inline.patterns.uri.pattern`=\n%r' % inline.patterns.uri.pattern
    #print >>sys.stderr, 'RSTState.inline.patterns.uri.pattern=\n%s' % inline.patterns.uri.pattern
a694 1
            #print >>sys.stderr, 'interpreted_or_phrase_link: role=%r, position=%r' % (role, position)
a784 1
            #print >>sys.stderr, 'RSTState.standalone_uri: remainder=%r' % remainder
a786 1
                #print >>sys.stderr, 'RSTState.standalone_uri: match.groups=%r, match.span(1)=%r' % (match.groups(), match.span(1))
d949 2
a950 5
        if self.debug:
            print >>sys.stderr, ('\nstates.Body.indent (block_quote): '
                                 'indented=%r' % indented)
        bq = self.block_quote(indented, lineoffset)
        self.statemachine.node += bq
d956 3
a958 6
        bq = nodes.block_quote()
        sm = self.indentSM(debug=self.debug, **self.indentSMkwargs)
        sm.run(indented, inputoffset=lineoffset,
               memo=self.statemachine.memo, node=bq, matchtitles=0)
        sm.unlink()
        return bq
d962 3
a964 3
        l = nodes.bullet_list()
        self.statemachine.node += l
        l['bullet'] = match.string[0]
d966 1
a966 1
        l += i
d968 6
a973 8
        kwargs = self.nestedSMkwargs.copy()
        kwargs['initialstate'] = 'BulletList'
        sm = self.nestedSM(debug=self.debug, **kwargs)
        sm.states['BulletList'].blankfinish = blankfinish
        sm.run(self.statemachine.inputlines[offset:],
               inputoffset=self.statemachine.abslineoffset() + 1,
               memo=self.statemachine.memo, node=l, matchtitles=0)
        if not sm.states['BulletList'].blankfinish:
d975 1
a975 5
        sm.unlink()
        try:
            self.statemachine.gotoline(sm.abslineoffset())
        except IndexError:
            pass
d981 1
a981 6
        if self.debug:
            print >>sys.stderr, ('\nstates.Body.list_item: blankfinish=%r'
                                 % blankfinish)
            print >>sys.stderr, ('\nstates.Body.list_item: indented=%r'
                                 % indented)
        i = nodes.list_item('\n'.join(indented))
d983 2
a984 5
            sm = self.indentSM(debug=self.debug, **self.indentSMkwargs)
            sm.run(indented, inputoffset=lineoffset,
                   memo=self.statemachine.memo, node=i, matchtitles=0)
            sm.unlink()
        return i, blankfinish
a988 1
        #print >>sys.stderr, 'Body.enumerated: format=%r, sequence=%r, text=%r, ordinal=%r' % (format, sequence, text, ordinal)
d1008 8
a1015 8
        l = nodes.enumerated_list()
        self.statemachine.node += l
        l['enumtype'] = sequence
        l['start'] = text
        l['prefix'] = self.enum.formatinfo[format].prefix
        l['suffix'] = self.enum.formatinfo[format].suffix
        i, blankfinish = self.list_item(match.end())
        l += i
d1017 7
a1023 10
        kwargs = self.nestedSMkwargs.copy()
        kwargs['initialstate'] = 'EnumeratedList'
        sm = self.nestedSM(debug=self.debug, **kwargs)
        sm.states['EnumeratedList'].blankfinish = blankfinish
        sm.states['EnumeratedList'].lastordinal = ordinal
        sm.states['EnumeratedList'].format = format
        sm.run(self.statemachine.inputlines[offset:],
               inputoffset=self.statemachine.abslineoffset() + 1,
               memo=self.statemachine.memo, node=l, matchtitles=0)
        if not sm.states['EnumeratedList'].blankfinish:
d1025 1
a1025 5
        sm.unlink()
        try:
            self.statemachine.gotoline(sm.abslineoffset())
        except IndexError:
            pass
d1080 4
a1083 4
        l = nodes.field_list()
        self.statemachine.node += l
        f, blankfinish = self.field(match)
        l += f
d1085 6
a1090 8
        kwargs = self.nestedSMkwargs.copy()
        kwargs['initialstate'] = 'FieldList'
        sm = self.nestedSM(debug=self.debug, **kwargs)
        sm.states['FieldList'].blankfinish = blankfinish
        sm.run(self.statemachine.inputlines[offset:],
               inputoffset=self.statemachine.abslineoffset() + 1,
               memo=self.statemachine.memo, node=l, matchtitles=0)
        if not sm.states['FieldList'].blankfinish:
d1092 1
a1092 5
        sm.unlink()
        try:
            self.statemachine.gotoline(sm.abslineoffset())
        except IndexError:
            pass
d1099 2
a1100 5
        if self.debug:
            print >>sys.stderr, ('\nstates.Body.field_list_item: indented=%r'
                                 % indented)
        f = nodes.field()
        f += nodes.field_name(name, name)
d1102 3
a1104 3
            f += nodes.field_argument(arg, arg)
        b = nodes.field_body('\n'.join(indented))
        f += b
d1106 2
a1107 5
            sm = self.indentSM(debug=self.debug, **self.indentSMkwargs)
            sm.run(indented, inputoffset=lineoffset,
                   memo=self.statemachine.memo, node=b, matchtitles=0)
            sm.unlink()
        return f, blankfinish
d1118 2
a1119 2
        l = nodes.option_list()
        self.statemachine.node += l
d1121 1
a1121 1
            i, blankfinish = self.option_list_item(match)
d1129 2
a1130 2
            bq = self.block_quote(indented, lineoffset)
            self.statemachine.node += bq
d1134 1
a1134 1
        l += i
d1136 6
a1141 8
        kwargs = self.nestedSMkwargs.copy()
        kwargs['initialstate'] = 'OptionList'
        sm = self.nestedSM(debug=self.debug, **kwargs)
        sm.states['OptionList'].blankfinish = blankfinish
        sm.run(self.statemachine.inputlines[offset:],
               inputoffset=self.statemachine.abslineoffset() + 1,
               memo=self.statemachine.memo, node=l, matchtitles=0)
        if not sm.states['OptionList'].blankfinish:
d1143 1
a1143 5
        sm.unlink()
        try:
            self.statemachine.gotoline(sm.abslineoffset())
        except IndexError:
            pass
d1150 3
a1152 6
        if self.debug:
            print >>sys.stderr, ('\nstates.Body.option_list_item: indented=%r'
                                 % indented)
        i = nodes.option_list_item('', *options)
        d = nodes.description('\n'.join(indented))
        i += d
d1154 2
a1155 5
            sm = self.indentSM(debug=self.debug, **self.indentSMkwargs)
            sm.run(indented, inputoffset=lineoffset,
                   memo=self.statemachine.memo, node=d, matchtitles=0)
            sm.unlink()
        return i, blankfinish
d1166 1
a1166 1
            o = nodes.option(optionstring)
d1177 1
a1177 1
                    o += nodes.long_option(tokens[0], tokens[0])
d1179 1
a1179 1
                    o += nodes.short_option(tokens[0], tokens[0])
d1181 1
a1181 1
                    o += nodes.vms_option(tokens[0], tokens[0])
d1183 2
a1184 2
                    o += nodes.option_argument(tokens[1], tokens[1])
                optlist.append(o)
d1214 2
a1215 2
                t = self.buildtable(tabledata, tableline)
                nodelist = [t] + warnings
d1299 3
a1301 4
            sm = self.nestedSM(debug=self.debug, **self.nestedSMkwargs)
            sm.run(cellblock, inputoffset=tableline+offset,
                   memo=self.statemachine.memo, node=entry, matchtitles=0)
            sm.unlink()
d1329 1
a1329 1
        f = nodes.footnote('\n'.join(indented))
d1332 1
a1332 1
            self.statemachine.memo.document.addautofootnote(name, f)
d1334 1
a1334 1
            f += nodes.label('', label)
d1336 1
a1336 1
            self.statemachine.memo.document.addimplicitlink(name, f)
d1338 2
a1339 5
            sm = self.indentSM(debug=self.debug, **self.indentSMkwargs)
            sm.run(indented, inputoffset=offset,
                   memo=self.statemachine.memo, node=f, matchtitles=0)
            sm.unlink()
        return [f], blankfinish
d1361 1
d1363 1
a1363 1
            t = self.statemachine.memo.errorist.warning(
d1367 2
a1368 1
            t += nodes.literal_block(blocktext, blocktext)
d1370 1
a1370 1
            t = nodes.target(blocktext, reference)
d1373 1
a1373 1
                      name, reference, t, self.statemachine.node)
d1376 3
a1378 2
                      name, t, self.statemachine.node)
        return [t], blankfinish
d1452 6
a1457 9
        kwargs = self.nestedSMkwargs.copy()
        kwargs['initialstate'] = 'Explicit'
        sm = self.nestedSM(debug=self.debug, **kwargs)
        sm.states['Explicit'].blankfinish = blankfinish
        sm.run(self.statemachine.inputlines[offset:],
               inputoffset=self.statemachine.abslineoffset() + 1,
               memo=self.statemachine.memo, node=self.statemachine.node,
               matchtitles=0)
        if not sm.states['Explicit'].blankfinish:
d1459 1
a1459 5
        sm.unlink()
        try:
            self.statemachine.gotoline(sm.abslineoffset())
        except IndexError:
            pass
d1561 2
a1562 2
        i, blankfinish = self.list_item(match.end())
        self.statemachine.node += i
d1589 2
a1590 2
        i, blankfinish = self.list_item(match.end())
        self.statemachine.node += i
d1602 2
a1603 2
        f, blankfinish = self.field(match)
        self.statemachine.node += f
d1615 1
a1615 1
            i, blankfinish = self.option_list_item(match)
d1618 1
a1618 1
        self.statemachine.node += i
d1656 3
a1658 3
        p, literalnext = self.paragraph(context,
                                        self.statemachine.abslineno() - 1)
        self.statemachine.node += p
d1665 3
a1667 7
            p, literalnext = self.paragraph(context,
                                            self.statemachine.abslineno() - 1)
            if self.debug:
                print >>sys.stderr, ('\nstates.Text.eof: context=%r, p=%r, '
                                     'node=%r' % (context, p,
                                                  self.statemachine.node))
            self.statemachine.node += p
d1674 4
a1677 4
        l = nodes.definition_list()
        i, blankfinish = self.definition_list_item(context)
        l += i
        self.statemachine.node += l
d1679 6
a1684 8
        kwargs = self.nestedSMkwargs.copy()
        kwargs['initialstate'] = 'DefinitionList'
        sm = self.nestedSM(debug=self.debug, **kwargs)
        sm.states['Definition'].blankfinish = blankfinish
        sm.run(self.statemachine.inputlines[offset:],
               inputoffset=self.statemachine.abslineoffset() + 1,
               memo=self.statemachine.memo, node=l, matchtitles=0)
        if not sm.states['Definition'].blankfinish:
d1686 1
a1686 5
        sm.unlink()
        try:
            self.statemachine.gotoline(sm.abslineoffset())
        except IndexError:
            pass
a1699 5
        if self.debug:
            print >>sys.stderr, ('\nstates.Text.underline: context=%r, '
                                 'match.string=%r, title=%r, titlestyles=%r'
                                 % (context, match.string, title,
                                    self.statemachine.memo.titlestyles))
d1720 2
a1721 6
        if self.debug:
            print >>sys.stderr, 'states.Text.text: lines=%r' % lines
        p, literalnext = self.paragraph(lines, startline)
        if self.debug:
            print >>sys.stderr, 'states.Text.text: p=%r' % p
        self.statemachine.node += p
d1750 7
a1756 7
        if self.debug:
            print >>sys.stderr, ('\nstates.Text.indent (definition): indented=%r'
                                 % indented)
        i = nodes.definition_list_item('\n'.join(termline + indented))
        t, warnings = self.term(termline, self.statemachine.abslineno() - 1)
        i += t
        d = nodes.definition('', *warnings)
d1758 1
a1758 1
            d += self.statemachine.memo.errorist.information(
d1761 2
a1762 6
        sm = self.indentSM(debug=self.debug, **self.indentSMkwargs)
        sm.run(indented, inputoffset=lineoffset,
               memo=self.statemachine.memo, node=d, matchtitles=0)
        sm.unlink()
        i += d
        return i, blankfinish
d1810 2
a1811 2
        i, blankfinish = self.definition_list_item(context)
        self.statemachine.node += i
@


1.17
log
@  - Added RSTState.nestedparse().  - Completed directives implementation.
@
text
@d4 2
a5 2
:Revision: $Revision: 1.16 $
:Date: $Date: 2001/09/10 04:32:48 $
a24 1
    - `TableParser`: Parses tables.
d105 1
d371 1
a371 1
    indentSM = NestedStateMachine
d374 1
a374 1
        self.indentSMkwargs = {'stateclasses': stateclasses,
d384 1
a384 1
            statemachineclass = self.indentSM
d386 1
a386 1
            statemachinekwargs = self.indentSMkwargs
d466 1
a466 1
        sm = self.indentSM(debug=self.debug, **self.indentSMkwargs)
a860 180
class TableParser:

    """
    Parse a table structure using `parse()`
    """

    headbodyseparatorpat = re.compile(r'\+=[=+]+=\+$')

    def init(self, block):
        self.block = block[:]           # make a copy; it may be modified
        self.bottom = len(block) - 1
        self.right = len(block[0]) - 1
        self.headbodysep = None
        self.done = [-1] * len(block[0])
        self.cells = []
        self.rowseps = {0: [0]}
        self.colseps = {0: [0]}

    def parse(self, block):
        self.init(block)
        self.findheadbodysep()
        self.parsegrid()
        structure = self.structurefromcells()
        return structure

    def findheadbodysep(self):
        for i in range(len(self.block)):
            line = self.block[i]
            if self.headbodyseparatorpat.match(line):
                if self.headbodysep:
                    raise MarkupError, ('Multiple head/body row separators '
                          'in table (at line offset %s and %s); only one '
                          'allowed.' % (self.headbodysep, i))
                else:
                    self.headbodysep = i
                    self.block[i] = line.replace('=', '-')

    def parsegrid(self):
        corners = [(0, 0)]
        while corners:
            top, left = corners.pop(0)
            if top == self.bottom or left == self.right \
                  or top <= self.done[left]:
                continue
            result = self.scancell(top, left)
            if not result:
                continue
            bottom, right, rowseps, colseps = result
            update_dictoflists(self.rowseps, rowseps)
            update_dictoflists(self.colseps, colseps)
            self.markdone(top, left, bottom, right)
            cellblock = self.getcellblock(top, left, bottom, right)
            self.cells.append((top, left, bottom, right, cellblock))
            corners.extend([(top, right), (bottom, left)])
            corners.sort()
        if not self.checkparsecomplete():
            raise MarkupError, 'Malformed table; parse incomplete.'

    def markdone(self, top, left, bottom, right):
        before = top - 1
        after = bottom - 1
        for col in range(left, right):
            assert self.done[col] == before
            self.done[col] = after

    def checkparsecomplete(self):
        last = self.bottom - 1
        for col in range(self.right):
            if self.done[col] != last:
                return None
        return 1

    def getcellblock(self, top, left, bottom, right):
        cellblock = []
        margin = right
        for lineno in range(top + 1, bottom):
            line = self.block[lineno][left + 1 : right].rstrip()
            cellblock.append(line)
            if line:
                margin = margin and min(margin, len(line) - len(line.lstrip()))
        if 0 < margin < right:
            cellblock = [line[margin:] for line in cellblock]
        return cellblock

    def scancell(self, top, left):
        assert self.block[top][left] == '+'
        result = self.scanright(top, left)
        return result

    def scanright(self, top, left):
        colseps = {}
        line = self.block[top]
        for i in range(left + 1, self.right + 1):
            if line[i] == '+':
                colseps[i] = [top]
                result = self.scandown(top, left, i)
                if result:
                    bottom, rowseps, newcolseps = result
                    update_dictoflists(colseps, newcolseps)
                    return bottom, i, rowseps, colseps
            elif line[i] != '-':
                return None
        return None

    def scandown(self, top, left, right):
        rowseps = {}
        for i in range(top + 1, self.bottom + 1):
            if self.block[i][right] == '+':
                rowseps[i] = [right]
                result = self.scanleft(top, left, i, right)
                if result:
                    newrowseps, colseps = result
                    update_dictoflists(rowseps, newrowseps)
                    return i, rowseps, colseps
            elif self.block[i][right] != '|':
                return None
        return None

    def scanleft(self, top, left, bottom, right):
        colseps = {}
        line = self.block[bottom]
        for i in range(right - 1, left, -1):
            if line[i] == '+':
                colseps[i] = [bottom]
            elif line[i] != '-':
                return None
        if line[left] != '+':
            return None
        result = self.scanup(top, left, bottom, right)
        if result is not None:
            rowseps = result
            return rowseps, colseps
        return None

    def scanup(self, top, left, bottom, right):
        rowseps = {}
        for i in range(bottom - 1, top, -1):
            if self.block[i][left] == '+':
                rowseps[i] = [left]
            elif self.block[i][left] != '|':
                return None
        return rowseps

    def structurefromcells(self):
        rowseps = self.rowseps.keys()
        rowseps.sort()
        rowindex = {}
        for i in range(len(rowseps)):
            rowindex[rowseps[i]] = i
        colseps = self.colseps.keys()
        colseps.sort()
        colindex = {}
        for i in range(len(colseps)):
            colindex[colseps[i]] = i
        colspecs = [(colseps[i] - colseps[i - 1] - 1)
                    for i in range(1, len(colseps))]
        onerow = [None for i in range(len(colseps) - 1)]
        rows = [onerow[:] for i in range(len(rowseps) - 1)]
        remaining = (len(rowseps) - 1) * (len(colseps) - 1)
        for top, left, bottom, right, block in self.cells:
            rownum = rowindex[top]
            colnum = colindex[left]
            assert rows[rownum][colnum] is None, \
                  'Cell (row %s, column %s) already used.' % (rownum + 1,
                                                              colnum + 1)
            morerows = rowindex[bottom] - rownum - 1
            morecols = colindex[right] - colnum - 1
            remaining -= (morerows + 1) * (morecols + 1)
            rows[rownum][colnum] = (morerows, morecols, top + 1, block)
        assert remaining == 0, 'Unused cells remaining.'
        if self.headbodysep:
            numheadrows = rowindex[self.headbodysep]
            headrows = rows[:numheadrows]
            bodyrows = rows[numheadrows:]
        else:
            headrows = []
            bodyrows = rows
        return (colspecs, headrows, bodyrows)


d970 1
a970 1
        kwargs = self.indentSMkwargs.copy()
d972 1
a972 1
        sm = self.indentSM(debug=self.debug, **kwargs)
d1034 1
a1034 1
        kwargs = self.indentSMkwargs.copy()
d1036 1
a1036 1
        sm = self.indentSM(debug=self.debug, **kwargs)
d1109 1
a1109 1
        kwargs = self.indentSMkwargs.copy()
d1111 1
a1111 1
        sm = self.indentSM(debug=self.debug, **kwargs)
d1172 1
a1172 1
        kwargs = self.indentSMkwargs.copy()
d1174 1
a1174 1
        sm = self.indentSM(debug=self.debug, **kwargs)
d1264 1
a1264 1
            except MarkupError, detail:
d1347 1
a1347 1
            sm = self.indentSM(debug=self.debug, **self.indentSMkwargs)
d1491 1
a1491 1
                      ([\w-]+)          # directive name
d1494 1
a1494 1
                      """, re.VERBOSE))]
d1501 1
a1501 1
        kwargs = self.indentSMkwargs.copy()
d1503 1
a1503 1
        sm = self.indentSM(debug=self.debug, **kwargs)
d1739 1
a1739 1
        kwargs = self.indentSMkwargs.copy()
d1741 1
a1741 1
        sm = self.indentSM(debug=self.debug, **kwargs)
a1922 4

def update_dictoflists(master, newdata):
    for key, values in newdata.items():
        master.setdefault(key, []).extend(values)
@


1.16
log
@  - Name changes (lowercased, updated, improved).  - Integer attributes on elements as appropriate.  - Beginnings of directive functionality.
@
text
@d4 2
a5 2
:Revision: $Revision: 1.15 $
:Date: $Date: 2001/09/07 01:35:08 $
d381 12
d1610 25
a1634 23
        # XXX need to actually *do* something with the directive
        type = match.group(1)
        try:
            directivefunction = directives.directive(
                  type, self.statemachine.memo.language)
        except Exception, detail:
            print >>sys.stderr, '%s: %s' % (detail.__class__.__name__, detail)
        atts = {'type': type}
        data = match.string[match.end():].strip()
        if data:
            atts['data'] = data
        try:
            self.statemachine.nextline()
            indented, indent, offset, blankfinish = \
                  self.statemachine.getindented()
            text = '\n'.join(indented)
        except IndexError:
            text = ''
            blankfinish = 1
        children = []
        if text:
            children.append(nodes.literal_block(text, text))
        return [nodes.directive(text, *children, **atts)], blankfinish
@


1.15
log
@  - Added TransformationError exception.  - Split off NestedStateMachine (recursive) from RSTStateMachine    (entry point).  - Added language module support.  - Added 1-section -> document promotion transformation.  - Added bibliographic field list transformations.  - Numbered errorist.system_warning calls -> named methods.
@
text
@d4 2
a5 2
:Revision: $Revision: 1.14 $
:Date: $Date: 2001/09/05 02:49:04 $
d99 3
d105 1
d215 1
a215 1
        bibliofields = self.language.parser.bibliofields
d305 1
a305 1
                  % (name, ''.join(self.language.parser.authorseps)))
d312 1
a312 1
        for authorsep in self.language.parser.authorseps:
d855 1
a855 1
    headBodySeparatorPat = re.compile(r'\+=[=+]+=\+$')
d871 1
a871 1
        structure = self.structureFromCells()
d877 1
a877 1
            if self.headBodySeparatorPat.match(line):
d897 2
a898 2
            updateDictOfLists(self.rowseps, rowseps)
            updateDictOfLists(self.colseps, colseps)
d947 1
a947 1
                    updateDictOfLists(colseps, newcolseps)
d961 1
a961 1
                    updateDictOfLists(rowseps, newrowseps)
d992 1
a992 1
    def structureFromCells(self):
d1059 1
a1059 1
    enum.sequenceREs = {}
d1061 1
a1061 1
        enum.sequenceREs[sequence] = re.compile(enum.sequencepats[sequence]
d1072 1
a1072 1
    pats['nonAlphaNum7Bit'] = '[!-/:-@@[-`{-~]'
d1096 1
a1096 1
                'overline': r'(%(nonAlphaNum7Bit)s)\1\1\1+ *$' % pats,
d1249 1
a1249 1
                if self.enum.sequenceREs[expectedsequence].match(text):
d1260 1
a1260 1
                if self.enum.sequenceREs[sequence].match(text):
d1432 2
a1433 2
            except MarkupError, details:
                nodelist = self.malformedtable(block, str(details)) + warnings
d1487 1
a1487 1
        tgroup = nodes.tgroup(cols=str(len(colspecs)))
d1490 1
a1490 1
            tgroup += nodes.colspec(colwidth=str(colspec))
d1510 1
a1510 1
                attributes['morerows'] = str(morerows)
d1512 1
a1512 1
                attributes['morecols'] = str(morecols)
d1599 6
a1604 1
        type = match.group(1).lower()
d2090 1
a2090 1
def updateDictOfLists(master, newdata):
@


1.14
log
@  - Completed (& moved) TableParser.  - Added genuine table support.
@
text
@d4 2
a5 2
:Revision: $Revision: 1.13 $
:Date: $Date: 2001/09/04 04:13:27 $
d12 2
a13 1
    - `RSTStateMachine`: reStructuredText's customized StateMachine.
d30 1
d103 3
a105 1
__all__ = ['RSTStateMachine', 'MarkupError', 'ParserError']
d110 1
d127 6
a132 3
    def run(self, inputlines, inputoffset=0,
            warninglevel=1, errorlevel=3,
            memo=None, node=None, matchtitles=1):
d137 20
d158 194
a351 4
        When called initially (from outside, to parse a document), `memo` and
        `node` must *not* be supplied. When subsequently called (internally,
        to parse a portion of the document), `memo` and `node` *must* be
        supplied.
a352 2
        self.warninglevel = warninglevel
        self.errorlevel = errorlevel
d354 4
a357 19
        if memo is None:
            errorist = utils.Errorist(warninglevel, errorlevel)
            docroot = nodes.document(errorist)
            self.memo = Stuff(document=docroot,
                              errorist=errorist,
                              titlestyles=[],
                              sectionlevel=0,
                              matchfirstfields=1)
            self.node = docroot
        else:
            if self.debug:
                print >>sys.stderr, ('\nRSTStateMachine (recursive): node=%r'
                                     % node)
            self.memo = memo
            self.node = node
        if not self.memo.matchfirstfields:
            for state in self.states.values:
                if state.transitions.has_key('firstfield'):
                    state.removetransition('firstfield')
d359 2
a360 4
        assert results == [], 'RSTStateMachine results should be empty.'
        if memo is None:                # initial (external) call
            self.node = self.memo = None
            return docroot
d367 2
a388 2
        # XXX need to catch title as first element (after comments),
        # so firstfields will work
d450 1
a450 2
        sm = RSTStateMachine(stateclasses=stateclasses, initialstate='Body',
                             debug=self.debug)
d647 2
a648 2
        sw = self.statemachine.memo.errorist.system_warning(
              1, 'Inline %s start-string without end-string '
d683 2
a684 2
                    sw = self.statemachine.memo.errorist.system_warning(
                          1, 'Mismatch: inline interpreted text start-string '
d696 2
a697 2
        sw = self.statemachine.memo.errorist.system_warning(
              1, 'Inline interpreted text or phrase link start-string '
d712 2
a713 2
                sw = self.statemachine.memo.errorist.system_warning(
                      1, 'Multiple roles in interpreted text at line %s.'
d735 2
a736 3
            #self.statemachine.memo.document.addautofootnoteref(refname,
            #                                                   fnrefnode)
            fnrefnode['auto'] = 1
d840 2
a841 2
        return self.statemachine.memo.errorist.system_warning(
              1, ('Unindent without blank line at line %s.'
d1064 1
a1064 1
    
d1171 4
a1174 4
            sw = self.statemachine.memo.errorist.system_warning(
                  2, ('Enumerated list start value invalid at line %s: '
                      '%r (sequence %r)' % (self.statemachine.abslineno(),
                                            text, sequence)))
d1184 2
a1185 2
            sw = self.statemachine.memo.errorist.system_warning(
                  0, ('Enumerated list start value not ordinal-1 at line %s: '
d1323 2
a1324 2
            sw = self.statemachine.memo.errorist.system_warning(
                  2, ('Invalid option list marker at line %s: %s'
d1413 2
a1414 2
            sw = self.statemachine.memo.errorist.system_warning(
                  1, 'Blank line required after table at line %s.'
d1441 2
a1442 2
            warnings.append(self.statemachine.memo.errorist.system_warning(
                  2, 'Unexpected indentation at line %s.' % lineno))
d1476 1
a1476 1
        nodelist = [self.statemachine.memo.errorist.system_warning(2, message),
d1545 1
a1545 1
            #self.statemachine.memo.document.addautofootnote(name, f)
d1578 2
a1579 2
            t = self.statemachine.memo.errorist.system_warning(
                  1, 'Hyperlink target at line %s contains whitespace. '
d1686 2
a1687 2
                          self.statemachine.memo.errorist.system_warning(
                          1, detail.__class__.__name__ + ': ' + str(detail)))
d1697 2
a1698 2
            sw = self.statemachine.memo.errorist.system_warning(
                  3, 'Unexpected section title at line %s.' % lineno)
d1706 2
a1707 2
            sw = self.statemachine.memo.errorist.system_warning(
                  3, 'Incomplete section title at line %s.' % lineno)
d1714 2
a1715 2
            sw = self.statemachine.memo.errorist.system_warning(
                  3, 'Missing underline for overline at line %s.' % lineno)
d1719 2
a1720 2
            sw = self.statemachine.memo.errorist.system_warning(
                  3, 'Title overline & underline mismatch at ' 'line %s.'
d1727 2
a1728 2
                  self.statemachine.memo.errorist.system_warning(
                  0, 'Title overline too short at line %s.'% lineno)
d1916 2
a1917 2
            sw = self.statemachine.memo.errorist.system_warning(
                  3, 'Unexpected section title at line %s.' % lineno)
d1930 2
a1931 2
                  self.statemachine.memo.errorist.system_warning(
                  0, 'Title underline too short at line %s.' % lineno)
d1945 2
a1946 2
            sw = self.statemachine.memo.errorist.system_warning(
                  2, 'Unexpected indentation at line %s.' % lineno)
d1974 2
a1975 2
            nodelist.append(self.statemachine.memo.errorist.system_warning(
                  1, 'Literal block expected at line %s; none found.'
d1990 3
a1992 4
            d += self.statemachine.memo.errorist.system_warning(
                  0, 'Blank line missing before literal block? '
                  'Interpreted as a definition list item. '
                  'At line %s.' % (lineoffset + 1))
@


1.13
log
@  - TableParser.parsegrid() now working. Almost there...
@
text
@d4 2
a5 2
:Revision: $Revision: 1.12 $
:Date: $Date: 2001/09/02 13:49:29 $
d648 180
d863 2
a864 5
    tbl = Stuff()
    """Table parsing information."""

    tbl.pats = {'tableside': re.compile('[+|].+[+|]$'),
                'tabletop': re.compile(r'\+-[-+]+-\+ *$')}
d866 2
d893 1
a893 1
                'tabletop': tbl.pats['tabletop'],
d1226 7
a1232 3
            data = '\n'.join(block)
            t = nodes.literal_block(data, data)
            nodelist = [t] + warnings
d1255 1
a1255 1
        if not self.tbl.pats['tabletop'].match(block[-1]): # find bottom
d1259 1
a1259 1
                if self.tbl.pats['tabletop'].match(block[i]):
d1272 1
a1272 1
    def malformedtable(self, block):
d1274 7
a1280 5
        nodelist = [
              self.statemachine.memo.errorist.system_warning(
              2, 'Malformed table at line %s; formatting as a literal '
              'block.' % (self.statemachine.abslineno() - len(block) + 1)),
              nodes.literal_block(data, data)]
d1283 38
a1858 138


class TableParser:

    headBodySeparatorPat = re.compile(r'\+=[=+]+=\+$')

    def init(self, block):
        self.block = block[:]           # make a copy; it may be modified
        self.bottom = len(block) - 1
        self.right = len(block[0]) - 1
        self.headbodysep = None
        self.done = [-1] * len(block[0])
        self.cells = []
        self.rowseps = {0: [0]}
        self.colseps = {0: [0]}

    def parse(self, block):
        self.init(block)
        self.findheadbodysep()
        self.parsegrid()

    def findheadbodysep(self):
        for i in range(len(self.block)):
            line = self.block[i]
            if self.headBodySeparatorPat.match(line):
                if self.headbodysep:
                    raise MarkupError, ('Multiple head/body row separators '
                          'in table (at line offset %s and %s); only one '
                          'allowed.' % (self.headbodysep, i))
                else:
                    self.headbodysep = i
                    self.block[i] = line.replace('=', '-')

    def parsegrid(self):
        corners = [(0, 0)]
        while corners:
            top, left = corners.pop(0)
            if top == self.bottom or left == self.right \
                  or top <= self.done[left]:
                continue
            result = self.scancell(top, left)
            if not result:
                continue
            bottom, right, rowseps, colseps = result
            updateDictOfLists(self.rowseps, rowseps)
            updateDictOfLists(self.colseps, colseps)
            self.markdone(top, left, bottom, right)
            cellblock = self.getcellblock(top, left, bottom, right)
            self.cells.append((top, left, bottom, right, cellblock))
            corners.extend([(top, right), (bottom, left)])
            corners.sort()
        if not self.checkparsecomplete():
            raise MarkupError, 'Malformed table; parse incomplete.'

    def markdone(self, top, left, bottom, right):
        before = top - 1
        after = bottom - 1
        for col in range(left, right):
            assert self.done[col] == before
            self.done[col] = after

    def checkparsecomplete(self):
        last = self.bottom - 1
        for col in range(self.right):
            if self.done[col] != last:
                return None
        return 1

    def getcellblock(self, top, left, bottom, right):
        cellblock = []
        margin = right
        for lineno in range(top + 1, bottom):
            line = self.block[lineno][left + 1 : right].rstrip()
            cellblock.append(line)
            if line:
                margin = margin and min(margin, len(line) - len(line.lstrip()))
        if 0 < margin < right:
            cellblock = [line[margin:] for line in cellblock]
        return cellblock

    def scancell(self, top, left):
        assert self.block[top][left] == '+'
        result = self.scanright(top, left)
        return result

    def scanright(self, top, left):
        colseps = {}
        line = self.block[top]
        for i in range(left + 1, self.right + 1):
            if line[i] == '+':
                colseps[i] = [top]
                result = self.scandown(top, left, i)
                if result:
                    bottom, rowseps, newcolseps = result
                    updateDictOfLists(colseps, newcolseps)
                    return bottom, i, rowseps, colseps
            elif line[i] != '-':
                return None
        return None

    def scandown(self, top, left, right):
        rowseps = {}
        for i in range(top + 1, self.bottom + 1):
            if self.block[i][right] == '+':
                rowseps[i] = [right]
                result = self.scanleft(top, left, i, right)
                if result:
                    newrowseps, colseps = result
                    updateDictOfLists(rowseps, newrowseps)
                    return i, rowseps, colseps
            elif self.block[i][right] != '|':
                return None
        return None

    def scanleft(self, top, left, bottom, right):
        colseps = {}
        line = self.block[bottom]
        for i in range(right - 1, left, -1):
            if line[i] == '+':
                colseps[i] = [bottom]
            elif line[i] != '-':
                return None
        if line[left] != '+':
            return None
        result = self.scanup(top, left, bottom, right)
        if result is not None:
            rowseps = result
            return rowseps, colseps
        return None

    def scanup(self, top, left, bottom, right):
        rowseps = {}
        for i in range(bottom - 1, top, -1):
            if self.block[i][left] == '+':
                rowseps[i] = [left]
            elif self.block[i][left] != '|':
                return None
        return rowseps
@


1.12
log
@Fixed some syntax errors in TableParser (whose current code is a dead end anyway).
@
text
@d4 2
a5 2
:Revision: $Revision: 1.9 $
:Date: $Date: 2001/08/25 02:05:16 $
d23 2
a24 1
    - `Stuff`: an auxilliary collection class.
d1640 2
d1643 8
a1650 3
        self.block = block
        self.rowseps = {}
        self.colseps = {}
d1654 1
d1656 12
a1667 1
        headrows, bodyrows = self.parserows(rowseps, colseps)
d1670 33
a1702 2
        colseps = self.scanrowsep(0, 0)
        self.scancolseps(colseps, 0)
d1704 45
a1748 23
    def scanrowsep(self, lineindex, startcol):
        line = self.block[lineindex]
        nextline = self.block[lineindex + 1]
        if lineindex > 0:
            previousline = self.block[lineindex - 1]
        else:
            previousline = ''
        width = len(line)
        colindex = startcol
        colseps = []
        while colindex < width:
            if line[colindex] == '+':
                if nextline[colindex] == '|':
                    self.colseps.setdefault(colindex, 0)# += 1
                    colseps.append(1)
                elif not previousline or previousline[colindex] != '|':
                    raise MarkupError, ('Problem with table markup at '
                                        'line %s, column %s.' % (lineindex,
                                                                 colindex))
            elif line[colindex] not in '=-':
                break
            colindex += 1
        return colseps
d1750 24
a1773 10
    def scancolseps(self, colseps, startline):
        height = len(self.block)
        for colsep in colseps:
            lineindex = startline + 1
            while lineindex < height:
                if self.block[lineindex][colsep] == '+':
                    self.rowseps.setdefault(lineindex, 0)# += 1
                elif self.block[lineindex][colsep] != '|':
                    break
                lineindex += 1
d1799 4
@


1.11
log
@  - Began work on table support (class TableParser).
@
text
@d1666 1
a1666 1
                    self.colseps.setdefault(colindex, 0) += 1
d1668 1
a1668 1
                 elif not previousline or previousline[colindex] != '|':
d1683 1
a1683 1
                    self.rowseps.setdefault(lineindex, 0) += 1
@


1.10
log
@  - Added support for auto-numbered footnotes.  - Added support for classifier after term in definition list items.
@
text
@d319 1
a319 1
                                 | 
d322 1
a322 1
                                 | 
d336 2
a337 2
                                 | 
                                   \[           # footnote_reference start, 
d644 1
a644 1
                  % (self.statemachine.abslineno() + 1)))        
d654 2
a655 2
    """Enumerated list information."""
    
d676 1
a676 1
                       
d682 6
d713 1
a713 1
                'tabletop': r'\+-[-+]+-\+ *$',
d995 1
a995 1
        
d1044 11
a1054 1
        nodelist = []
d1060 1
a1060 1
            nodelist.append(self.statemachine.memo.errorist.system_warning(
d1063 1
d1065 2
a1066 1
            if block[i][0] not in '|+':
d1071 18
d1090 6
a1095 2
        nodelist.insert(0, nodes.literal_block(data, data))
        return nodelist, blankfinish
d1099 1
a1099 1
    
d1322 1
a1322 1
    
d1600 1
a1600 1
    
d1635 52
@


1.9
log
@  - Changed ``element.extend(nodelist)`` to ``element += nodelist``.
@
text
@d4 2
a5 2
:Revision: $Revision: 1.8 $
:Date: $Date: 2001/08/23 04:17:43 $
d319 2
a320 1
                                 | \*           # emphasis
d322 2
a323 1
                                 | ``           # literal
d336 8
a343 1
                                 | \[(%s)(\]_)  # footnote_reference, end (8,9)
d532 12
a543 3
        fnrefnode = nodes.footnote_reference('[%s]_' % fnname, fnname,
                                             refname=refname)
        self.statemachine.memo.document.addrefname(refname, fnrefnode)
d771 2
d1082 7
a1088 2
        f += nodes.label('', label)
        self.statemachine.memo.document.addimplicitlink(name, f)
a1089 1
            #print >>sys.stdout, 'Body.footnote: indented=%r' % indented
d1161 2
a1162 2
        indented, offset, blankfinish = \
              self.statemachine.getknownindented(match.end())
d1166 25
a1190 4
    explicit.constructs = [(re.compile(r'\.\. +\[(#|#?(%s))\](?: +|$)'
                                       % RSTState.inline.simplename), footnote),
                           (re.compile(r'\.\. +_'), hyperlink_target),
                           (re.compile(r'\.\. +([\w-]+)::(?: +|$)'), directive)]
d1218 1
a1218 1
        for pattern, method in constructs:
d1524 1
d1526 1
d1537 1
a1537 1
        i = nodes.definition_list_item('\n'.join(termline + indented), t, d)
d1541 1
a1541 1
        """Return a definition_list's term object."""
d1543 11
a1553 3
        textnodes, warnings = self.inline_text(lines[0], lineno)
        t = nodes.term(lines[0], '', *textnodes)
        return t, warnings
@


1.8
log
@  - Some refinements to temporary tables.  - Refixed literal blocks.  - Factored SpecializedText out of Text subclass.
@
text
@d4 2
a5 2
:Revision: $Revision: 1.7 $
:Date: $Date: 2001/08/22 03:33:54 $
d248 1
a248 1
        s.extend(warnings)
d1008 1
a1008 1
        self.statemachine.node.extend(nodelist)
d1150 1
a1150 1
        self.statemachine.node.extend(nodelist)
d1344 1
a1344 1
        self.statemachine.node.extend(nodelist)
d1365 1
a1365 1
        self.statemachine.node.extend(p)
d1367 1
a1367 1
            self.statemachine.node.extend(self.literal_block())
d1378 1
a1378 1
            self.statemachine.node.extend(p)
d1380 1
a1380 1
                self.statemachine.node.extend(self.literal_block())
d1447 1
a1447 1
        self.statemachine.node.extend(p)
d1454 1
a1454 1
            self.statemachine.node.extend(self.literal_block())
@


1.7
log
@  - Changed interpreted text roles to ':role:' syntax, outside of    backquotes.  - Simplified RSTState.inlineobj().  - Dropped leading '_' from footnotes.  - Dropped brackets from footnotes' implicit hyperlink names.  - Added VMS/DOS-style options to option lists.  - Added check for whitespace in hyperlinks.  - Added empty comment support.  - Began adding auto-numbered footnote support.  - Dropped requirement for blank line between definition list items.  - Fixed a bug with literal blocks (but the fix may have to be    fixed).
@
text
@d4 2
a5 2
:Revision: $Revision: 1.6 $
:Date: $Date: 2001/08/14 03:49:25 $
d689 1
a689 1
                'table': r'\+-[-+]+-\+ *$',
d699 1
a699 1
                          'table',
d1005 12
a1016 1
    def table(self, match, context, nextstate):
d1018 18
a1035 3
        data = '\n'.join(self.statemachine.gettextblock())
        self.statemachine.node += nodes.literal_block(data, data)
        return context, nextstate, []
d1253 1
a1253 1
    table = invalid_input
d1450 4
d1460 1
a1460 1
              self.statemachine.getindented(1)
d1501 1
a1501 1
class Definition(Text):
d1503 6
a1508 1
    """Second line of potential definition_list_item."""
d1510 4
a1513 1
    initialtransitions = ['underline', 'text']
d1515 2
a1516 2
    def not_definition(self, match, context, nextstate):
        """Not a definition."""
d1519 5
a1523 1
    blank = underline = text = not_definition
d1525 3
a1527 4
    def eof(self, context):
        """Not a definition."""
        self.statemachine.previousline(2)
        return []
@


1.6
log
@  - Factored SpecializedBody out of Body subclasses.  - Added support for field lists, option lists.  - Added temporary support for tables.  - Updated docstrings for new field list syntax.
@
text
@d3 3
a5 3
:Contact: dgoodger@@bigfoot.com
:Revision: $Revision: 1.5 $
:Date: $Date: 2001/08/11 02:13:23 $
d300 4
a303 2
    inline.start_string_prefix = r'(?:^|[ \n%s])' % re.escape(inline.openers)
    inline.end_string_suffix = r'(?:$|[- \n.,:;!?%s])' % re.escape(inline.closers)
d310 1
a310 1
    inline.emailc = r"""[-_!~*'{|}/#%?^`&=+$a-zA-Z0-9]"""
a321 2
                                 | `            # interpreted or phrase link
                                   (?!`)          # but not literal
d325 10
a334 3
                               (              # whole constructs (group 3):
                                   (%s)(_)      # link name, end-string (4,5)
                                 | \[(%s)(\]_)  # footnote_reference, end (6,7)
d341 2
d351 3
a353 12
                inline.non_whitespace_escape_before + '(`_?)'
                + inline.end_string_suffix),
          interpreted_role=re.compile(
                r"""
                  %s          # no whitespace/escape before
                  (:[ \n]+)   # prefix role (group 1)
                |           # *OR*
                  ([ \n]+:)   # suffix role (group 2)
                  %s          # no whitespace after
                """ % (inline.non_whitespace_escape_before,
                       inline.non_whitespace_after),
                re.VERBOSE),
d365 1
a365 1
                        //?                         # hierarchical URI
a367 4
                      |                           # OR
                        %s+(?:\.%s+)*               # opaque URI
                        (?:@@%s+(?:\.%s+)*)?         # (email only?)
                        %s                          # final URI char
d388 8
a395 6
                """ % ((inline.start_string_prefix, inline.uric, inline.urilast)
                       + (inline.emailc,) * 4
                       + (inline.urilast, inline.uric, inline.urilast,
                          inline.uric, inline.urilast)
                       + (inline.emailc,) * 4
                       + (inline.urilast, inline.end_string_suffix,)),
d397 4
a400 3
    inline.groups = Stuff(initial=Stuff(start=2, whole=3, linkname=4, linkend=5,
                                        footnotelabel=6, fnend=7),
                          interpreted_role=Stuff(prefix=1, suffix=2),
d408 2
a409 2
        start = match.start(self.inline.groups.initial.start)
        end = match.end(self.inline.groups.initial.start)
d431 12
a442 15
        else:
            endmatch = pattern.search(string[matchend:])
            if endmatch and endmatch.start(1):  # 1 or more chars
                text = unescape(endmatch.string[:endmatch.start(1)],
                                restorebackslashes)
                rawsource = unescape(
                      string[matchstart:matchend+endmatch.end(1)], 1)
                inlineobj = nodeclass(rawsource, text)
                return (string[:matchstart], [inlineobj],
                        string[matchend:][endmatch.end(1):], [])
            else:
                sw = self.statemachine.memo.errorist.system_warning(
                      1, 'Inline %s start-string without end-string '
                      'at line %s.' % (nodeclass.__name__, lineno))
                return (string[:matchend], [], string[matchend:], [sw])
d452 3
a454 1
          pattern=inline.patterns.interpreted_or_phrase_link):
d456 10
a465 3
        matchstart = match.start(self.inline.groups.initial.start)
        matchend = match.end(self.inline.groups.initial.start)
        if self.quotedstart(match):
d467 16
a482 19
        else:
            endmatch = pattern.search(string[matchend:])
            if endmatch and endmatch.start(1):  # 1 or more chars
                escaped = endmatch.string[:endmatch.start(1)]
                text = unescape(escaped, 0)
                rawsource = unescape(
                      string[matchstart:matchend+endmatch.end(1)], 1)
                if rawsource[-1] == '_':
                    refname = normname(text)
                    inlineobj = nodes.link(rawsource, text,
                                           refname=normname(text))
                    self.statemachine.memo.document.addrefname(refname,
                                                               inlineobj)
                    sw = []
                else:
                    inlineobj, sw = self.interpreted(lineno, escaped,
                                                     rawsource, text)
                return (string[:matchstart], [inlineobj],
                        string[matchend:][endmatch.end(1):], sw)
d484 20
d505 7
a511 19
                      1, 'Inline %s start-string without end-string '
                      'at line %s.' % (nodeclass.__name__, lineno))
                return (string[:matchend], [], string[matchend:], [sw])

    def interpreted(self, lineno, escaped, rawsource, text,
                    pattern=inline.patterns.interpreted_role,
                    prefix=inline.groups.interpreted_role.prefix,
                    suffix=inline.groups.interpreted_role.suffix):
        #print >>sys.stderr, 'RSTState.interpreted: rawsource=%r, text=%r' % (rawsource, text)
        sw = []
        match = pattern.search(escaped)
        if not match:
            return nodes.interpreted(rawsource, text), sw
        #print >>sys.stdout, 'RSTState.interpreted: match.groups=%r' % (match.groups(),)
        if match.group(prefix):
            #print >>sys.stderr, 'RSTState.interpreted: prefix matched! match.group(prefix)=%r' % (match.group(prefix),)
            role = normname(unescape(escaped[:match.start(prefix)]))
            aftercolon = escaped[match.end(prefix):]
            text = unescape(aftercolon)
d513 2
a514 10
            #print >>sys.stderr, 'RSTState.interpreted: suffix matched!'
            aftercolon = escaped[match.end(suffix):]
            role = normname(unescape(aftercolon))
            text = unescape(escaped[:match.start(suffix)])
        #print >>sys.stderr, 'RSTState.interpreted: aftercolon=%r' % aftercolon
        if pattern.search(aftercolon):
            sw.append(self.statemachine.memo.errorist.system_warning(
                  1, 'Multiple role-separators in interpreted text '
                  'at line %s.' % lineno))
        return nodes.interpreted(rawsource, text, role=role), sw
d521 1
a521 1
        fnname = '[%s]' % match.group(self.inline.groups.initial.footnotelabel)
d523 1
a523 1
        fnrefnode = nodes.footnote_reference(fnname + '_', fnname,
d594 1
d606 2
a607 1
                      dispatch[groups[start] or groups[linkend]
d675 2
a676 1
    pats['option'] = '(%(shortopt)s|%(longopt)s)' % pats
d979 1
a979 1
            elif tokens[0][:1] == '-':
d989 2
d1034 1
a1034 1
        name = normname('[' + label + ']')
d1037 1
a1037 1
        self.statemachine.memo.document.addexplicitlink(name, f)
d1039 1
a1039 1
            #rint >>sys.stdout, 'Body.footnote: indented=%r' % indented
d1056 1
a1056 1
        block[0] = unescape(targetmatch.string[targetmatch.end():], 1)
d1064 8
a1071 5
        reference = ''.join([line.strip() for line in block])
        t = nodes.target('\n'.join([match.string] + block[1:]), reference)
        if reference:
            self.statemachine.memo.document.addindirectlink(
                  name, reference, t, self.statemachine.node)
d1073 7
a1079 2
            self.statemachine.memo.document.addexplicitlink(
                  name, t, self.statemachine.node)
d1103 8
d1116 1
a1116 1
    explicit.constructs = [(re.compile(r'\.\. +_\[(%s)\](?: +|$)'
d1360 1
a1360 1
        i = self.definition_list_item(context)
d1367 1
d1371 2
d1429 2
a1430 1
        indented, indent, offset, blankfinish = self.statemachine.getindented()
d1435 2
a1440 2
        if not blankfinish:
            nodelist.append(self.unindentwarning())
d1453 1
a1453 1
                  2, 'Blank line missing before literal block? '
a1459 2
        if not blankfinish:
            d += self.unindentwarning()
d1461 1
a1461 1
        return i
d1490 1
a1490 1
        i = self.definition_list_item(context)
d1492 1
@


1.5
log
@  - Added support for enumerated lists (Body.enumerated(),    EnumeratedList).  - Fixed URI pattern to match absolute paths & news (opaque).  - Removed dependency on trailing spaces.  - Extracted Body.block_quote() from Body.indent().  - Changed underlines/overlines to require at least 4 characters    (avoids '...', '???', etc.).
@
text
@d2 5
a6 5
Author: David Goodger
Contact: dgoodger@@bigfoot.com
Revision: $Revision: 1.3 $
Date: $Date: 2001/08/01 03:00:54 $
Copyright: This module has been placed in the public domain.
d9 1
a9 1
reStructuredText parser. It defines the following classes:
d11 22
a32 10
- `RSTStateMachine`: reStructuredText's customized StateMachine.
- `RSTState`: reStructuredText State superclass.
- `Body`: Generic classifier of the first line of a block.
- `BulletList`: Second and subsequent bullet_list list_items
- `EnumeratedList`: Second and subsequent enumerated_list list_items.
- `DefinitionList`: Second and subsequent definition_list_items.
- `Explicit`: Second and subsequent explicit markup constructs.
- `Text`: Classifier of second line of a text block.
- `Definition`: Second line of potential definition_list_item.
- `Stuff`: an auxilliary collection class.
d34 2
a35 14
Exception classes:

- `MarkupError`
- `ParserError`

Functions:

- `escape2null()`: Return a string with escape-backslashes converted to nulls.
- `unescape()`: Return a string with nulls removed or restored to backslashes.
- `normname()`: Return a case- and whitespace-normalized name.

Attributes:

- `stateclasses`: set of State classes used with `RSTStateMachine`.
d195 2
a196 1
        Raise `EOFError` when a sibling or supersection encountered.
d664 2
d668 4
d679 1
a679 1
                'enumerated': r'(%(parens)s|%(rparen)s|%(period)s)( +|$)'
d681 2
a682 1
                'option': r'(-\w|--\w[\w-]*).*?  ',
d687 1
a687 1
                'firstfield': r'[!-9;-~]+:( +|$)',
d690 3
a692 2
                          'enumerated',
                          'option',
d697 1
a697 2
                          #('firstfield', 'Field'),
                          ('text', 'Text')]
d744 15
a758 1
    def enumerated(self, match, context, nextstate):
d808 18
a825 1
    def parseenumerator(self, match, trysequence=None):
d829 2
a830 2
            if groupdict[format]:
                break
d835 7
a841 1
        if not trysequence:
a845 6
        else:
            try:
                if self.enum.sequenceREs[trysequence].match(text):
                    sequence = trysequence
            except KeyError:            # shouldn't happen
                raise ParserError, 'unknown sequence: %s' % sequence
d858 134
a991 2
    def option(self, match, context, nextstate):
        return context, nextstate, []
d999 3
a1178 3
    def firstfield(self, match, context, nextstate):
        return context, nextstate, []

d1181 2
a1182 1
        return [match.string], nextstate, []
d1184 24
a1207 13
    def list_item(self, indent):
        indented, lineoffset, blankfinish = \
              self.statemachine.getknownindented(indent)
        if self.debug:
            print >>sys.stderr, ('\nstates.Body.list_item: indented=%r'
                                 % indented)
        i = nodes.list_item('\n'.join(indented))
        if indented:
            sm = self.indentSM(debug=self.debug, **self.indentSMkwargs)
            sm.run(indented, inputoffset=lineoffset,
                   memo=self.statemachine.memo, node=i, matchtitles=0)
            sm.unlink()
        return i, blankfinish
d1210 1
a1210 1
class BulletList(Body):
d1218 1
a1218 1
            self.not_list_item()
a1223 4
    def not_list_item(self, match=None, context=None, nextstate=None):
        """Not a list item."""
        self.statemachine.previousline()
        raise EOFError
d1225 7
a1231 2
    indent = enumerated = option = doctest = table = explicit_markup \
             = overline = text = not_list_item
d1234 1
a1234 1
class EnumeratedList(Body):
d1238 1
a1238 1
    def enumerated(self, match, context, nextstate):
d1246 1
a1246 1
            self.not_list_item()
a1252 4
    def not_list_item(self, match=None, context=None, nextstate=None):
        """Not a list item."""
        self.statemachine.previousline()
        raise EOFError
d1254 13
a1266 2
    indent = bullet = option = doctest = table = explicit_markup = overline \
             = text = not_list_item
d1268 1
d1270 9
a1278 1
class DefinitionList(Body):
a1279 1
    """Second and subsequent definition_list_items."""
d1281 1
a1281 3
    def text(self, match, context, nextstate):
        """Definition lists."""
        return [match.string], 'Definition', []
d1283 1
a1283 4
    def not_definition_list_item(self, match, context, nextstate):
        """Not a definition list item."""
        self.statemachine.previousline()
        raise EOFError
d1285 1
a1285 2
    indent = bullet = enumerated = option = doctest = table = explicit_markup \
             = overline = not_definition_list_item
d1288 1
a1288 1
class Explicit(Body):
a1298 8
    def not_explicit(self, match, context, nextstate):
        """Not an explicit construct."""
        self.statemachine.previousline()
        raise EOFError

    indent = bullet = enumerated = option = doctest = table = overline = text \
             = not_explicit

d1470 2
a1471 2
stateclasses = [Body, BulletList, EnumeratedList, DefinitionList, Explicit,
                Text, Definition]
@


1.4
log
@- Undid yesterday's error (un-"set '.errorist' on each state object for convenience" -- not possible).- Extracted checksubsection() and newsubsection() from RSTState.section().- Fixed bugs with overline-section-header level parsing.
@
text
@d15 1
d25 1
d97 1
a97 1
from dps import nodes, statemachine, utils
d100 1
a100 1
__all__ = ['RSTStateMachine', 'MarkupError']
d104 1
d364 1
a364 1
                        //                          # hierarchical URI
d369 2
a370 1
                        @@%s+(?:\.%s+)*%s            # (email only?)
d386 1
a386 1
                    %s+(?:\.%s*)*              # host
d630 33
a662 6
    pats = {'arabic': '[0-9]+',
            'loweralpha': '[a-z]',
            'upperalpha': '[A-Z]',
            'lowerroman': '[ivxlcdm]+',
            'upperroman': '[IVXLCDM]+',
            'nonAlphaNum7Bit': '[!-/:-@@[-`{-~]'}
d664 1
a664 4
                    '|%(upperroman)s)' % pats)
    pats['parens'] = r'(?P<parens>\(%(enum)s\))' % pats
    pats['rightparen'] = r'(?P<rightparen>%(enum)s\))' % pats
    pats['period'] = r'(?P<period>%(enum)s\.)' % pats
d666 8
a673 2
    patterns = {'bullet': r'[-+*] +',
                'enum': r'(%(parens)s|%(rightparen)s|%(period)s) +' % pats,
d675 1
a675 1
                'doctest': r'>>> ',
d678 1
a678 1
                'overline': r'(%(nonAlphaNum7Bit)s)\1\1+ *$' % pats,
d682 1
a682 1
                          'enum',
d698 7
a705 1
        self.statemachine.node += bq
d710 1
a710 3
        if not blankfinish:
            self.statemachine.node += self.unindentwarning()
        return context, nextstate, []
d736 82
a817 3
    def enum(self, match, context, nextstate):
        """Potential Enumerated List Item"""
        return context, nextstate, []
d1046 29
a1074 1
    indent = enum = option = doctest = table = explicit_markup = overline \
d1091 1
a1091 1
    indent = bullet = enum = option = doctest = table = explicit_markup \
d1111 2
a1112 2
    indent = bullet = enum = option = doctest = table = text = \
             not_explicit
d1123 1
a1123 1
    patterns = {'underline': r'([!-/:-@@[-`{-~])\1\1+ *$',
d1285 2
a1286 2
stateclasses = [Body, Text, BulletList, DefinitionList, Definition,
                Explicit]
@


1.3
log
@added docstrings; set '.errorist' on each state object for convenience; changed RSTStateMachine.run() to return the document instance
@
text
@d4 2
a5 2
Revision: $Revision: 1.2 $
Date: $Date: 2001/07/28 05:16:59 $
d122 2
d155 1
a155 1
        if memo is none:                # initial (external) call
a166 4

        self.errorist = statemachine.memo.errorist
        """Shortcut to error/warning generator."""

d186 8
d196 2
a197 2
        try:
            mylevel = memo.sectionlevel
a198 15
            if self.debug:
                print >>sys.stderr, ('\nstates.RSTState.section: mylevel=%s, '
                                     'new level=%s (exists)' % (mylevel, level))
            if level <= mylevel:        # sibling or supersection
                memo.sectionlevel = level
                self.statemachine.previousline(2)
                raise EOFError          # return to parent section
            if level == mylevel + 1:    # subsection
                memo.sectionlevel += 1
            else:
                sw = self.errorist.strong_system_warning(
                      'ABORT', 'Title level inconsistent at line %s:' % lineno,
                      source)
                self.statemachine.node += sw
                return
d200 1
a200 2
            if len(titlestyles) == memo.sectionlevel:
                memo.sectionlevel += 1
d202 5
d208 1
a208 1
                sw = self.errorist.strong_system_warning(
d212 24
a235 1
                return
d237 2
a238 2
            print >>sys.stderr, ('\nstates.RSTState.section: starting a new '
                                 'subsection (level %s)' % (mylevel + 1))
d240 1
a252 1
        self.statemachine.node += s
d254 1
a254 1
            print >>sys.stderr, ('\nstates.RSTState.section: back from '
d264 2
a265 2
        if memo.sectionlevel <= mylevel:
            raise EOFError              # pass on to supersection
d438 1
a438 1
                sw = self.errorist.system_warning(
d477 1
a477 1
                sw = self.errorist.system_warning(
d504 1
a504 1
            sw.append(self.errorist.system_warning(
d615 1
a615 1
        return self.errorist.system_warning(
d840 1
a840 1
                          self.errorist.system_warning(
d851 1
a851 1
            sw = self.errorist.system_warning(
d855 1
a856 1
            title = underline = ''
d860 1
a860 1
            sw = self.errorist.system_warning(
d864 1
a864 1
        source = match.string + title + underline
d868 1
a868 1
            sw = self.errorist.system_warning(
d873 1
a873 1
            sw = self.errorist.system_warning(
d878 1
a878 1
        title = title.strip()
d881 1
a881 1
                  self.errorist.system_warning(
d885 1
a885 1
            self.section(title, source, style, lineno + 1)
d1028 1
a1028 1
            sw = self.errorist.system_warning(
d1042 1
a1042 1
                  self.errorist.system_warning(
d1057 1
a1057 1
            sw = self.errorist.system_warning(
d1079 1
a1079 1
            nodelist.append(self.errorist.system_warning(
d1095 1
a1095 1
            d += self.errorist.system_warning(
@


1.2
log
@Patch 443276 "comment handling" -- doesn't "swallow" empty comments, but fixed it so outdenting doesn't fail (I'm not 100% sure this is the right thing to do though).Bug 443270 "bad footnote labels not caught" -- generate a warning for malformed hyperlink targets.Bug 443294 "text after interpreted breakage" -- modified start-string prefix & end-string suffixes to allow for this.
@
text
@d4 2
a5 2
Revision: $Revision: 1.1.1.1 $
Date: $Date: 2001/07/21 22:14:09 $
d8 2
d11 81
d98 1
a98 1
__all__ = ['RSTStateMachine']
d121 9
a129 2
        """Extend `StateMachineWS.run()`: set up document-wide data."""
        self.warninglevel=warninglevel
d151 5
a155 1
        return StateMachineWS.run(self, inputlines, inputoffset)
d165 4
d203 1
a203 1
                sw = memo.errorist.strong_system_warning(
d213 1
a213 1
                sw = memo.errorist.strong_system_warning(
d420 1
a420 1
                sw = self.statemachine.memo.errorist.system_warning(
d459 1
a459 1
                sw = self.statemachine.memo.errorist.system_warning(
d486 1
a486 1
            sw.append(self.statemachine.memo.errorist.system_warning(
d597 1
a597 1
        return self.statemachine.memo.errorist.system_warning(
d604 3
a606 1
    """Identifier of first line of a body element or section title."""
d647 1
a651 1
        self.statemachine.node += bq
d659 1
a662 1
        self.statemachine.node += l
d822 1
a822 1
                          self.statemachine.memo.errorist.system_warning(
d833 1
a833 1
            sw = self.statemachine.memo.errorist.system_warning(
d842 1
a842 1
            sw = self.statemachine.memo.errorist.system_warning(
d850 1
a850 1
            sw = self.statemachine.memo.errorist.system_warning(
d855 1
a855 1
            sw = self.statemachine.memo.errorist.system_warning(
d863 1
a863 1
                  self.statemachine.memo.errorist.system_warning(
d955 1
a955 1
    Second line of a text block.
d1010 1
a1010 1
            sw = self.statemachine.memo.errorist.system_warning(
d1024 1
a1024 1
                  self.statemachine.memo.errorist.system_warning(
d1039 1
a1039 1
            sw = self.statemachine.memo.errorist.system_warning(
d1061 1
a1061 1
            nodelist.append(self.statemachine.memo.errorist.system_warning(
d1077 1
a1077 1
            d += self.statemachine.memo.errorist.system_warning(
@


1.1
log
@Initial revision
@
text
@d4 2
a5 2
Revision: $Revision: 1.2 $
Date: $Date: 2001/07/20 00:38:11 $
d18 1
a18 1
class MarkupError: pass
d180 2
a181 2
    inline.start_string_prefix = r'(?:^|[ \n])[%s]*' % re.escape(inline.openers)
    inline.end_string_suffix = r'[.,:;!?%s-]*(?:[ \n]|$)' % re.escape(inline.closers)
d187 1
d246 2
a247 1
                        %s+?                        # URI characters
d250 1
a250 1
                        @@%s+(?:\.%s+)*              # (email only?)
d253 2
a254 1
                        \?%s*?
d257 2
a258 1
                        \#%s*?
d266 2
a267 1
                    %s+?(?:\.%s+?)*             # host
d271 1
a271 1
                """ % ((inline.start_string_prefix, inline.uric)
d273 2
a274 1
                       + (inline.uric, inline.uric)
d276 1
a276 1
                       + (inline.end_string_suffix,)),
d636 2
a637 1
            raise MarkupError('not a hyperlink target')
d679 2
a680 2
        indented, indent, offset, blankfinish = \
              self.statemachine.getfirstknownindented(match.end())
d714 1
d720 4
a723 1
                except MarkupError:
d725 2
a726 1
        return self.comment(match)
@


1.1.1.1
log
@initial checkin
@
text
@@
